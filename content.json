[{"title":"作用域，连接属性以及存储类型","date":"2020-10-15T08:47:34.000Z","path":"2020/10/C-scope-linkage-and-storage-class/","text":"逃避手中的难事，看看 C 中标识符的作用域、链接属性和存储类型是如何区分的吧。 以下内容为阅读《C 和指针》时做的笔记。pp39-47。 作用域当变量在程序的某个部分被声明时，它只有在程序的一定区域才能被访问，这个区域由标识符的作用域决定。 标识符的作用域就是程序中该标识符可以被使用的区域。 这意味着，作用域之外无法访问这些变量，分属不同作用域的变量可以有相同的名字。 编译器可以确认 4 种不同类型的作用域——文件作用域、函数作用域、代码作用域和原型作用域。标识符声明的位置决定它的作用域。 代码块作用域：位于一堆花括号之间的所有语句称为一个代码块，任何在代码块开始位置声明的标识符都具有代码块作用域（block scope）。 文件作用域：任何在代码块之外声明的标识符都具有文件作用域（file scope）。它表示这些标识符从它们的声明之处直到它所在的源文件结尾处都是可以访问的。文件中定义的函数名也具有文件作用域。 原型作用域：只适用于在函数原型中声明的参数名。 函数作用域：只适用于语句标签，在goto 语句中使用。（不用理会） 链接属性标识符的链接属性决定如何处理在不同文件中出现的标识符。标识符的作用域与它的链接属性有关，但两个属性并不相同。 链接属性一共 3 种——external、internal 和 none。 none：拥有该属性的标识符被当作单独的个体，即该标识符的多个声明被当作独立不同的实体。 internal：拥有该属性的标识符在同一个源文件内的所有声明都指同一个实体，位于不同源文件的多个声明分属不同的实体。 external：拥有该属性的标识符不论声明多少次，位于多个源文件的标识符都表示同一实体。 如下例子所示，其中，b、c 和 f 的链接属性为 external，其余标识符的链接属性为 none。 12345678typedef char *a;int b;int c( int d )&#123; int e; int f(int g); ...&#125; 除了缺省时的链接属性之外，关键字 extern 和 static 用于在声明中修改标识符的链接属性。 如果某个声明缺省时为 external 链接属性，在它前面加上 static 关键字可以使它的链接属性变为 internal。如：static int b;。那么变量 b 将为这个源文件所私有。此外，static只对缺省链接属性为 external 的声明才有改变链接属性的效果。 external 关键字的规则更加复杂。一般来说，当它为一个标识符指定 external 链接属性时，就可以访问在其他任何位置定义的这个实体。 如果你在一个地方定义变量，请在使用这个变量的其他源文件的声明中添加 extern 关键字。 当 extern 关键字用于源文件中一个标识符的第 1 次声明时，它指定该标识符具有 external 链接属性，但如果它用于该标识符的第 2 次或以后的声明时，它并不会更改由第 1 次声明所指定的链接属性。 存储类型变量的存储类型是指存储变量值的内存类型，它决定变量何时创建、何时销毁以及它的值讲保持多久。三种类型：普通内存、运行时堆栈和硬件寄存器。 变量缺省存储类型取决于它的声明位置。凡是在任何代码块之外声明的变量总是存储于静态内存中，即不属于堆栈的内存，这类变量被称为静态变量。这类变量无法为其指定存储类型。静态变量在程序执行前创建，一直存在。 在代码块内部声明的变量的缺省存储类型是自动的（automatic），即它存储于堆栈中，称为自动变量。自动变量在代码块执行完毕后就消失，当代码块再次执行时，它们的值一般并不是上次执行时的值。注意，修改变量的存储类型并不表示修改该变量的作用域，它仍然只能在该代码块内部按照名字访问。 静态变量和自动变量的初始化存在重要差别。静态变量在可执行文件载入内存时，已经保存了正确初始值的位置将赋值给那个变量，完成这个任务不需要额外的时间和指令，默认初始化为 0。而自动变量的初始化需要更多的开销。事实上，自动变量没有缺省的初始值，而显示初始化将在代码块的起始处插入一条隐式的赋值语句，这导致： 除声明 const 变量之外，在声明变量时同时进行初始化和先声明后赋值只有风格之差，而无效率之别。 这条隐式的赋值语句使自动变量在程序执行到它们所声明的函数时，每次都将重新初始化。 由于初始化在程序运行时执行，因而可以用任何表达式作为初始化值。 若不对自动变量进行初始化，其值总是垃圾。 static 关键字如前面所言，static 关键字有两个用途：修改链接属性和修改存储类型。 当 static 用于函数定义时，或用于代码块之外的变量声明时，它用于修改标识符的链接属性，从 external 改为 internal，但不影响标识符的存储类型和作用域。用这种方式声明的函数或变量只能在声明它们的源文件中访问。 当它用于代码块内部的变量时，static 关键字用于修改变量的存储类型，从自动变量改为静态变量，但变量的链接属性和作用域不受影响。 总结 变量类型 声明的位置 是否存储于堆栈 作用域 如果声明为 static 全局 所有代码块之外 否 从声明处到文件尾 不允许其他源文件访问 局部 代码块起始处 是 整个代码块 变量不存储于堆栈中，其值在程序整个执行期一直保持 形式参数 函数头部 是 整个函数 不允许","content":"<p>逃避手中的难事，看看 C 中标识符的作用域、链接属性和存储类型是如何区分的吧。</p>\n<p>以下内容为阅读《C 和指针》时做的笔记。pp39-47。</p>\n<a id=\"more\"></a>\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><p>当变量在程序的某个部分被声明时，它只有在程序的一定区域才能被访问，这个区域由标识符的作用域决定。</p>\n<blockquote>\n<p>标识符的作用域就是程序中该标识符可以被使用的区域。</p>\n</blockquote>\n<p>这意味着，作用域之外无法访问这些变量，分属不同作用域的变量可以有相同的名字。</p>\n<p>编译器可以确认 4 种不同类型的作用域——文件作用域、函数作用域、代码作用域和原型作用域。标识符声明的位置决定它的作用域。</p>\n<ul>\n<li><strong>代码块作用域</strong>：位于一堆花括号之间的所有语句称为一个代码块，任何在代码块开始位置声明的标识符都具有代码块作用域（block scope）。</li>\n<li><strong>文件作用域</strong>：任何在代码块之外声明的标识符都具有文件作用域（file scope）。它表示这些标识符从它们的声明之处直到它所在的源文件结尾处都是可以访问的。文件中定义的函数名也具有文件作用域。</li>\n<li><strong>原型作用域</strong>：只适用于在函数原型中声明的参数名。</li>\n<li><strong>函数作用域</strong>：只适用于语句标签，在<code>goto</code> 语句中使用。（不用理会）</li>\n</ul>\n<h2 id=\"链接属性\"><a href=\"#链接属性\" class=\"headerlink\" title=\"链接属性\"></a>链接属性</h2><p>标识符的链接属性决定如何处理在不同文件中出现的标识符。标识符的作用域与它的链接属性有关，但两个属性并不相同。</p>\n<p>链接属性一共 3 种——<code>external</code>、<code>internal</code> 和 <code>none</code>。</p>\n<ul>\n<li><code>none</code>：拥有该属性的标识符被当作单独的个体，即该标识符的多个声明被当作独立不同的实体。</li>\n<li><code>internal</code>：拥有该属性的标识符在同一个源文件内的所有声明都指同一个实体，位于不同源文件的多个声明分属不同的实体。</li>\n<li><code>external</code>：拥有该属性的标识符不论声明多少次，位于多个源文件的标识符都表示同一实体。</li>\n</ul>\n<p>如下例子所示，其中，b、c 和 f 的链接属性为 external，其余标识符的链接属性为 none。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">char</span> *a;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">c</span><span class=\"params\">( <span class=\"keyword\">int</span> d )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> e;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span> g)</span></span>;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>除了缺省时的链接属性之外，关键字 <code>extern</code> 和 <code>static</code> 用于在声明中修改标识符的链接属性。</p>\n<p>如果某个声明缺省时为 <code>external</code> 链接属性，在它前面加上 <code>static</code> 关键字可以使它的链接属性变为 <code>internal</code>。如：<code>static int b;</code>。那么变量 b 将为这个源文件所私有。此外，<strong><code>static</code>只对缺省链接属性为 <code>external</code> 的声明才有改变链接属性的效果</strong>。</p>\n<p><code>external</code> 关键字的规则更加复杂。一般来说，<strong>当它为一个标识符指定 <code>external</code> 链接属性时，就可以访问在其他任何位置定义的这个实体</strong>。</p>\n<blockquote>\n<p>如果你在一个地方定义变量，请在使用这个变量的其他源文件的声明中添加 <code>extern</code> 关键字。</p>\n</blockquote>\n<p>当 <code>extern</code> 关键字用于源文件中一个标识符的第 1 次声明时，它指定该标识符具有 <code>external</code> 链接属性，但如果它用于该标识符的第 2 次或以后的声明时，它并不会更改由第 1 次声明所指定的链接属性。</p>\n<h2 id=\"存储类型\"><a href=\"#存储类型\" class=\"headerlink\" title=\"存储类型\"></a>存储类型</h2><p>变量的存储类型是指存储变量值的内存类型，它决定变量何时创建、何时销毁以及它的值讲保持多久。三种类型：普通内存、运行时堆栈和硬件寄存器。</p>\n<p><strong>变量缺省存储类型取决于它的声明位置。</strong>凡是在任何代码块之外声明的变量总是存储于静态内存中，即不属于堆栈的内存，这类变量被称为<em>静态变量</em>。这类变量无法为其指定存储类型。静态变量在程序执行前创建，一直存在。</p>\n<p>在代码块内部声明的变量的缺省存储类型是自动的（automatic），即它存储于堆栈中，称为<strong>自动变量</strong>。自动变量在代码块执行完毕后就消失，当代码块再次执行时，它们的值一般并不是上次执行时的值。注意，修改变量的存储类型并不表示修改该变量的作用域，它仍然只能在该代码块内部按照名字访问。</p>\n<p>静态变量和自动变量的初始化存在重要差别。静态变量在可执行文件载入内存时，已经保存了正确初始值的位置将赋值给那个变量，完成这个任务不需要额外的时间和指令，默认初始化为 0。而自动变量的初始化需要更多的开销。事实上，自动变量没有缺省的初始值，而显示初始化将在代码块的起始处插入一条隐式的赋值语句，这导致：</p>\n<ul>\n<li>除声明 const 变量之外，在声明变量时同时进行初始化和先声明后赋值只有风格之差，而无效率之别。</li>\n<li>这条隐式的赋值语句使自动变量在程序执行到它们所声明的函数时，每次都将重新初始化。</li>\n<li>由于初始化在程序运行时执行，因而可以用任何表达式作为初始化值。</li>\n<li>若不对自动变量进行初始化，其值总是垃圾。</li>\n</ul>\n<h2 id=\"static-关键字\"><a href=\"#static-关键字\" class=\"headerlink\" title=\"static 关键字\"></a><code>static</code> 关键字</h2><p>如前面所言，<code>static</code> 关键字有两个用途：修改链接属性和修改存储类型。</p>\n<p>当 <code>static</code> 用于函数定义时，或用于代码块之外的变量声明时，它用于修改标识符的链接属性，从 <code>external</code> 改为 <code>internal</code>，但不影响标识符的存储类型和作用域。用这种方式声明的函数或变量只能在声明它们的源文件中访问。</p>\n<p>当它用于代码块内部的变量时，static 关键字用于修改变量的存储类型，从自动变量改为静态变量，但变量的链接属性和作用域不受影响。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><table>\n<thead>\n<tr>\n<th>变量类型</th>\n<th>声明的位置</th>\n<th>是否存储于堆栈</th>\n<th>作用域</th>\n<th>如果声明为 <code>static</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>全局</td>\n<td>所有代码块之外</td>\n<td>否</td>\n<td>从声明处到文件尾</td>\n<td>不允许其他源文件访问</td>\n</tr>\n<tr>\n<td>局部</td>\n<td>代码块起始处</td>\n<td>是</td>\n<td>整个代码块</td>\n<td>变量不存储于堆栈中，其值在程序整个执行期一直保持</td>\n</tr>\n<tr>\n<td>形式参数</td>\n<td>函数头部</td>\n<td>是</td>\n<td>整个函数</td>\n<td>不允许</td>\n</tr>\n</tbody>\n</table>\n","tags":[{"name":"C/C++","slug":"C-C","permalink":"https://jonathan1214.github.io/tags/C-C/"}]},{"title":"一张实验室电脑的软件清单","date":"2020-10-10T05:26:17.000Z","path":"2020/10/windows-software-list/","text":"最多两周后，需要搬到隔壁实验室去，大概会配一台电脑，在此列一张需要安装的软件清单，如果可以的话，最好列出获取软件的方式。 uTorrent 360 压缩 Altium Designer Anaconda Android Studio（-） CCleaner doxygen foxmail git GitHub Desktop Google Chrome Java KeePass Password Safe Keil 4 Mathpix Snipping Tool MathType MATLAB Office, Visio VScode VS Modelsim Node.js Notepad++ Fiddler PuTTy Python Quartus 13.1 ScreenToGif ShowMore Stardock Fences3 Steam Wallpaper Engine TeamViewer Typora Vim VMware WinSCP Wireshark Wolfram Engine XMind 百度网盘 坚果云 欧路词典 QQ 网易云音乐 微信 rime 输入法 桌面日历 补充： endnote Snipaste ToDo","content":"<p>最多两周后，需要搬到隔壁实验室去，大概会配一台电脑，在此列一张需要安装的软件清单，如果可以的话，最好列出获取软件的方式。<br><a id=\"more\"></a></p>\n<ul>\n<li>uTorrent</li>\n<li>360 压缩</li>\n<li>Altium Designer</li>\n<li>Anaconda</li>\n<li>Android Studio（-）</li>\n<li>CCleaner</li>\n<li>doxygen</li>\n<li>foxmail</li>\n<li>git</li>\n<li>GitHub Desktop</li>\n<li>Google Chrome</li>\n<li>Java</li>\n<li>KeePass Password Safe</li>\n<li>Keil 4</li>\n<li>Mathpix Snipping Tool</li>\n<li>MathType</li>\n<li>MATLAB</li>\n<li>Office, Visio</li>\n<li>VScode</li>\n<li>VS</li>\n<li>Modelsim</li>\n<li>Node.js</li>\n<li>Notepad++</li>\n<li>Fiddler</li>\n<li>PuTTy</li>\n<li>Python</li>\n<li>Quartus 13.1</li>\n<li>ScreenToGif</li>\n<li>ShowMore</li>\n<li>Stardock Fences3</li>\n<li>Steam Wallpaper Engine</li>\n<li>TeamViewer</li>\n<li>Typora</li>\n<li>Vim</li>\n<li>VMware</li>\n<li>WinSCP</li>\n<li>Wireshark</li>\n<li>Wolfram Engine</li>\n<li>XMind</li>\n<li>百度网盘</li>\n<li>坚果云</li>\n<li>欧路词典</li>\n<li>QQ</li>\n<li>网易云音乐</li>\n<li>微信</li>\n<li>rime 输入法</li>\n<li>桌面日历</li>\n</ul>\n<p>补充：</p>\n<ul>\n<li>endnote</li>\n<li>Snipaste</li>\n<li>ToDo</li>\n</ul>\n","tags":[{"name":"记录","slug":"记录","permalink":"https://jonathan1214.github.io/tags/记录/"}]},{"title":"生 日","date":"2020-10-07T14:53:02.000Z","path":"2020/10/to-tata/","text":"如果还在，49 了。 放心，一切都好。","content":"<p>如果还在，49 了。</p>\n<p>放心，一切都好。</p>\n","tags":[{"name":"记录","slug":"记录","permalink":"https://jonathan1214.github.io/tags/记录/"}]},{"title":"一次一次又一次的拖延，能逃离这个怪圈吗？","date":"2020-10-04T10:59:12.000Z","path":"2020/10/again-again-agin-delay/","text":"2 号老师告诉我们 8 号提交开题报告给她，现在已经 4 号晚上了，我还是几乎一字未动。是我拖延症又犯了，还是我根本不配写，关于这个问题，我决定好好考虑下，现在也写不下去，考虑下这个问题也挺好。首先明确一点，不管配不配，这个报告我都必须写完。在这个基础上，再去考虑下一步：我要写出一个什么样的报告？为了这个目标我需要去做哪些事情？如果仅仅只是为了写完报告，那么我大可以找几篇硕士论文，把他们的前面部分进行一些糅合，就可以得到一份报告了，这种方式不失为一个选择，但也面临着问题：我到底要做的是什么东西？这个问题的优先级甚至还可以再提一提。或许我早就有了前面那个问题的答案：简单做一个编译码器即可，但简单搜索之后，我感到很难受，因为这件事情别人早就做过了，甚至已经做得挺好了，而我只是一个新手，也要去做相同的事情，我下意识地想逃避了。 话说回来，我从心底是喜欢做这个东西的，我只是讨厌写报告，因为我不擅长写，非要写的话我会写得很烂，这让我感到很难受，这种感觉太真实了，我又把成长型思维抛到脑后了。现在让我尝试用这种思维进行思考：无论最终我的报告写得怎么样，我做的这个东西有没有得到认可以从而让我能够顺利毕业，我都要努力去完成，这是出于对老师的信任，而且我不该纠结于表面的批评，应该更深一步地考虑，将这看成是我成长的机会。报告写得烂，那就烂吧，我努力了，这次写得烂，那么给我建议吧，下一次我会让它变得更好。毕设做的东西毫无创新，不能通过，那可不行，我已经完成了。 还有一个问题，如果有不确定的地方，不要再过多考虑了，那只是徒劳，尽早去寻求帮助吧。不要高估了自己，我需要帮助，这是快速进步的秘诀。 话已至此，希望我真心听进去了，还剩下三天时间，加油写完吧，更重要的事是，记住这种感觉，这比什么都重要。人生没有这么短，路还长。","content":"<p>2 号老师告诉我们 8 号提交开题报告给她，现在已经 4 号晚上了，我还是几乎一字未动。是我拖延症又犯了，还是我根本不配写，关于这个问题，我决定好好考虑下，现在也写不下去，考虑下这个问题也挺好。<br><a id=\"more\"></a><br>首先明确一点，不管配不配，这个报告我都必须写完。在这个基础上，再去考虑下一步：我要写出一个什么样的报告？为了这个目标我需要去做哪些事情？如果仅仅只是为了写完报告，那么我大可以找几篇硕士论文，把他们的前面部分进行一些糅合，就可以得到一份报告了，这种方式不失为一个选择，但也面临着问题：我到底要做的是什么东西？这个问题的优先级甚至还可以再提一提。或许我早就有了前面那个问题的答案：简单做一个编译码器即可，但简单搜索之后，我感到很难受，因为这件事情别人早就做过了，甚至已经做得挺好了，而我只是一个新手，也要去做相同的事情，我下意识地想逃避了。</p>\n<p>话说回来，我从心底是喜欢做这个东西的，<strong>我只是讨厌写报告，因为我不擅长写，非要写的话我会写得很烂，这让我感到很难受</strong>，这种感觉太真实了，我又把成长型思维抛到脑后了。现在让我尝试用这种思维进行思考：无论最终我的报告写得怎么样，我做的这个东西有没有得到认可以从而让我能够顺利毕业，我都要努力去完成，这是出于对老师的信任，而且我不该纠结于表面的批评，应该更深一步地考虑，将这看成是我成长的机会。报告写得烂，那就烂吧，我努力了，这次写得烂，那么给我建议吧，下一次我会让它变得更好。毕设做的东西毫无创新，不能通过，那可不行，我已经完成了。</p>\n<p>还有一个问题，如果有不确定的地方，不要再过多考虑了，那只是徒劳，尽早去寻求帮助吧。不要高估了自己，我需要帮助，这是快速进步的秘诀。</p>\n<p>话已至此，希望我真心听进去了，还剩下三天时间，加油写完吧，更重要的事是，记住这种感觉，这比什么都重要。人生没有这么短，路还长。</p>\n","tags":[{"name":"记录","slug":"记录","permalink":"https://jonathan1214.github.io/tags/记录/"},{"name":"sr-log","slug":"sr-log","permalink":"https://jonathan1214.github.io/tags/sr-log/"}]},{"title":"毕设要开题了！","date":"2020-10-02T12:43:53.000Z","path":"2020/10/preparation-for-start-of-graduation-project/","text":"昨天恰逢国庆和中秋一起过，中午和晚上都出去聚餐了，中午和实验室的师姐和师兄们吃，晚上和打篮球的朋友们吃，很舒服。不过今天需要准备开题了，早上来实验室了，又是拖着略显疲惫的身体，我已经有点分不清是因为睡眠不足还是手上在做的东西迟迟没有进展，稍加思索，我更觉得是手上做的东西迟迟没有进展导致的，因为一事无成，所以心中有牵挂，晚上睡不好，早上没精神，然后就是效率低下，更加难以推进手中的事情，这是一个恶性循环。需要找到好的办法突破这个循环，目前看来唯一的办法就是取得进展，但是需要消耗的时间和精力未免也太多了些，我需要别的更好的办法。 现在这些暂时都不重要了，现在重要的事情是 8 号提交一份开题报告给老师。 抛开对未知的恐惧，找到一条路吧。","content":"<p>昨天恰逢国庆和中秋一起过，中午和晚上都出去聚餐了，中午和实验室的师姐和师兄们吃，晚上和打篮球的朋友们吃，很舒服。<br><a id=\"more\"></a><br>不过今天需要准备开题了，早上来实验室了，又是拖着略显疲惫的身体，我已经有点分不清是因为睡眠不足还是手上在做的东西迟迟没有进展，稍加思索，我更觉得是手上做的东西迟迟没有进展导致的，因为一事无成，所以心中有牵挂，晚上睡不好，早上没精神，然后就是效率低下，更加难以推进手中的事情，这是一个恶性循环。需要找到好的办法突破这个循环，目前看来唯一的办法就是取得进展，但是需要消耗的时间和精力未免也太多了些，我需要别的更好的办法。</p>\n<p>现在这些暂时都不重要了，现在重要的事情是 8 号提交一份开题报告给老师。</p>\n<p>抛开对未知的恐惧，找到一条路吧。</p>\n","tags":[{"name":"记录","slug":"记录","permalink":"https://jonathan1214.github.io/tags/记录/"}]},{"title":"完成小阶段任务——终于完成了简单的 LDPC 编译码","date":"2020-09-24T01:31:36.000Z","path":"2020/09/I-DID-IT/","text":"折腾了这么多天，总算是完成了 8 月就拿到的 LDPC 编码译码任务，最近几天一直在 Debug，如果不是做高阶调制，我可能永远不会注意到这个 Bug——随机数生成错误，而这个错误在低信噪比时对仿真结果几乎没有印象，当时做的时候也没有去尝试更高的信噪比，这是我的失误，加上高阶调制之后，事情变得不太一样了，错误就显现出来了，误码率平层在10^-4位置出现了，这本不该发生。经过几天的寻找，从一开始的随意寻找，到昨晚上才想到断点查看判决时的数据，还是经验不足啊，希望经过这次的痛苦经历，自己的Debug能力能有所提高。 列出几条 Debug 原则，长长记性。 Debug 之前，先捋一遍代码的整个流程，思考可能出现错误的地方。 测试驱动开发。多写写测试。 对于从网上找来的代码，如果没有经过充分的测试，谨慎使用。 按时提交代码，千万不要拖延。 更好的断点调试，查看出问题的数据，找到问题的根源。 如果实在在自己写的部分找不到错误，那么错的不是你，是这个世界…… OK，这一阶段的任务已经完成，下一步是尝试在 FPGA 上实现编译码过程，我需要好好思考这个问题： 目标：LDPC 码编译码 FPGA 实现。 这个目标还不够明确：是仅仅做一下基带仿真还是要进行实际的传输，这是两件完全不一样的事情。这个问题需要考虑，但我觉得大概率两件事情都要做，先易后难。至于更多的事情，后面碰到了再说吧。","content":"<p>折腾了这么多天，总算是完成了 8 月就拿到的 LDPC 编码译码任务，最近几天一直在 Debug，如果不是做高阶调制，我可能永远不会注意到这个 Bug——随机数生成错误，而这个错误在低信噪比时对仿真结果几乎没有印象，当时做的时候也没有去尝试更高的信噪比，这是我的失误，加上高阶调制之后，事情变得不太一样了，错误就显现出来了，误码率平层在10^-4位置出现了，这本不该发生。经过几天的寻找，从一开始的随意寻找，到昨晚上才想到断点查看判决时的数据，还是经验不足啊，希望经过这次的痛苦经历，自己的Debug能力能有所提高。</p>\n<p>列出几条 Debug 原则，长长记性。<br><a id=\"more\"></a></p>\n<ul>\n<li>Debug 之前，先捋一遍代码的整个流程，思考可能出现错误的地方。</li>\n<li>测试驱动开发。多写写测试。</li>\n<li>对于从网上找来的代码，如果没有经过充分的测试，谨慎使用。</li>\n<li>按时提交代码，千万不要拖延。</li>\n<li>更好的断点调试，查看出问题的数据，找到问题的根源。</li>\n<li>如果实在在自己写的部分找不到错误，那么错的不是你，是这个世界……</li>\n</ul>\n<p>OK，这一阶段的任务已经完成，下一步是尝试在 FPGA 上实现编译码过程，我需要好好思考这个问题：</p>\n<blockquote>\n<p>目标：LDPC 码编译码 FPGA 实现。</p>\n</blockquote>\n<p>这个目标还不够明确：是仅仅做一下基带仿真还是要进行实际的传输，这是两件完全不一样的事情。这个问题需要考虑，但我觉得大概率两件事情都要做，先易后难。至于更多的事情，后面碰到了再说吧。 </p>\n","tags":[{"name":"记录","slug":"记录","permalink":"https://jonathan1214.github.io/tags/记录/"},{"name":"sr-log","slug":"sr-log","permalink":"https://jonathan1214.github.io/tags/sr-log/"}]},{"title":"搬砖日记 2020.09.16","date":"2020-09-16T12:27:54.000Z","path":"2020/09/sr-log-200916/","text":"实验室的第二天，写下的第一篇日志。今天的任务是实现 LDPC 码的高阶调制问题，经过了一番折腾，最终得到了一个看起来正确的方法，这种方法也在『Channel Codes』这本书的第 15 章简单提到了。实现 LDPC 码的高阶调制解调框图如下所示。 问题在于如何从接收到的符号中获得 LDPC 码译码器需要的信息，15 章中给出了在 SPA 下，由接收到的符号求每个比特的内信息计算方法，如下所示： 其他的计算则和 BPSK 调制的 LDPC 码译码相同，由此我们解决了 LDPC 码的高阶调制问题。当然肯定有很多细节我没有考虑到，暂时先这样吧，后面想到了再补充。","content":"<p>实验室的第二天，写下的第一篇日志。今天的任务是实现 LDPC 码的高阶调制问题，经过了一番折腾，最终得到了一个看起来正确的方法，这种方法也在『Channel Codes』这本书的第 15 章简单提到了。实现 LDPC 码的高阶调制解调框图如下所示。</p>\n<a id=\"more\"></a>\n<img src=\"/2020/09/sr-log-200916/image-20200916203759142.png\" title=\"a block diagram of an LDPC-coded modulation system\">\n<p>问题在于如何从接收到的符号中获得 LDPC 码译码器需要的信息，15 章中给出了在 SPA 下，由接收到的符号求每个比特的内信息计算方法，如下所示：</p>\n<img src=\"/2020/09/sr-log-200916/image-20200916204403197.png\" title=\"LDPC-coded modulation system 内信息计算\">\n<p>其他的计算则和 BPSK 调制的 LDPC 码译码相同，由此我们解决了 LDPC 码的高阶调制问题。当然肯定有很多细节我没有考虑到，暂时先这样吧，后面想到了再补充。</p>\n","tags":[{"name":"记录","slug":"记录","permalink":"https://jonathan1214.github.io/tags/记录/"},{"name":"sr-log","slug":"sr-log","permalink":"https://jonathan1214.github.io/tags/sr-log/"}]},{"title":"闲逛半个月","date":"2020-09-03T02:27:36.000Z","path":"2020/09/hang-out-for-half-a-month/","text":"如题所示 ，我已经闲逛了半个月之久，昏昏沉沉过了半个月，像是突然失去了学习的状态，心情无法平复，难以集中到文章上，于是我逃避到游戏中，我尝试了 CSGO，Dota2，现在又开始玩 LOL 了，但我从心里知道这并不会长久的，很快我就会回归到我的状态，集中注意力学习。这半个月来我到底干了什么呢？首先我感受到了自己的懈怠，但是不想就这样懈怠下去，于是决定先做点简单的事情——在 B 站看 FPGA 教程，或许是教程的每个视频太长，让我感觉很挫败，或许根本就是我无法静下心学习，总之，几天后我决定看买的那本 FPGA 书。看书比起看视频来果然快很多，而且可以随时停下来刷刷手机，四天之后，我把书看完了，但真的只是看完了，自问看过的东西脑子还记得的真的不多，很惭愧。接下来我彻底无事可做了，虽然老师给了篇文章让我去看，但是我完全无法静下心去看文章，尽管那篇文章并不长，简单看下的话应该花不到一个下午就能看完，我一定是哪里不对劲了。到现在我还是没有找到原因，不过我感受到了，这段不对劲的时间马上要过去了，我可以重新回归到之前的状态。 我猜测，我在失去目标时很容易变的不知所措，如果我正在做的事情没有一个清晰的进度指示，也会让我感到沮丧无法坚持下去。","content":"<p>如题所示 ，我已经闲逛了半个月之久，昏昏沉沉过了半个月，像是突然失去了学习的状态，心情无法平复，难以集中到文章上，于是我逃避到游戏中，我尝试了 CSGO，Dota2，现在又开始玩 LOL 了，但我从心里知道这并不会长久的，很快我就会回归到我的状态，集中注意力学习。<br><a id=\"more\"></a><br>这半个月来我到底干了什么呢？首先我感受到了自己的懈怠，但是不想就这样懈怠下去，于是决定先做点简单的事情——在 B 站看 FPGA 教程，或许是教程的每个视频太长，让我感觉很挫败，或许根本就是我无法静下心学习，总之，几天后我决定看买的那本 FPGA 书。看书比起看视频来果然快很多，而且可以随时停下来刷刷手机，四天之后，我把书看完了，但真的只是看完了，自问看过的东西脑子还记得的真的不多，很惭愧。接下来我彻底无事可做了，虽然老师给了篇文章让我去看，但是我完全无法静下心去看文章，尽管那篇文章并不长，简单看下的话应该花不到一个下午就能看完，我一定是哪里不对劲了。到现在我还是没有找到原因，不过我感受到了，这段不对劲的时间马上要过去了，我可以重新回归到之前的状态。</p>\n<p>我猜测，我在失去目标时很容易变的不知所措，如果我正在做的事情没有一个清晰的进度指示，也会让我感到沮丧无法坚持下去。</p>\n","tags":[{"name":"记录","slug":"记录","permalink":"https://jonathan1214.github.io/tags/记录/"}]},{"title":"LDPC 码译码结束，喘上一口气","date":"2020-08-17T14:39:27.000Z","path":"2020/08/a-small-summer-win/","text":"过去的这两周，我的时间基本花在了 LDPC 码的学习上，开始是阅读『hannel Codes』这本书，然后就是用 C 语言实现其中介绍的译码算法和 SPA 和其简化版本 MSA，若是不深入其原理，实现这个算法并不困难，但我忽视了一个重要的问题：我实现的算法最终要达到什么样的效果？这导致我白白浪费了两天时间。 书上给出的 BER 曲线中，使用的算法是 SPA，而我实现的算法是 MSA，其他条件相同的情况下，MSA 性能就是不如 SPA，因为它只是 SPA 的简化版本。我做出来的误码率曲线老是和书上的差一点，让我非常困惑，纠结了半天，后面问了老师，她给了她当时做的时候生成的 H 矩阵和当时实现的代码，让我作一个参考，这对我帮助很大。 昨天一天还是白白度过了，我在极度自闭中混过了一天，期间断点运行了代码试了试，发现了我原来实现算法中的一个小问题，还优化了一下代码，但都对性能毫无改进，就算是使用老师给的 H 矩阵也是一样。我开始怀疑是算法本身的问题，是不是它根本就达不到书上给出的性能，于是今天我回头去看书，在图的上方，作者写明了仿真算法是 SPA，而我做的是 MSA！该死，我居然直接忽视了这么明显了信息。在往前翻翻，作者提到 MSA 会比 SPA 的性能差 0.1dB，我的仿真是符合的！我有点激动，赶紧实现了 SPA，稍加调试，开始运行，等待结果。 果然，就是 MSA 算法的问题，书上给出的图在 SPA 算法下的，而我做的是 MSA，自然有性能差距。 这次仿真就告一段落了，后续我会写几篇文章，总结仿真实现的过程以及在仿真中遇到的问题。现在我觉得最关键的一个问题是：面对仿真结果的不理想，如何进行调试，尤其是时间有限的情况下，如何快速定位错误。这是个共性的问题，需要经验的积累，从这次经历中我能学到的是什么呢？找时间总结下。","content":"<p>过去的这两周，我的时间基本花在了 LDPC 码的学习上，开始是阅读『hannel Codes』这本书，然后就是用 C 语言实现其中介绍的译码算法和 SPA 和其简化版本 MSA，若是不深入其原理，实现这个算法并不困难，但我忽视了一个重要的问题：我实现的算法最终要达到什么样的效果？这导致我白白浪费了两天时间。</p>\n<a id=\"more\"></a>\n<p>书上给出的 BER 曲线中，使用的算法是 SPA，而我实现的算法是 MSA，其他条件相同的情况下，MSA 性能就是不如 SPA，因为它只是 SPA 的简化版本。我做出来的误码率曲线老是和书上的差一点，让我非常困惑，纠结了半天，后面问了老师，她给了她当时做的时候生成的 H 矩阵和当时实现的代码，让我作一个参考，这对我帮助很大。</p>\n<img src=\"/2020/08/a-small-summer-win/image-20200817230403378.png\" title=\"书上给出的仿真结果图\">\n<p>昨天一天还是白白度过了，我在极度自闭中混过了一天，期间断点运行了代码试了试，发现了我原来实现算法中的一个小问题，还优化了一下代码，但都对性能毫无改进，就算是使用老师给的 H 矩阵也是一样。我开始怀疑是算法本身的问题，是不是它根本就达不到书上给出的性能，于是今天我回头去看书，在图的上方，作者写明了仿真算法是 SPA，而我做的是 MSA！该死，我居然直接忽视了这么明显了信息。在往前翻翻，作者提到 MSA 会比 SPA 的性能差 0.1dB，我的仿真是符合的！我有点激动，赶紧实现了 SPA，稍加调试，开始运行，等待结果。</p>\n<p><strong>果然，就是 MSA 算法的问题，书上给出的图在 SPA 算法下的，而我做的是 MSA，自然有性能差距。</strong></p>\n<img src=\"/2020/08/a-small-summer-win/finalresult.png\" title=\"最终的仿真结果\">\n<p>这次仿真就告一段落了，后续我会写几篇文章，总结仿真实现的过程以及在仿真中遇到的问题。现在我觉得最关键的一个问题是：<strong>面对仿真结果的不理想，如何进行调试，尤其是时间有限的情况下，如何快速定位错误。</strong>这是个共性的问题，需要经验的积累，从这次经历中我能学到的是什么呢？找时间总结下。</p>\n","tags":[{"name":"记录","slug":"记录","permalink":"https://jonathan1214.github.io/tags/记录/"}]},{"title":"FPGA 开发流程以及如何创建一个工程","date":"2020-08-07T13:57:18.000Z","path":"2020/08/FPGA-development-process-and-an-project-example/","text":"几天前再次从老师那儿得知毕设我需要做的是 LDPC 码的 FPGA 实现，看起来我必须得找时间学学 FPGA 了。本文就是在今天看完 B 站小梅哥的FPGA视频做的笔记，简单介绍 FPGA 的开发流程，最后会在 Quartus 中创建一个工程。 1. 开发流程一般的 FPGA 项目开发会遵循下面这个流程，从设计输入到最后的在线调试，当然有的人叫法可能不同，我看到的这个教程是这么介绍的，下面逐个来看每一步都需要做什么。 1.1 设计定义1.2 设计输入1.3 分析和综合1.4 功能仿真1.5 布局布线1.6 时序仿真1.7 IO 分配以及文件的生成1.8 配置 FPGA1.9 在线调试2. 如何完成一个简单的项目了解了上面的开发流程后，现在以一个简单的例子说明具体是如何操作的，同时学习下如何在 Quartus 中创建工程。 设计定义 一个二选一多路器，包含两个输入 IO，a 和 b，可以是高或低电平，还有一个输入按键，当按键按下时，LED 与 a 端口状态相同，当按键松开时，LED 与 b 端口状态相同。 这就完成了第一步，我们明确了需要做的东西需要实现的功能是什么样的。接下来是第二步，我们需要在 Verilog 文件中定义模块，将我们的设计实现出来。 2.1 创建工程在创建工程之前，先了解下我们的项目目录安排，如下图所示，template 文件夹下包含了四个文件夹，功能分别是： doc 用来存放相关的文档； prj 用来存放项目相关的文件； rtl 用来存放我们设计模块，保存的是 Verilog 文件； testbench 存放的是 testbench 的 Verilog 文件，在涉及到时在详细述。 了解项目目录安排后，我们就可以创建工程了，每次需要创建工程时，可以把这个 template 拷贝一份然后改为我们需要的名字即可。打开 Quartus 软件，开始界面如下所示，我使用的是 13.0 版本。 点击红框处的 Create a New Project 就可以开始创建一个新工程了，点击下一步会出现如下界面，在这个界面有两件事需要做：选择项目目录，填写项目名称。 像我们刚才所说的一样，复制 template 目录，重命名为 test，然后选择项目目录为 test 下的 prj 目录，填写项目名称为也为 test，然后点击下一步，这个界面我们可以添加已经有的文件，但我们还没有，直接点击下一步，在这里我们需要选择 FPGA 的型号，这里根据手中的板子上的 FPGA 型号选择即可，关于 FPGA 的命名规则，可以上网搜下。 选择完之后点击下一步，在这里我们需要选择 EDA 工具，这里选择 Simulation 工具即可，我这里安装了 ModelSim，所以选择 ModelSim，一般还是建议使用 ModelSim-Altera，说是用 ModelSim 会有一些路径问题，需要配置，对初学者不是很友好，我暂时还没有碰到，因此先这么用着。然后选择 Format 为 Verilog HDL。 之后一路点击next即可。我们的项目创建完毕了。 2.2 编写模块接下来编写模块以实现设计定义，先创建 Verilog 脚本：Ctrl + N 新建文件，选择 Verilog HDL。新建文件后，将文件保存到 rtl 目录下，命名为 test.v，之后就可以编写 module 了。在打开的 test.v 文件中输入如下内容： 1234567891011121314module test(a, b, key_in, led_out); input a; // 输入端口 a input b; // 输入端口 b input key_in; // 按键输入 选择信号 output led_out; // led 控制端口 // 当 key_in == 0, led_out = a assign led_out = (key_in == 0) ? a : b; endmodule 2.3 分析与综合这个模块就可以实现我们设计定义中的内容，编写完之后，点击菜单栏中的 Processing 下的 Start 下的 Start Analysis &amp; Synthesis，或者点击工具栏上的 Start Analysis &amp; Synthesis，对文件进行分析和综合，检查文件中是否有错，如果有的话，需要去解决才能进行下一步。 2.4 前仿真前仿真前，先要配置我们的 testbench。完成之后可以点击 RTL Simulation 进行前仿真。 2.5 布局布线点击 Start Compilation： 2.6 后仿真点击 Gate Level Simulation：","content":"<p>几天前再次从老师那儿得知毕设我需要做的是 LDPC 码的 FPGA 实现，看起来我必须得找时间学学 FPGA 了。本文就是在今天看完 B 站<a href=\"https://space.bilibili.com/476579378\" target=\"_blank\" rel=\"noopener\">小梅哥</a>的<a href=\"https://www.bilibili.com/video/BV1KE411h7AZ\" target=\"_blank\" rel=\"noopener\">FPGA视频</a>做的笔记，简单介绍 FPGA 的开发流程，最后会在 Quartus 中创建一个工程。</p>\n<a id=\"more\"></a>\n<h2 id=\"1-开发流程\"><a href=\"#1-开发流程\" class=\"headerlink\" title=\"1. 开发流程\"></a>1. 开发流程</h2><p>一般的 FPGA 项目开发会遵循下面这个流程，从设计输入到最后的在线调试，当然有的人叫法可能不同，我看到的这个教程是这么介绍的，下面逐个来看每一步都需要做什么。</p>\n<h3 id=\"1-1-设计定义\"><a href=\"#1-1-设计定义\" class=\"headerlink\" title=\"1.1 设计定义\"></a>1.1 设计定义</h3><h3 id=\"1-2-设计输入\"><a href=\"#1-2-设计输入\" class=\"headerlink\" title=\"1.2 设计输入\"></a>1.2 设计输入</h3><h3 id=\"1-3-分析和综合\"><a href=\"#1-3-分析和综合\" class=\"headerlink\" title=\"1.3 分析和综合\"></a>1.3 分析和综合</h3><h3 id=\"1-4-功能仿真\"><a href=\"#1-4-功能仿真\" class=\"headerlink\" title=\"1.4 功能仿真\"></a>1.4 功能仿真</h3><h3 id=\"1-5-布局布线\"><a href=\"#1-5-布局布线\" class=\"headerlink\" title=\"1.5 布局布线\"></a>1.5 布局布线</h3><h3 id=\"1-6-时序仿真\"><a href=\"#1-6-时序仿真\" class=\"headerlink\" title=\"1.6 时序仿真\"></a>1.6 时序仿真</h3><h3 id=\"1-7-IO-分配以及文件的生成\"><a href=\"#1-7-IO-分配以及文件的生成\" class=\"headerlink\" title=\"1.7 IO 分配以及文件的生成\"></a>1.7 IO 分配以及文件的生成</h3><h3 id=\"1-8-配置-FPGA\"><a href=\"#1-8-配置-FPGA\" class=\"headerlink\" title=\"1.8 配置 FPGA\"></a>1.8 配置 FPGA</h3><h3 id=\"1-9-在线调试\"><a href=\"#1-9-在线调试\" class=\"headerlink\" title=\"1.9 在线调试\"></a>1.9 在线调试</h3><h2 id=\"2-如何完成一个简单的项目\"><a href=\"#2-如何完成一个简单的项目\" class=\"headerlink\" title=\"2. 如何完成一个简单的项目\"></a>2. 如何完成一个简单的项目</h2><p>了解了上面的开发流程后，现在以一个简单的例子说明具体是如何操作的，同时学习下如何在 Quartus 中创建工程。</p>\n<ul>\n<li><p><strong>设计定义</strong></p>\n<p>一个二选一多路器，包含两个输入 IO，a 和 b，可以是高或低电平，还有一个输入按键，当按键按下时，LED 与 a 端口状态相同，当按键松开时，LED 与 b 端口状态相同。</p>\n</li>\n</ul>\n<p>这就完成了第一步，我们明确了需要做的东西需要实现的功能是什么样的。接下来是第二步，我们需要在 Verilog 文件中定义模块，将我们的设计实现出来。</p>\n<h3 id=\"2-1-创建工程\"><a href=\"#2-1-创建工程\" class=\"headerlink\" title=\"2.1 创建工程\"></a>2.1 创建工程</h3><p>在创建工程之前，先了解下我们的项目目录安排，如下图所示，template 文件夹下包含了四个文件夹，功能分别是：</p>\n<ul>\n<li>doc 用来存放相关的文档；</li>\n<li>prj 用来存放项目相关的文件；</li>\n<li>rtl 用来存放我们设计模块，保存的是 Verilog 文件；</li>\n<li>testbench 存放的是 testbench 的 Verilog 文件，在涉及到时在详细述。</li>\n</ul>\n<p><img src=\"2020-08-07-FPGA-development-process-and-an-project-example/image-20200807223822609.png\" alt=\"image-20200807223822609\"></p>\n<p>了解项目目录安排后，我们就可以创建工程了，每次需要创建工程时，可以把这个 template 拷贝一份然后改为我们需要的名字即可。打开 Quartus 软件，开始界面如下所示，我使用的是 13.0 版本。</p>\n<p><img src=\"2020-08-07-FPGA-development-process-and-an-project-example/image-20200807224428973.png\" alt=\"image-20200807224428973\"></p>\n<p>点击红框处的 Create a New Project 就可以开始创建一个新工程了，点击下一步会出现如下界面，在这个界面有两件事需要做：选择项目目录，填写项目名称。</p>\n<p><img src=\"2020-08-07-FPGA-development-process-and-an-project-example/image-20200807225227001.png\" alt=\"image-20200807225227001\"></p>\n<p>像我们刚才所说的一样，复制 template 目录，重命名为 test，然后选择项目目录为 test 下的 prj 目录，填写项目名称为也为 test，然后点击下一步，这个界面我们可以添加已经有的文件，但我们还没有，直接点击下一步，在这里我们需要选择 FPGA 的型号，这里根据手中的板子上的 FPGA 型号选择即可，关于 FPGA 的命名规则，可以上网搜下。</p>\n<p><img src=\"2020-08-07-FPGA-development-process-and-an-project-example/image-20200807225754347.png\" alt=\"image-20200807225754347\"></p>\n<p>选择完之后点击下一步，在这里我们需要选择 EDA 工具，这里选择 Simulation 工具即可，我这里安装了 ModelSim，所以选择 ModelSim，一般还是建议使用 ModelSim-Altera，说是用 ModelSim 会有一些路径问题，需要配置，对初学者不是很友好，我暂时还没有碰到，因此先这么用着。然后选择 Format 为 Verilog HDL。</p>\n<p><img src=\"2020-08-07-FPGA-development-process-and-an-project-example/image-20200807230147706.png\" alt=\"image-20200807230147706\"></p>\n<p>之后一路点击next即可。我们的项目创建完毕了。</p>\n<h3 id=\"2-2-编写模块\"><a href=\"#2-2-编写模块\" class=\"headerlink\" title=\"2.2 编写模块\"></a>2.2 编写模块</h3><p>接下来编写模块以实现设计定义，先创建 Verilog 脚本：Ctrl + N 新建文件，选择 Verilog HDL。新建文件后，将文件保存到 rtl 目录下，命名为 test.v，之后就可以编写 module 了。在打开的 test.v 文件中输入如下内容：</p>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">module</span> test(a, b, key_in, led_out);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">input</span> a; <span class=\"comment\">// 输入端口 a</span></span><br><span class=\"line\">    <span class=\"keyword\">input</span> b; <span class=\"comment\">// 输入端口 b</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">input</span> key_in; <span class=\"comment\">// 按键输入 选择信号</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">output</span> led_out; <span class=\"comment\">// led 控制端口</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 当 key_in == 0, led_out = a</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">assign</span> led_out = (key_in == <span class=\"number\">0</span>) ? a : b;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">endmodule</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-3-分析与综合\"><a href=\"#2-3-分析与综合\" class=\"headerlink\" title=\"2.3 分析与综合\"></a>2.3 分析与综合</h3><p>这个模块就可以实现我们设计定义中的内容，编写完之后，点击菜单栏中的 Processing 下的 Start 下的 Start Analysis &amp; Synthesis，或者点击工具栏上的 Start Analysis &amp; Synthesis，对文件进行分析和综合，检查文件中是否有错，如果有的话，需要去解决才能进行下一步。</p>\n<p><img src=\"2020-08-07-FPGA-development-process-and-an-project-example/image-20200808202917341.png\" alt=\"image-20200808202917341\"></p>\n<h3 id=\"2-4-前仿真\"><a href=\"#2-4-前仿真\" class=\"headerlink\" title=\"2.4 前仿真\"></a>2.4 前仿真</h3><p>前仿真前，先要配置我们的 testbench。完成之后可以点击 RTL Simulation 进行前仿真。</p>\n<p><img src=\"2020-08-07-FPGA-development-process-and-an-project-example/image-20200809133617627.png\" alt=\"image-20200809133617627\"></p>\n<h3 id=\"2-5-布局布线\"><a href=\"#2-5-布局布线\" class=\"headerlink\" title=\"2.5 布局布线\"></a>2.5 布局布线</h3><p>点击 Start Compilation：</p>\n<p><img src=\"2020-08-07-FPGA-development-process-and-an-project-example/image-20200809133806051.png\" alt=\"image-20200809133806051\"></p>\n<h3 id=\"2-6-后仿真\"><a href=\"#2-6-后仿真\" class=\"headerlink\" title=\"2.6 后仿真\"></a>2.6 后仿真</h3><p>点击 Gate Level Simulation：</p>\n<p><img src=\"2020-08-07-FPGA-development-process-and-an-project-example/image-20200809134109186.png\" alt=\"image-20200809134109186\"></p>\n","tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://jonathan1214.github.io/tags/FPGA/"}]},{"title":"近日杂记","date":"2020-08-06T02:33:39.000Z","path":"2020/08/some-recent-chores/","text":"又过去几天了，每天保持低效率地看书，也总算是看完了『Channel Codes』的前两章，看书时间分布也就是上午两小时下午两小时，晚上一小时了，期间得穿插着打游戏和上网冲浪，这就是放假的状态吗？有点舒服，但是又觉得不该如此，人生怎么能如此颓废。思考罢了，回头又是继续这种生活，好不快乐。","content":"<p>又过去几天了，每天保持低效率地看书，也总算是看完了『Channel   Codes』的前两章，看书时间分布也就是上午两小时下午两小时，晚上一小时了，期间得穿插着打游戏和上网冲浪，这就是放假的状态吗？有点舒服，但是又觉得不该如此，人生怎么能如此颓废。思考罢了，回头又是继续这种生活，好不快乐。</p>\n<a id=\"more\"></a>\n","tags":[{"name":"记录","slug":"记录","permalink":"https://jonathan1214.github.io/tags/记录/"}]},{"title":"结束了，我的大学前三年","date":"2020-07-31T14:41:41.000Z","path":"2020/07/the-end-of-my-first-three-years-of-university/","text":"今天，终于写完了生产实习要求提交的设计报告，给自己这一周来的辛苦来一个结局。辛苦聪聪了，一直在小组内沟通，感谢，还有大家，虽然摸鱼但好歹在线，感谢。至此，我的大学前三年结束了，没有什么高光时刻，平平淡淡地度过了，今天是一个里程碑。","content":"<p>今天，终于写完了生产实习要求提交的设计报告，给自己这一周来的辛苦来一个结局。辛苦聪聪了，一直在小组内沟通，感谢，还有大家，虽然摸鱼但好歹在线，感谢。至此，我的大学前三年结束了，没有什么高光时刻，平平淡淡地度过了，今天是一个里程碑。</p>\n","tags":[{"name":"记录","slug":"记录","permalink":"https://jonathan1214.github.io/tags/记录/"},{"name":"里程碑","slug":"里程碑","permalink":"https://jonathan1214.github.io/tags/里程碑/"}]},{"title":"写在移动通信期末考试后","date":"2020-07-04T12:18:36.000Z","path":"2020/07/written-after-mobile-communications-final-exam/","text":"刚结束了今年的第一门专业课考试，不用感觉就知道考得稀烂，卷面约有 30 分没做完，折合下最终的成绩直接没了 18 分，这下可以考虑打破最低的考试课得分记录了——电路 76 分，我觉得很有希望。 艰苦的 2020 过去一半了，我还呆在家，来不及感慨自己这半年来又是什么都没做，就得不认真地准备专业课考试，我从心里抵触考试，自然就不好好准备，以为也不过如此，拿到足够多的分数即可，但被现实告知，不会这么容易的，拿到想要的东西也得认真对待才行。 刚结束了今年的第一门专业课考试，不用感觉就知道考得稀烂，卷面约有 30 分没做完，折合下最终的成绩直接没了 18 分，这下可以考虑打破最低的考试课得分记录了——电路 76 分，我觉得很有希望。 问题出在了哪里？ 痛苦地承认自己真的不行？未免太过窝囊。好在这才刚刚开始，还有补救的机会，移动通信失去的东西，要在后面的天线原理和卫星通信上找回来，就像以前做的那样。 希望一切好起来吧。","content":"<p>刚结束了今年的第一门专业课考试，不用感觉就知道考得稀烂，卷面约有 30 分没做完，折合下最终的成绩直接没了 18 分，这下可以考虑打破最低的考试课得分记录了——电路 76 分，我觉得很有希望。<br><a id=\"more\"></a></p>\n<p>艰苦的 2020 过去一半了，我还呆在家，来不及感慨自己这半年来又是什么都没做，就得不认真地准备专业课考试，我从心里抵触考试，自然就不好好准备，以为也不过如此，拿到足够多的分数即可，但被现实告知，不会这么容易的，拿到想要的东西也得认真对待才行。</p>\n<p>刚结束了今年的第一门专业课考试，不用感觉就知道考得稀烂，卷面约有 30 分没做完，折合下最终的成绩直接没了 18 分，这下可以考虑打破最低的考试课得分记录了——电路 76 分，我觉得很有希望。</p>\n<p>问题出在了哪里？</p>\n<p>痛苦地承认自己真的不行？未免太过窝囊。好在这才刚刚开始，还有补救的机会，移动通信失去的东西，要在后面的天线原理和卫星通信上找回来，就像以前做的那样。</p>\n<p>希望一切好起来吧。</p>\n","tags":[{"name":"记录","slug":"记录","permalink":"https://jonathan1214.github.io/tags/记录/"}]},{"title":"『Channel Codes』笔记之有限域、向量空间、有限集合和图","date":"2020-06-22T14:46:35.000Z","path":"2020/06/finiteFields-VectorSpaces-FiniteGeometries-Graphs/","text":"我准备写一系列文章来记录阅读《Channel Codes》时留下来的笔记，这是第一篇，对应书中的第二章，介绍了有限域、向量空间、有限集合和图。无论是传统的信道编码还是现代的信道编码，都离不开这些代数和集合数学的概念，这些概念是信道编码的基础。 2.1 集合和二元运算集合(set)就是一些特定对象的合集(collection)，这些对象被称作集合中的元素(element)。如：$X = {x_1, x_2, x_3, x_4, x_5, x_6}$，则 $X$ 是一个集合，它有 6 个元素。关于集合，我们需要知道下面这些： 有限集(finite set)：集合中只有有限个元素； 无限集(infinite set)：集合中的元素是无限个的； 基数(cardinality)：集合 $X$ 中元素的个数就是元素的基数，记作 $| X|$。 子集(subset) 真子集(proper subset) 定义在集合 $S$ 上的二元运算定义了一种规则，它对集合中的一对元素以确定的顺序进行运算，且结果仍然属于该集合。 associative（结合的）：运算满足结合律。 commutative（交换的）：运算满足交换律。 2.2 群代数系统：集合定义在集合上的一些运算。 2.2.1 群的基本概念定义：集合和定义在集合上的一个二元元算称为群，且满足如下条件： 运算满足结合律（associative） 集合有一个单位元（identity element） 对于任何一个元素，在集合中存在一个它的逆，且这个逆是唯一的。 如果一个群是可交换的，那么称其为阿贝尔群。 2.2.2 有限群2.2.3 子群和陪集 陪集的一些性质： No two elements of a coset of H are identical. No two elements from two different cosets of H are identical. Every element of G appears in one and only one coset of H. All distinct cosets of H are disjoint. The union of all the distinct cosets of H forms the group G. 拉格朗日定理： 2.3 域有限域在编码理论中非常重要。 2.3.1 定义和基本概念 从定义在可以看到，域可以分为两个群，每个群各有一个单位元素，因此域的元素个数至少为2，且可以证明：存在只含有两个元素的域。 A field is simply an algebraic system in which we can perform addition, sub- traction, multiplication, and division without leaving the field. 从下面这个定义也可以引入到有限域： 一条证明，解释了师姐讲文章时的疑问： 2.3.2 Finite Fields有限域又叫伽罗华域，在差错控制编码中非常重要。记作 GF(p)，p 为素数。 2.4 Vector Space2.4.1 Basic Definitions and Properties 2.5 Polynomials over Finite Fields2.6 Construction and Properties of Galois Fields构造方法：通过 GF(p) 的 m 阶 primitive polynomials 得到 root a，那么，{0, 1, a, a^2, …, a^(p^m-2)} 构成了 GF(p^m)。 2.6.2 Some Fundamental Properties of Finite Fields 2.7 Finite Geometries","content":"<p>我准备写一系列文章来记录阅读《Channel Codes》时留下来的笔记，这是第一篇，对应书中的第二章，介绍了有限域、向量空间、有限集合和图。无论是传统的信道编码还是现代的信道编码，都离不开这些代数和集合数学的概念，这些概念是信道编码的基础。<br><a id=\"more\"></a></p>\n<h2 id=\"2-1-集合和二元运算\"><a href=\"#2-1-集合和二元运算\" class=\"headerlink\" title=\"2.1 集合和二元运算\"></a>2.1 集合和二元运算</h2><p>集合(set)就是一些特定对象的合集(collection)，这些对象被称作集合中的元素(element)。如：$X = {x_1, x_2, x_3, x_4, x_5, x_6}$，则 $X$ 是一个集合，它有 6 个元素。关于集合，我们需要知道下面这些：</p>\n<ul>\n<li>有限集(finite set)：集合中只有有限个元素；</li>\n<li>无限集(infinite set)：集合中的元素是无限个的；</li>\n<li>基数(cardinality)：集合 $X$ 中元素的个数就是元素的基数，记作 $| X|$。</li>\n<li>子集(subset)</li>\n<li>真子集(proper subset)</li>\n</ul>\n<p>定义在集合 $S$ 上的二元运算定义了一种规则，它对集合中的一对元素以<strong>确定的顺序</strong>进行运算，且结果仍然属于该集合。</p>\n<p>associative（结合的）：运算满足结合律。</p>\n<p>commutative（交换的）：运算满足交换律。</p>\n<h2 id=\"2-2-群\"><a href=\"#2-2-群\" class=\"headerlink\" title=\"2.2 群\"></a>2.2 群</h2><p>代数系统：集合定义在集合上的一些运算。</p>\n<h3 id=\"2-2-1-群的基本概念\"><a href=\"#2-2-1-群的基本概念\" class=\"headerlink\" title=\"2.2.1 群的基本概念\"></a>2.2.1 群的基本概念</h3><p>定义：集合和定义在集合上的一个二元元算称为群，且满足如下条件：</p>\n<ol>\n<li>运算满足结合律（associative）</li>\n<li>集合有一个单位元（identity element）</li>\n<li>对于任何一个元素，在集合中存在一个它的逆，且这个逆是唯一的。</li>\n</ol>\n<p>如果一个群是可交换的，那么称其为阿贝尔群。</p>\n<h3 id=\"2-2-2-有限群\"><a href=\"#2-2-2-有限群\" class=\"headerlink\" title=\"2.2.2 有限群\"></a>2.2.2 有限群</h3><h3 id=\"2-2-3-子群和陪集\"><a href=\"#2-2-3-子群和陪集\" class=\"headerlink\" title=\"2.2.3 子群和陪集\"></a>2.2.3 子群和陪集</h3><p><img src=\"2020-06-22-finiteFields-VectorSpaces-FiniteGeometries-Graphs/image-20200803190531807.png\" alt=\"image-20200803190531807\"></p>\n<p><img src=\"2020-06-22-finiteFields-VectorSpaces-FiniteGeometries-Graphs/image-20200803190547257.png\" alt=\"image-20200803190547257\"></p>\n<p>陪集的一些性质：</p>\n<ol>\n<li>No two elements of a coset of H are identical. </li>\n<li>No two elements from two different cosets of H are identical. </li>\n<li>Every element of G appears in one and only one coset of H.</li>\n<li>All distinct cosets of H are disjoint.</li>\n<li>The union of all the distinct cosets of H forms the group G.</li>\n</ol>\n<p>拉格朗日定理：</p>\n<p><img src=\"2020-06-22-finiteFields-VectorSpaces-FiniteGeometries-Graphs/image-20200803191142440.png\" alt=\"image-20200803191142440\"></p>\n<h2 id=\"2-3-域\"><a href=\"#2-3-域\" class=\"headerlink\" title=\"2.3 域\"></a>2.3 域</h2><p>有限域在编码理论中非常重要。</p>\n<h3 id=\"2-3-1-定义和基本概念\"><a href=\"#2-3-1-定义和基本概念\" class=\"headerlink\" title=\"2.3.1 定义和基本概念\"></a>2.3.1 定义和基本概念</h3><p><img src=\"2020-06-22-finiteFields-VectorSpaces-FiniteGeometries-Graphs/image-20200803193203931.png\" alt=\"image-20200803193203931\"></p>\n<p>从定义在可以看到，域可以分为两个群，每个群各有一个单位元素，因此域的元素个数至少为2，且可以证明：存在只含有两个元素的域。</p>\n<p>A field is simply an algebraic system in which we can perform addition, sub- traction, multiplication, and division without leaving the field.</p>\n<p><img src=\"2020-06-22-finiteFields-VectorSpaces-FiniteGeometries-Graphs/image-20200803193728641.png\" alt=\"image-20200803193728641\"></p>\n<p>从下面这个定义也可以引入到有限域：</p>\n<p><img src=\"2020-06-22-finiteFields-VectorSpaces-FiniteGeometries-Graphs/image-20200803194026394.png\" alt=\"image-20200803194026394\"></p>\n<p>一条证明，解释了师姐讲文章时的疑问：</p>\n<p><img src=\"2020-06-22-finiteFields-VectorSpaces-FiniteGeometries-Graphs/image-20200803194826387.png\" alt=\"image-20200803194826387\"></p>\n<h3 id=\"2-3-2-Finite-Fields\"><a href=\"#2-3-2-Finite-Fields\" class=\"headerlink\" title=\"2.3.2 Finite Fields\"></a>2.3.2 Finite Fields</h3><p>有限域又叫伽罗华域，在差错控制编码中非常重要。记作 GF(p)，p 为素数。</p>\n<p><img src=\"2020-06-22-finiteFields-VectorSpaces-FiniteGeometries-Graphs/image-20200804083806871.png\" alt=\"image-20200804083806871\"></p>\n<p><img src=\"2020-06-22-finiteFields-VectorSpaces-FiniteGeometries-Graphs/image-20200804083859309.png\" alt=\"image-20200804083859309\"></p>\n<p><img src=\"2020-06-22-finiteFields-VectorSpaces-FiniteGeometries-Graphs/image-20200804083922415.png\" alt=\"image-20200804083922415\"></p>\n<h2 id=\"2-4-Vector-Space\"><a href=\"#2-4-Vector-Space\" class=\"headerlink\" title=\"2.4 Vector Space\"></a>2.4 Vector Space</h2><h3 id=\"2-4-1-Basic-Definitions-and-Properties\"><a href=\"#2-4-1-Basic-Definitions-and-Properties\" class=\"headerlink\" title=\"2.4.1 Basic Definitions and Properties\"></a>2.4.1 Basic Definitions and Properties</h3><p><img src=\"2020-06-22-finiteFields-VectorSpaces-FiniteGeometries-Graphs/image-20200804090317809.png\" alt=\"image-20200804090317809\"></p>\n<h2 id=\"2-5-Polynomials-over-Finite-Fields\"><a href=\"#2-5-Polynomials-over-Finite-Fields\" class=\"headerlink\" title=\"2.5 Polynomials over Finite Fields\"></a>2.5 Polynomials over Finite Fields</h2><h2 id=\"2-6-Construction-and-Properties-of-Galois-Fields\"><a href=\"#2-6-Construction-and-Properties-of-Galois-Fields\" class=\"headerlink\" title=\"2.6 Construction and Properties of Galois Fields\"></a>2.6 Construction and Properties of Galois Fields</h2><p>构造方法：通过 GF(p) 的 m 阶 primitive polynomials 得到 root a，那么，{0, 1, a, a^2, …, a^(p^m-2)} 构成了 GF(p^m)。</p>\n<h3 id=\"2-6-2-Some-Fundamental-Properties-of-Finite-Fields\"><a href=\"#2-6-2-Some-Fundamental-Properties-of-Finite-Fields\" class=\"headerlink\" title=\"2.6.2 Some Fundamental Properties of Finite Fields\"></a>2.6.2 Some Fundamental Properties of Finite Fields</h3><p><img src=\"2020-06-22-finiteFields-VectorSpaces-FiniteGeometries-Graphs/image-20200805085904765.png\" alt=\"image-20200805085904765\"></p>\n<p><img src=\"2020-06-22-finiteFields-VectorSpaces-FiniteGeometries-Graphs/image-20200805085939344.png\" alt=\"image-20200805085939344\"></p>\n<p><img src=\"2020-06-22-finiteFields-VectorSpaces-FiniteGeometries-Graphs/image-20200805090049807.png\" alt=\"image-20200805090049807\"></p>\n<p><img src=\"2020-06-22-finiteFields-VectorSpaces-FiniteGeometries-Graphs/image-20200805090202552.png\" alt=\"image-20200805090202552\"></p>\n<p><img src=\"2020-06-22-finiteFields-VectorSpaces-FiniteGeometries-Graphs/image-20200805090223152.png\" alt=\"image-20200805090223152\"></p>\n<p><img src=\"2020-06-22-finiteFields-VectorSpaces-FiniteGeometries-Graphs/image-20200805090332982.png\" alt=\"image-20200805090332982\"></p>\n<p><img src=\"2020-06-22-finiteFields-VectorSpaces-FiniteGeometries-Graphs/image-20200805090359630.png\" alt=\"image-20200805090359630\"></p>\n<p><img src=\"2020-06-22-finiteFields-VectorSpaces-FiniteGeometries-Graphs/image-20200805090428880.png\" alt=\"image-20200805090428880\"></p>\n<p><img src=\"2020-06-22-finiteFields-VectorSpaces-FiniteGeometries-Graphs/image-20200805090506367.png\" alt=\"image-20200805090506367\"></p>\n<p><img src=\"2020-06-22-finiteFields-VectorSpaces-FiniteGeometries-Graphs/image-20200805090522736.png\" alt=\"image-20200805090522736\"></p>\n<p><img src=\"2020-06-22-finiteFields-VectorSpaces-FiniteGeometries-Graphs/image-20200805090540369.png\" alt=\"image-20200805090540369\"></p>\n<p><img src=\"2020-06-22-finiteFields-VectorSpaces-FiniteGeometries-Graphs/image-20200805090616153.png\" alt=\"image-20200805090616153\"></p>\n<h2 id=\"2-7-Finite-Geometries\"><a href=\"#2-7-Finite-Geometries\" class=\"headerlink\" title=\"2.7 Finite Geometries\"></a>2.7 Finite Geometries</h2>","tags":[{"name":"Channel Codes","slug":"Channel-Codes","permalink":"https://jonathan1214.github.io/tags/Channel-Codes/"},{"name":"文献笔记","slug":"文献笔记","permalink":"https://jonathan1214.github.io/tags/文献笔记/"},{"name":"抽象代数","slug":"抽象代数","permalink":"https://jonathan1214.github.io/tags/抽象代数/"}]},{"title":"计算机网络课程报告","date":"2020-06-07T14:25:10.000Z","path":"2020/06/curriculum-report-of-computer-network/","text":"现在初步打算写无线局域网中MAC的接入技术，在知网简单搜索下，发现研究这个的还真不少，如无线局域网中高效MAC层接入机制研究，低时延高可靠无线局域网MAC增强技术研究和工业无线局域网MAC协议确定性机制研究。看起来写完这篇课程报告不是特别烦，基本上我觉得可以照着一篇硕士论文快速完成这篇课程报告，毕竟时间紧急，拿到该拿的分即可。写完后，我会在这里同步完报告的全部内容。 1. 无线局域网的发展历史随着互联网业务的迅速发展，人们对各种在线服务的实时性需求日益强烈。相比蜂窝网，无线局域网网络有着高带宽，灵活以及廉价等诸多优势，目前，无线局域网（Wireless Local Area Network, WLAN）己经在家庭、校园、企业和城市公共场所等多种场景部署。 可以看到无线局域网已经广泛应用于我们的日常生活，这是由于其传输速率高、带宽配置灵活、使用非授权频段以及方便灵活部署等优势。无线局域网的代表协议是IEEE 802.11系列标准，第一个IEEE 802.11 标准于1997年发表，至今已有 23 年历史了[1]。二十年来，802.11取得了很大的发展，很多新技术进入了标准，推动 802.11 协议日趋完善。 1997年，IEEE推出了第一个无线局域网标准——IEEE 802.11，其中定义了介质访问控制（MAC）层和物理层。物理层定义了工作在2.4GHz的ISM频段上的两种扩频作调制方式和一种红外线传输的方式，总数据传输速率设计为2Mbit/s，MAC层采用的CSMA/CA技术。 EEE 802.11a协议[2]在1999年被标准化，它采用的是正交频分复用技术（Orthogonal Frequency Division Multiplexing, OFDM），工作频率为5GHz，使用52个正交频分多路复用子载波，最大原始数据传输率为54Mb/s，达到了现实网络中等吞吐量（20Mb/s）的要求。 同年IEEE 802.11b被正式批准，该标准规定无线局域网工作频段在2.4GHz，由于工作频段更低，与IEEE 802.11a相比，它的工作范围更大，但速率更低，数据传输速率达到11Mbps。该标准是对IEEE 802.11的一个补充，采用点对点模式和基本模式两种运作模式，其数据传输速率可以根据实际情况在11Mbps、5.5Mbps、2Mbps、1Mbps的不同速率间自动切换，802.11b和工作在5GHz频率上的802.11a标准不兼容。由于价格低廉，802.11b产品已经被广泛地投入市场，并在许多实际工作场所运行。 2003年7月IEEE 802.11工作组批准了IEEE 802.11g草案，在2.4GHz频段使用正交频分复用技术，使数据传输速率提高到20Mbit/s以上；可与IEEE 802.11b的Wi-Fi系统互联互通，可共存于同一AP的网络里，从而保障了后向兼容性。 IEEE 802.11 n在2009年标准化，采用了OFDM和4x4多入多出（Multiple-Input Multiple-Output, MIMO）技术[3]，物理层速率可以在两路20MHz信道(共40MHz )中达到600Mbps。 2013推出的IEEE 802.11ac协议利用OFDM和8x8 MIMO技术[4]，在8个20MHz信道(共160MHz)中，物理层速率可达到6.9Gbps，在802.11n基础上有了很大的提升。最新的 802.11ax 标准已经支持160MHz的带宽，8条流空间复用，基于 OFDMA的多址接入技术提高了信道利用率，满足密集部署场景的应用需求[5]。其他更多标准的简略信息如图1-1所示。 我们可以看到，无线局域网标准定义了协议的工作频段、调制编码方式及最高速度的支持。可以看到，无线局域网的工作频段是2.4GHz和5GHz，前者的具体范围是2.4000～2.4835GHz，后者是5.15～5.825GHz，通常设计工作在2.4GHz频段的协议支持的数据传输速率低一些，但覆盖范围大，工作在5GHz频段的协议支持的数据传输塑料布高一些，但覆盖范围小。从调制技术来看，无线局域网的物理层从CCK向OFDM和MIMO-OFDM发展，支持的传输速率越来越大，2Mbps，54Mbps，600Mbps，1Gbps，9.6Gbps，传输速率是越来越大，当然其中消耗了更多的带宽资源。 2. 无线局域网的MAC层2.1 无线局域网的两种网络结构IEEE 802.11定义了无线局域网的两种网络结构，分别是无中心网络（Ad hoc模式）和有中心网络。在Ad hoc模式下，网络中没有中心站点，各站点式平等的，这是一种对等式网络（Peer-to-Peer，P2P），有中心网络的网络结构中有一个中心站点，又称接入点（Access Point，AP），也叫做AP模式。两种结构的示意图如图2-1所示。 目前，AP模式是比较常用的，我们在家中使用的WiFi就是这种模式，而Ad hoc一般在一些专用场合使用，平时比较少见。 2.2 无线局域网的MAC层结构在无线局域网中，无线信道由多个站点共享，它们同处于一个冲突域下，在这种情况下，最需要解决的一个问题就是如何避免站点数据的碰撞，否则站点的数据会发生相互干扰，导致接受站点无法正确接收到信息。这个时候我们就需要一个控制各站点接入无线信道的协议来统一管理，这就是我们的MAC层协议。 MAC层即介质访问控制层，在传输帧时，一个基站首先要获取共享信道的访问，无线局域网的标准定义了两种介质访问控制方式：分布式协调功能（DCF）和集中式协调功能（PCF）。其中DCF功能是必须支持的，而PCF则不一定。MAC的结构如图2-2所示。 DCF机制是IEEE 802.11协议采用的基于竞争的MAC机制，其采用载波监听多址接入/冲突避免（Carrier Sense Multiple Access mechanism with Collision Avoidance，CSMA/CA）和二进制指数退避（Binary Exponential Back-off，BEB）两种基本机制可以为多个站点提供信道接入，各个站点在这种机制下对信道资源进行争用，有可能会发生数据碰撞。 PCF是MAC的可选用功能，在PCF下，各站点不需要争用信道，信道资源由AP统一分配，这种工作模式下，不会发生数据碰撞。但是一般情况下这种方式使用较少，只有在对传输时间要求高的视频、音频会话类应用时，才会启用PCF方式。 2.3 无线局域网的MAC层接入机制当前，IEEE 802.11MAC协议中广泛采用的接入方法是CSMA/CA。CA的意思是冲突避免，无线局域网发送结点监测到无线信道“空闲”时不“立即”发送帧，而是所有准备发送数据帧的主机都执行退避算法，通过“冲突避免”（CA）来减小冲突发生概率，而且无线局域网发送结点需要等待接收结点发送回确认帧，来判断此次发送是否成功。 2.3.1 常用帧间间隔网络中的无线网卡在检测到信道空闲时到真正发送一帧时，或发送一帧之后到发送下一帧时，都需要间隔一个帧间隔（Inter Frame Space，IFS）时间。IEEE 802.11协议规定了4种帧间间隔： （1）短帧间间隔（Short IFS，SIFS）固定值，是最小的帧间间隔，只有在等待一个SIFS后才可能发送ACK帧、CTS帧。 （2）分布协调功能帧间间隔（Distributed coordination IFS，DIFS）DIFS比PIFS长一个时一隙时间。它只能工作在DCF模式，主要用于在每次通信中的第一帧之前。 （3）点协调功能帧间间隔（Point coordination IFS，PIFS)PIFS比SIFS长一个时隙时间(slot time )，又称集中协调功能帧间间隔。它只能工作在PCF模式，用于在开始使用PCF功能时，使站点能够尽快获得发送权。 （4）扩展帧间间隔（Extended coordination IFS，EIFS）EIFS是最长的IFS，主要用于在前一帧出错的情况下，发送站点必须延迟EIFS，而不是正常情况下的DIFS时间后，再发送下一帧 2.3.2 CSMA/CA原理CSMA/CA的设计目标是为了尽可能减少冲突发送概率，简单概括其基本原理就是信道监听，推迟发送和冲突避免。信道监听通过物理层对无线信道进行载波监听，ACK确认，推迟发送采用虚拟载波监听（Virtual Carrier Sense，VCS）与网络分配向量（Network Allocation Vector，NAV）机制，冲突退避采用DIFS和二进制指数退避算法。 CSMA/CA有两种工作模式，基本模式和可选的RTS/CTS预约模式，后者可以解决隐藏主机带来的冲突问题。这里只介绍基本模式，它的信道接入过程如图2-3所示。 NAV起到一个计时器的作用，其数值由发送主机在帧头的“持续时间”字段广播给其他主机，对于其他主机，只有当检测到NAV=0时才认为信道是空闲的。如果检测到信道空闲，那么发送主机需要等待一个DIFS，然后随机退避n个slot time才能发送数据帧，这个时候的数据帧就携带了此次发送站点的NAV信息，提醒其他站点信道繁忙，让其他站点保持静默以免发送碰撞。退避时间由二进制指数退避算法决定，退避时间为$$W = (2^{2+i}-1)\\cdot W_s$$第i次退避时，从 $2^{i+1}-1$ 个slot time中随机选取一个作为退避时间，如果在退避时，检测到NAV不为0，这表示其他站点开始发送帧，此次竞争失败，则冻结当前退避时间，直到NAV=0并等待DIFS后继续从刚才冻结的退避时间开始倒数。从上述的描述我们可以看到，帧立即发送的条件为：NAV=0并且经过DIFS并且退避时间=0。 接收主机（AP模式下即为AP）收到数据帧后，等待SIFS，才能向发送主机发送ACK确认帧，发送主机收到后，一次帧发送才算完成。 从前述对CSMA/CA的分析我们不难发现，这种机制在AP连接的站点数目较少时性能才比较好，因为此时站点退避的时间相同的概率比较小，发生冲突的概率小，但如果AP接入的站点很多，那么碰撞的概率增大，网络的性能变差。针对这种情况，对其进行改进的研究也很多，我们在后面进行介绍。 3. 无线局域网的MAC层接入技术的改进前面谈到，传统的无线局域网MAC接入技术基于CAMA/CA和BEB机制，在这种机制下，如果网络中接入的站点比较多，数据发生碰撞的概率会增大，极端情况下，如果接入的站点特别多，没有站带你能够向AP发送数据，也就是说在密集组网的情况下，传统的MAC层接入技术有许多需要改进的地方。 3.1 初始竞争窗口值的改进在CSMA/CA和BEB协议中，一些参数如初始竞争窗口值对网络的性能有着显著的影响，系统吞吐量对初始竞争窗口值比较敏感，一个合适的竞争窗口选择方案可以极大地提高系统的吞吐量[6]，这不难理解，当网络负载小的时候，窗口也就可以小一些，让用户得以快速接入。 基于此，有很多竞争窗口值优化方案被提出，竞争窗口值其实是与当前的活跃用户关联在一起的，因此活跃用户检测也是有一个需要考虑的问题，可以根据测量得到的碰撞概率对当前活跃用户进行估计[7]，也可以根据观察到的空闲时隙数来对活跃用户数进行估计[8]，估计完用户数后，再对竞争窗口值进行动态调整。 还有利用贪婪策略的CSMA/CA竞争窗口启发式优化方案，使用贪婪搜索算法得到当前系统初始竞争窗口值的，并根据启发式规则使之处于动态最优状态[9]。 3.2 接入方式的改变从本质上来看CSMA/CA机制是一种随机接入的竞争机制，而且是单用户单信道的，这种机制天然就不适合密集用户的场景。因此，有的学者研究了多信道下的MAC协议，以获得更高的吞吐量和更低的时延[10]。 最新的WiFi标准IEEE 802.11ax引入OFDMA技术，不再采用原来的单用户单信道，而是将整个信道划分为多个子信道来允许多个用户同时接入。新的MAC层技术也必须适应这种接入方式，原有的CSMA/CA其实已经不太适用了，因此，人们又提出了多站点随机接入型和接入点集中调度接入型。 4. 总结本文简单介绍了无线局域网的发展历史，介绍了无线局域网的MAC层接入技术，我们发现，随着网络的发展和接入用户数量的快速增长，带宽和接入速率已经不是限制网络的因素，如何让众多用户有效地接入站点成了一个更加值得重视的问题。其实整个问题不止在无线局域网中存在，在蜂窝网络等用户接入网都会存在这样的问题，这种场景下，用户是随机接入的，如何有效地区分用户是一个很关键的问题。 未来，随着接入站点数目的不断增加，有效地接入控制方法是需要的，值得研究。在一些特定场景下，如工业局域网中，不仅要保证站点的接入，还需要保证高可靠性，针对确定性问题做到指标检测过程和负载调整过程，就可实现良好的负载均衡[11]。针对这些特定场景下的优化的研究也有很多。 参考文献[1] Perahia E .IEEE 802.11n Development: History, Process, and Technology[J]. IEEE Communications Magazine, 2008, 46(7):48-55.[2] IEEE. IEEE Standard for Telecommunications and Information Exchange Between Systems一LAN/MAN Specific Requirements一Part 11:Wireless Medium Access Control (MAC) and physical layer (PHY) specifications: High Speed Physical Layer in the 5 GHz band[C]// IEEE Std 80211a. IEEE, 2002.[3] IEEE. IEEE Standard for Information technology–Local and metropolitan area networks– Specific requirements– Part 11:Wireless LAN Medium Access Control (MAC) and Physical Layer (PHY) Specifications Amendment 2: Fast Basic Service Set (BSS) Transition[J]. IEEE Xplore,2008:1-126.[4] IEEE Standard for Information technology– Telecommunications and information exchange between systems Local and metropolitan area networks—Specific requirements–Part 11:Wireless LAN Medium Access Control (MAC) and Physical Layer (PH Y) Specifications–A[C]// IEEE Std 802.11 ac-2013 (Amendment to IEEE Std 802.11-2012, as amended by IEEE Std 802.11 ae-2012, IEEE Std 802.11 aa-2012, and IEEE Std 802.11 ad-2012). 2013.[5] Zhu H , Li M , Chlamtac I , et al. A survey of quality of service in IEEE 802.11 networks.[J]. Wireless Communications IEEE, 2004, 11(4):6-14.[6] Parker B M, Schormans J A, Gilmour S G. Increasing throughput in IEEE 802.11 by optimal selection of backoff parameters[J]. Networks Iet, 2014, 4(1):21-29.[7] Morino Y, Hiraguri T, Yoshino H, et al. A Novel Contention Window Control Scheme Based on a Markov Chain Model in Dense WLAN Environment[C]// International Conference on Artificial Intelligence. 2016.[8] Yu Q, Zhuang Y, Ma L. Dynamic contention window adjustment scheme for improving throughput and fairness in IEEE 802.11 wireless LANs[C]// Global Communications Conference. IEEE, 2013.[9] 林尚娟. 无线局域网中高效MAC层接入机制研究[D].北京邮电大学,2019.[10] Hadded M , Muhlethaler P , Laouiti A , et al. TDMA-based MAC Protocols for Vehicular Ad Hoc Networks: A Survey, Qualitative Analysis and Open Research Issues[J]. IEEE Communications Surveys &amp; Tutorials, 2015, 17(4):1-1.[11] 程煜钧. 工业无线局域网MAC协议确定性机制研究[D].北京交通大学,2019.","content":"<p>现在初步打算写无线局域网中MAC的接入技术，在知网简单搜索下，发现研究这个的还真不少，如<a href=\"https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CMFD&amp;dbname=CMFD201902&amp;filename=1019113029.nh&amp;uid=WEEvREcwSlJHSldRa1FhdXNzY2Z2S3F4L2xoUW9La0NoVFhnOE9GdXhpZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4ggI8Fm4gTkoUKaID8j8gFw!!&amp;v=MjU0ODllWm9GQ3ZsVUwvSlZGMjZGN0s1SGRIT3BwRWJQSVI4ZVgxTHV4WVM3RGgxVDNxVHJXTTFGckNVUjdxZlk=\" target=\"_blank\" rel=\"noopener\">无线局域网中高效MAC层接入机制研究</a>，<a href=\"https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CMFD&amp;dbname=CMFD202001&amp;filename=1020004190.nh&amp;uid=WEEvREcwSlJHSldRa1FhdXNzY2Z2S3F4L2xoUW9La0NoVFhnOE9GdXhpZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4ggI8Fm4gTkoUKaID8j8gFw!!&amp;v=MjYzMzBab0ZDdmxWcnpCVkYyNUhyTzRHdERGcjVFYlBJUjhlWDFMdXhZUzdEaDFUM3FUcldNMUZyQ1VSN3FmWWU=\" target=\"_blank\" rel=\"noopener\">低时延高可靠无线局域网MAC增强技术研究</a>和<a href=\"https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CDFD&amp;dbname=CDFDLAST2020&amp;filename=1019253781.nh&amp;uid=WEEvREcwSlJHSldRa1FhdXNzY2Z2S3F4L2xoUW9La0NoVFhnOE9GdXhpZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4ggI8Fm4gTkoUKaID8j8gFw!!&amp;v=MjA5NDlkYkVycEViUElSOGVYMUx1eFlTN0RoMVQzcVRyV00xRnJDVVI3cWZZZVpvRkN2a1dydlBWRjI2RjdHOUg=\" target=\"_blank\" rel=\"noopener\">工业无线局域网MAC协议确定性机制研究</a>。看起来写完这篇课程报告不是特别烦，基本上我觉得可以照着一篇硕士论文快速完成这篇课程报告，毕竟时间紧急，拿到该拿的分即可。写完后，我会在这里同步完报告的全部内容。<br><a id=\"more\"></a></p>\n<h2 id=\"1-无线局域网的发展历史\"><a href=\"#1-无线局域网的发展历史\" class=\"headerlink\" title=\"1. 无线局域网的发展历史\"></a>1. 无线局域网的发展历史</h2><p>随着互联网业务的迅速发展，人们对各种在线服务的实时性需求日益强烈。相比蜂窝网，无线局域网网络有着高带宽，灵活以及廉价等诸多优势，目前，无线局域网（Wireless Local Area Network, WLAN）己经在家庭、校园、企业和城市公共场所等多种场景部署。</p>\n<p>可以看到无线局域网已经广泛应用于我们的日常生活，这是由于其传输速率高、带宽配置灵活、使用非授权频段以及方便灵活部署等优势。无线局域网的代表协议是IEEE 802.11系列标准，第一个IEEE 802.11 标准于1997年发表，至今已有 23 年历史了[1]。二十年来，802.11取得了很大的发展，很多新技术进入了标准，推动 802.11 协议日趋完善。</p>\n<p>1997年，IEEE推出了第一个无线局域网标准——IEEE 802.11，其中定义了介质访问控制（MAC）层和物理层。物理层定义了工作在2.4GHz的ISM频段上的两种扩频作调制方式和一种红外线传输的方式，总数据传输速率设计为2Mbit/s，MAC层采用的CSMA/CA技术。</p>\n<p>EEE 802.11a协议[2]在1999年被标准化，它采用的是正交频分复用技术（Orthogonal Frequency Division Multiplexing, OFDM），工作频率为5GHz，使用52个正交频分多路复用子载波，最大原始数据传输率为54Mb/s，达到了现实网络中等吞吐量（20Mb/s）的要求。</p>\n<p>同年IEEE 802.11b被正式批准，该标准规定无线局域网工作频段在2.4GHz，由于工作频段更低，与IEEE 802.11a相比，它的工作范围更大，但速率更低，数据传输速率达到11Mbps。该标准是对IEEE 802.11的一个补充，采用点对点模式和基本模式两种运作模式，其数据传输速率可以根据实际情况在11Mbps、5.5Mbps、2Mbps、1Mbps的不同速率间自动切换，802.11b和工作在5GHz频率上的802.11a标准不兼容。由于价格低廉，802.11b产品已经被广泛地投入市场，并在许多实际工作场所运行。</p>\n<p>2003年7月IEEE 802.11工作组批准了IEEE 802.11g草案，在2.4GHz频段使用正交频分复用技术，使数据传输速率提高到20Mbit/s以上；可与IEEE 802.11b的Wi-Fi系统互联互通，可共存于同一AP的网络里，从而保障了后向兼容性。</p>\n<p>IEEE 802.11 n在2009年标准化，采用了OFDM和4x4多入多出（Multiple-Input Multiple-Output, MIMO）技术[3]，物理层速率可以在两路20MHz信道(共40MHz )中达到600Mbps。</p>\n<p>2013推出的IEEE 802.11ac协议利用OFDM和8x8 MIMO技术[4]，在8个20MHz信道(共160MHz)中，物理层速率可达到6.9Gbps，在802.11n基础上有了很大的提升。最新的 802.11ax 标准已经支持160MHz的带宽，8条流空间复用，基于 OFDMA的多址接入技术提高了信道利用率，满足密集部署场景的应用需求[5]。其他更多标准的简略信息如图1-1所示。    </p>\n<img src=\"/2020/06/curriculum-report-of-computer-network/mainIEEE80211Standard.png\" title=\"图1-1 主要的IEEE 802.11标准\">\n<p>我们可以看到，无线局域网标准定义了协议的工作频段、调制编码方式及最高速度的支持。可以看到，无线局域网的工作频段是2.4GHz和5GHz，前者的具体范围是2.4000～2.4835GHz，后者是5.15～5.825GHz，通常设计工作在2.4GHz频段的协议支持的数据传输速率低一些，但覆盖范围大，工作在5GHz频段的协议支持的数据传输塑料布高一些，但覆盖范围小。从调制技术来看，无线局域网的物理层从CCK向OFDM和MIMO-OFDM发展，支持的传输速率越来越大，2Mbps，54Mbps，600Mbps，1Gbps，9.6Gbps，传输速率是越来越大，当然其中消耗了更多的带宽资源。</p>\n<h2 id=\"2-无线局域网的MAC层\"><a href=\"#2-无线局域网的MAC层\" class=\"headerlink\" title=\"2. 无线局域网的MAC层\"></a>2. 无线局域网的MAC层</h2><h3 id=\"2-1-无线局域网的两种网络结构\"><a href=\"#2-1-无线局域网的两种网络结构\" class=\"headerlink\" title=\"2.1 无线局域网的两种网络结构\"></a>2.1 无线局域网的两种网络结构</h3><p>IEEE 802.11定义了无线局域网的两种网络结构，分别是无中心网络（Ad hoc模式）和有中心网络。在Ad hoc模式下，网络中没有中心站点，各站点式平等的，这是一种对等式网络（Peer-to-Peer，P2P），有中心网络的网络结构中有一个中心站点，又称接入点（Access Point，AP），也叫做AP模式。两种结构的示意图如图2-1所示。</p>\n<p>目前，AP模式是比较常用的，我们在家中使用的WiFi就是这种模式，而Ad hoc一般在一些专用场合使用，平时比较少见。</p>\n<img src=\"/2020/06/curriculum-report-of-computer-network/networdPattern.png\" title=\"图2-1 网络模式示意图\">\n<h3 id=\"2-2-无线局域网的MAC层结构\"><a href=\"#2-2-无线局域网的MAC层结构\" class=\"headerlink\" title=\"2.2 无线局域网的MAC层结构\"></a>2.2 无线局域网的MAC层结构</h3><p>在无线局域网中，无线信道由多个站点共享，它们同处于一个冲突域下，在这种情况下，最需要解决的一个问题就是如何避免站点数据的碰撞，否则站点的数据会发生相互干扰，导致接受站点无法正确接收到信息。这个时候我们就需要一个控制各站点接入无线信道的协议来统一管理，这就是我们的MAC层协议。</p>\n<p>MAC层即介质访问控制层，在传输帧时，一个基站首先要获取共享信道的访问，无线局域网的标准定义了两种介质访问控制方式：分布式协调功能（DCF）和集中式协调功能（PCF）。其中DCF功能是必须支持的，而PCF则不一定。MAC的结构如图2-2所示。</p>\n<img src=\"/2020/06/curriculum-report-of-computer-network/WLANMAC.png\" title=\"图2-2 无线局域网 MAC示意图\">\n<p>DCF机制是IEEE 802.11协议采用的基于竞争的MAC机制，其采用载波监听多址接入/冲突避免（Carrier Sense Multiple Access mechanism with Collision Avoidance，CSMA/CA）和二进制指数退避（Binary Exponential Back-off，BEB）两种基本机制可以为多个站点提供信道接入，各个站点在这种机制下对信道资源进行争用，有可能会发生数据碰撞。</p>\n<p>PCF是MAC的可选用功能，在PCF下，各站点不需要争用信道，信道资源由AP统一分配，这种工作模式下，不会发生数据碰撞。但是一般情况下这种方式使用较少，只有在对传输时间要求高的视频、音频会话类应用时，才会启用PCF方式。</p>\n<h3 id=\"2-3-无线局域网的MAC层接入机制\"><a href=\"#2-3-无线局域网的MAC层接入机制\" class=\"headerlink\" title=\"2.3 无线局域网的MAC层接入机制\"></a>2.3 无线局域网的MAC层接入机制</h3><p>当前，IEEE 802.11MAC协议中广泛采用的接入方法是CSMA/CA。CA的意思是冲突避免，无线局域网发送结点监测到无线信道“空闲”时不“立即”发送帧，而是所有准备发送数据帧的主机都执行退避算法，通过“冲突避免”（CA）来减小冲突发生概率，而且无线局域网发送结点需要等待接收结点发送回确认帧，来判断此次发送是否成功。</p>\n<h4 id=\"2-3-1-常用帧间间隔\"><a href=\"#2-3-1-常用帧间间隔\" class=\"headerlink\" title=\"2.3.1 常用帧间间隔\"></a>2.3.1 常用帧间间隔</h4><p>网络中的无线网卡在检测到信道空闲时到真正发送一帧时，或发送一帧之后到发送下一帧时，都需要间隔一个帧间隔（Inter Frame Space，IFS）时间。IEEE 802.11协议规定了4种帧间间隔：</p>\n<p>（1）短帧间间隔（Short IFS，SIFS）<br>固定值，是最小的帧间间隔，只有在等待一个SIFS后才可能发送ACK帧、CTS帧。</p>\n<p>（2）分布协调功能帧间间隔（Distributed coordination IFS，DIFS）<br>DIFS比PIFS长一个时一隙时间。它只能工作在DCF模式，主要用于在每次通信中的第一帧之前。</p>\n<p>（3）点协调功能帧间间隔（Point coordination IFS，PIFS)<br>PIFS比SIFS长一个时隙时间(slot time )，又称集中协调功能帧间间隔。它只能工作在PCF模式，用于在开始使用PCF功能时，使站点能够尽快获得发送权。</p>\n<p>（4）扩展帧间间隔（Extended coordination IFS，EIFS）<br>EIFS是最长的IFS，主要用于在前一帧出错的情况下，发送站点必须延迟EIFS，而不是正常情况下的DIFS时间后，再发送下一帧</p>\n<h4 id=\"2-3-2-CSMA-CA原理\"><a href=\"#2-3-2-CSMA-CA原理\" class=\"headerlink\" title=\"2.3.2 CSMA/CA原理\"></a>2.3.2 CSMA/CA原理</h4><p>CSMA/CA的设计目标是为了尽可能减少冲突发送概率，简单概括其基本原理就是信道监听，推迟发送和冲突避免。信道监听通过物理层对无线信道进行载波监听，ACK确认，推迟发送采用虚拟载波监听（Virtual Carrier Sense，VCS）与网络分配向量（Network Allocation Vector，NAV）机制，冲突退避采用DIFS和二进制指数退避算法。</p>\n<p>CSMA/CA有两种工作模式，基本模式和可选的RTS/CTS预约模式，后者可以解决隐藏主机带来的冲突问题。这里只介绍基本模式，它的信道接入过程如图2-3所示。</p>\n<img src=\"/2020/06/curriculum-report-of-computer-network/channelConnectionProcess.png\" title=\"图2-3 基本模式下的信道接入过程\">\n<p>NAV起到一个计时器的作用，其数值由发送主机在帧头的“持续时间”字段广播给其他主机，对于其他主机，只有当检测到NAV=0时才认为信道是空闲的。如果检测到信道空闲，那么发送主机需要等待一个DIFS，然后随机退避n个slot time才能发送数据帧，这个时候的数据帧就携带了此次发送站点的NAV信息，提醒其他站点信道繁忙，让其他站点保持静默以免发送碰撞。退避时间由二进制指数退避算法决定，退避时间为<br>$$<br>W = (2^{2+i}-1)\\cdot W_s<br>$$<br>第i次退避时，从 $2^{i+1}-1$ 个slot time中随机选取一个作为退避时间，如果在退避时，检测到NAV不为0，这表示其他站点开始发送帧，此次竞争失败，则冻结当前退避时间，直到NAV=0并等待DIFS后继续从刚才冻结的退避时间开始倒数。从上述的描述我们可以看到，帧立即发送的条件为：NAV=0并且经过DIFS并且退避时间=0。</p>\n<p>接收主机（AP模式下即为AP）收到数据帧后，等待SIFS，才能向发送主机发送ACK确认帧，发送主机收到后，一次帧发送才算完成。</p>\n<p>从前述对CSMA/CA的分析我们不难发现，这种机制在AP连接的站点数目较少时性能才比较好，因为此时站点退避的时间相同的概率比较小，发生冲突的概率小，但如果AP接入的站点很多，那么碰撞的概率增大，网络的性能变差。针对这种情况，对其进行改进的研究也很多，我们在后面进行介绍。</p>\n<h2 id=\"3-无线局域网的MAC层接入技术的改进\"><a href=\"#3-无线局域网的MAC层接入技术的改进\" class=\"headerlink\" title=\"3. 无线局域网的MAC层接入技术的改进\"></a>3. 无线局域网的MAC层接入技术的改进</h2><p>前面谈到，传统的无线局域网MAC接入技术基于CAMA/CA和BEB机制，在这种机制下，如果网络中接入的站点比较多，数据发生碰撞的概率会增大，极端情况下，如果接入的站点特别多，没有站带你能够向AP发送数据，也就是说在密集组网的情况下，传统的MAC层接入技术有许多需要改进的地方。</p>\n<h3 id=\"3-1-初始竞争窗口值的改进\"><a href=\"#3-1-初始竞争窗口值的改进\" class=\"headerlink\" title=\"3.1 初始竞争窗口值的改进\"></a>3.1 初始竞争窗口值的改进</h3><p>在CSMA/CA和BEB协议中，一些参数如初始竞争窗口值对网络的性能有着显著的影响，系统吞吐量对初始竞争窗口值比较敏感，一个合适的竞争窗口选择方案可以极大地提高系统的吞吐量[6]，这不难理解，当网络负载小的时候，窗口也就可以小一些，让用户得以快速接入。</p>\n<p>基于此，有很多竞争窗口值优化方案被提出，竞争窗口值其实是与当前的活跃用户关联在一起的，因此活跃用户检测也是有一个需要考虑的问题，可以根据测量得到的碰撞概率对当前活跃用户进行估计[7]，也可以根据观察到的空闲时隙数来对活跃用户数进行估计[8]，估计完用户数后，再对竞争窗口值进行动态调整。</p>\n<p>还有利用贪婪策略的CSMA/CA竞争窗口启发式优化方案，使用贪婪搜索算法得到当前系统初始竞争窗口值的，并根据启发式规则使之处于动态最优状态[9]。</p>\n<h3 id=\"3-2-接入方式的改变\"><a href=\"#3-2-接入方式的改变\" class=\"headerlink\" title=\"3.2 接入方式的改变\"></a>3.2 接入方式的改变</h3><p>从本质上来看CSMA/CA机制是一种随机接入的竞争机制，而且是单用户单信道的，这种机制天然就不适合密集用户的场景。因此，有的学者研究了多信道下的MAC协议，以获得更高的吞吐量和更低的时延[10]。</p>\n<p>最新的WiFi标准IEEE 802.11ax引入OFDMA技术，不再采用原来的单用户单信道，而是将整个信道划分为多个子信道来允许多个用户同时接入。新的MAC层技术也必须适应这种接入方式，原有的CSMA/CA其实已经不太适用了，因此，人们又提出了多站点随机接入型和接入点集中调度接入型。</p>\n<h2 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h2><p>本文简单介绍了无线局域网的发展历史，介绍了无线局域网的MAC层接入技术，我们发现，随着网络的发展和接入用户数量的快速增长，带宽和接入速率已经不是限制网络的因素，如何让众多用户有效地接入站点成了一个更加值得重视的问题。其实整个问题不止在无线局域网中存在，在蜂窝网络等用户接入网都会存在这样的问题，这种场景下，用户是随机接入的，如何有效地区分用户是一个很关键的问题。</p>\n<p>未来，随着接入站点数目的不断增加，有效地接入控制方法是需要的，值得研究。在一些特定场景下，如工业局域网中，不仅要保证站点的接入，还需要保证高可靠性，针对确定性问题做到指标检测过程和负载调整过程，就可实现良好的负载均衡[11]。针对这些特定场景下的优化的研究也有很多。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p>[1]   Perahia E .IEEE 802.11n Development: History, Process, and Technology[J]. IEEE Communications Magazine, 2008, 46(7):48-55.<br>[2]   IEEE. IEEE Standard for Telecommunications and Information Exchange Between Systems一LAN/MAN Specific Requirements一Part 11:Wireless Medium Access Control (MAC) and physical layer (PHY) specifications: High Speed Physical Layer in the 5 GHz band[C]// IEEE Std 80211a. IEEE, 2002.<br>[3]   IEEE. IEEE Standard for Information technology–Local and metropolitan area networks– Specific requirements– Part 11:Wireless LAN Medium Access Control (MAC) and Physical Layer (PHY) Specifications Amendment 2: Fast Basic Service Set (BSS) Transition[J]. IEEE Xplore,2008:1-126.<br>[4]   IEEE Standard for Information technology– Telecommunications and information exchange between systems Local and metropolitan area networks—Specific requirements–Part 11:Wireless LAN Medium Access Control (MAC) and Physical Layer (PH Y) Specifications–A[C]// IEEE Std 802.11 ac-2013 (Amendment to IEEE Std 802.11-2012, as amended by IEEE Std 802.11 ae-2012, IEEE Std 802.11 aa-2012, and IEEE Std 802.11 ad-2012). 2013.<br>[5]   Zhu H , Li M , Chlamtac I , et al. A survey of quality of service in IEEE 802.11 networks.[J]. Wireless Communications IEEE, 2004, 11(4):6-14.<br>[6]   Parker B M, Schormans J A, Gilmour S G. Increasing throughput in IEEE 802.11 by optimal selection of backoff parameters[J]. Networks Iet, 2014, 4(1):21-29.<br>[7]   Morino Y, Hiraguri T, Yoshino H, et al. A Novel Contention Window Control Scheme Based on a Markov Chain Model in Dense WLAN Environment[C]// International Conference on Artificial Intelligence. 2016.<br>[8]   Yu Q, Zhuang Y, Ma L. Dynamic contention window adjustment scheme for improving throughput and fairness in IEEE 802.11 wireless LANs[C]// Global Communications Conference. IEEE, 2013.<br>[9]   林尚娟. 无线局域网中高效MAC层接入机制研究[D].北京邮电大学,2019.<br>[10] Hadded M , Muhlethaler P , Laouiti A , et al. TDMA-based MAC Protocols for Vehicular Ad Hoc Networks: A Survey, Qualitative Analysis and Open Research Issues[J]. IEEE Communications Surveys &amp; Tutorials, 2015, 17(4):1-1.<br>[11] 程煜钧. 工业无线局域网MAC协议确定性机制研究[D].北京交通大学,2019.</p>\n","tags":[{"name":"网络","slug":"网络","permalink":"https://jonathan1214.github.io/tags/网络/"}]},{"title":"A Distance Sensor Demo For Arduino","date":"2020-06-01T09:34:56.000Z","path":"2020/06/distance-sensor-demo-for-arduino/","text":"Distance sensor can be very useful in some conditons, such as obstacles detecting and avoiding. By using arduino, it’s very easy for us to use distance sensor. This demo show us a simple example to use distance sensor. For better display, we will use LCD1602 to show the distance. It’s modified from example in arduino. Supplies Arduino uno R3 HC-SR04 Breadboard LCD1602 Red LED Spotter Two 100 Ohm resistance some DuPont lines Step 1 Design and connect circuitBrowsering internet, it’s easy to find instructions of HC-SR04 and LCD1602. And there are so many libraries for us in arduino. In our circuit, arduino digital pin 2, 3, 4, 5, 11 and 12 are used for LCD1602 while digital pin 7 and 8 are for HC-SR04. LED uses digital pin 13. Finally, following is our circuits. Step2 CodeAs we said before, our program is based on libraries. So it’s simple to write code. Later I will display complete code. Outside the loop, we define a function readUltrasonicDistance used for HC-SR04. Calling this readUltrasonicDistance, we get distance in centimeter. Inside the function setup, we initialize a LCD1604. In the loop, we get distance in centimeter by calling function readUltrasonicDistance. Then we clear LCD screen and print some characters and distance we just got. Finally, we turn on the LED if distance less than 90cm, or turn off the LED if not less than 90cm. Here shows complete code. distanceDemo.cview raw12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;LiquidCrystal.h&gt;// initialize the library with the numbers of the interface pinsLiquidCrystal lcd(12, 11, 5, 4, 3, 2);int cm = 0;long readUltrasonicDistance(int triggerPin, int echoPin){ pinMode(triggerPin, OUTPUT); // Clear the trigger digitalWrite(triggerPin, LOW); delayMicroseconds(2); // Sets the trigger pin to HIGH state for 10 microseconds digitalWrite(triggerPin, HIGH); delayMicroseconds(10); digitalWrite(triggerPin, LOW); pinMode(echoPin, INPUT); // Reads the echo pin, and returns the sound wave travel time in microseconds return pulseIn(echoPin, HIGH);}int LED = 13;void setup(){ Serial.begin(9600); lcd.begin(16, 2); lcd.print(\"DistanceSensor:\"); pinMode(LED,OUTPUT);}void loop(){ // measure the ping time in cm cm = 0.01723 * readUltrasonicDistance(7, 8); // convert to inches by dividing by 2.54 Serial.print(cm); Serial.println(\"cm\"); lcd.clear(); lcd.print(\"DistanceSensor:\"); lcd.setCursor(0, 1); lcd.print(cm); lcd.print(\"cm\"); if (cm &lt; 90) { digitalWrite(LED, HIGH); delay(1000); } else { digitalWrite(LED, LOW); delay(500); // Wait for 100 millisecond(s) }} SummaryIn this post, we show a demo to use distance sensor HC-SR04 and LCD1602. It’s a good example to use the sensor. Also, there are many possible usages.","content":"<p>Distance sensor can be very useful in some conditons, such as obstacles detecting and avoiding. By using arduino, it’s very easy for us to use distance sensor. This demo show us a simple example to use distance sensor. For better display, we will use LCD1602 to show the distance. <strong>It’s modified from example in arduino.</strong><br><a id=\"more\"></a></p>\n<h2 id=\"Supplies\"><a href=\"#Supplies\" class=\"headerlink\" title=\"Supplies\"></a>Supplies</h2><ul>\n<li>Arduino uno R3</li>\n<li>HC-SR04</li>\n<li>Breadboard</li>\n<li>LCD1602</li>\n<li>Red LED</li>\n<li>Spotter</li>\n<li>Two 100 Ohm resistance</li>\n<li>some DuPont lines</li>\n</ul>\n<h2 id=\"Step-1-Design-and-connect-circuit\"><a href=\"#Step-1-Design-and-connect-circuit\" class=\"headerlink\" title=\"Step 1 Design and connect circuit\"></a>Step 1 Design and connect circuit</h2><p>Browsering internet, it’s easy to find instructions of HC-SR04 and LCD1602. And there are so many libraries for us in arduino. In our circuit, arduino digital pin 2, 3, 4, 5, 11 and 12 are used for LCD1602 while digital pin 7 and 8 are for HC-SR04. LED uses digital pin 13. Finally, following is our circuits.</p>\n<img src=\"/2020/06/distance-sensor-demo-for-arduino/distance-sensor-demo.png\" title=\"Final Circuit\">\n<h2 id=\"Step2-Code\"><a href=\"#Step2-Code\" class=\"headerlink\" title=\"Step2 Code\"></a>Step2 Code</h2><p>As we said before, our program is  based on libraries. So it’s simple to write code. Later I will display complete code. </p>\n<p>Outside the loop, we define a function readUltrasonicDistance used for HC-SR04. Calling this readUltrasonicDistance, we get distance in centimeter. Inside the function setup, we initialize a LCD1604. In the loop, we get distance in centimeter by calling function readUltrasonicDistance. Then we clear LCD screen and print some characters and distance we just got. Finally, we turn on the LED if distance less than 90cm, or turn off the LED if not less than 90cm.</p>\n<p>Here shows complete code.</p>\n<figure class=\"highlight c\"><figcaption><span>distanceDemo.c</span><a href=\"/downloads/code/distanceDemo.c\">view raw</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;LiquidCrystal.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// initialize the library with the numbers of the interface pins</span></span><br><span class=\"line\"><span class=\"function\">LiquidCrystal <span class=\"title\">lcd</span><span class=\"params\">(<span class=\"number\">12</span>, <span class=\"number\">11</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> cm = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">readUltrasonicDistance</span><span class=\"params\">(<span class=\"keyword\">int</span> triggerPin, <span class=\"keyword\">int</span> echoPin)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">  pinMode(triggerPin, OUTPUT);  <span class=\"comment\">// Clear the trigger</span></span><br><span class=\"line\">  digitalWrite(triggerPin, LOW);</span><br><span class=\"line\">  delayMicroseconds(<span class=\"number\">2</span>);</span><br><span class=\"line\">  <span class=\"comment\">// Sets the trigger pin to HIGH state for 10 microseconds</span></span><br><span class=\"line\">  digitalWrite(triggerPin, HIGH);</span><br><span class=\"line\">  delayMicroseconds(<span class=\"number\">10</span>);</span><br><span class=\"line\">  digitalWrite(triggerPin, LOW);</span><br><span class=\"line\">  pinMode(echoPin, INPUT);</span><br><span class=\"line\">  <span class=\"comment\">// Reads the echo pin, and returns the sound wave travel time in microseconds</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> pulseIn(echoPin, HIGH);</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">int</span> LED = <span class=\"number\">13</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setup</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">  Serial.begin(<span class=\"number\">9600</span>);</span><br><span class=\"line\">  lcd.begin(<span class=\"number\">16</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">  lcd.print(<span class=\"string\">\"DistanceSensor:\"</span>);</span><br><span class=\"line\">  pinMode(LED,OUTPUT);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">  <span class=\"comment\">// measure the ping time in cm</span></span><br><span class=\"line\">  cm = <span class=\"number\">0.01723</span> * readUltrasonicDistance(<span class=\"number\">7</span>, <span class=\"number\">8</span>);</span><br><span class=\"line\">  <span class=\"comment\">// convert to inches by dividing by 2.54</span></span><br><span class=\"line\">  Serial.print(cm);</span><br><span class=\"line\">  Serial.println(<span class=\"string\">\"cm\"</span>);</span><br><span class=\"line\">  lcd.clear();</span><br><span class=\"line\">  lcd.print(<span class=\"string\">\"DistanceSensor:\"</span>);</span><br><span class=\"line\">  lcd.setCursor(<span class=\"number\">0</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">  lcd.print(cm);</span><br><span class=\"line\">  lcd.print(<span class=\"string\">\"cm\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cm &lt; <span class=\"number\">90</span>) {</span><br><span class=\"line\">      digitalWrite(LED, HIGH);</span><br><span class=\"line\">      delay(<span class=\"number\">1000</span>);</span><br><span class=\"line\">  } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">      digitalWrite(LED, LOW);</span><br><span class=\"line\">      delay(<span class=\"number\">500</span>); <span class=\"comment\">// Wait for 100 millisecond(s)</span></span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>In this post, we show a demo to use distance sensor HC-SR04 and LCD1602. It’s a good example to use the sensor. Also, there are many possible usages.</p>\n","tags":[]},{"title":"支持话音业务的卫星通信链路信道编码设计","date":"2020-05-26T03:18:10.000Z","path":"2020/05/curriculum-design-of-satellite-communications/","text":"又是一篇关于课程内容的文章，这次是卫星通信课设。如题所示，按照要求，我们需要设计一种支持话音业务的卫星通信链路信道编码设计，以达到给定的性能指标，不过稍微想想也能知道，我们现在并不具备这样的能力，我猜测这个课设题的目的是为了让我们熟悉已有的信道编码方式，比较它们的性能并根据需要选择一种方式。先给出题目： 题目三：支持话音业务的卫星通信链路道编码设计 。话音信号的传输速率为 4.8kbps，误码性能为 $1\\times 10^{-3}$，并采用 BPSK 调制方式。设计一种在开阔地区可进行话音通信的信道编码方式。 题目理解五个人开了两次会，讨论出一个大概的对于题目理解的结果。题目不长，有几个关键点需要抓住：信道编码，传输速率，误码性能，BPSK 和开阔地区。我们的分析结果如下： 虽然在开阔地区或许不用考虑多径干扰，但是还是需要考虑卫星通信中的突发错误，因此需要考虑交织技术来对抗突发错误，由话音业务中的时延要求确定交织时延的大小，进而通过传输速率确定交织深度。 最终的比较选择是在误码率 $1\\times 10^{-3}$ 下，我们计算不同的信道编码方式下需要的信噪比即可，这是最主要的方面，同时码率和时延进行分析比较，得出最终的编码方式选择结果。 好在开题时老师指出了我们的一些问题，也给我们指明了方向： 在设计信道编码时，必须要考虑到具体的链路参数，最好用一个实际的卫星和地面段进行分析，信道考虑为莱斯信道是正确的； 信道编码的选择受到很多参数的约束，我们需要在这些参数中间进行折中考虑，如功率效率、误码率、编码效率和带宽。 按照老师的指导，我们分工了，有人负责链路预算，有人复杂写报告，我负责进行 MATLAB 仿真。 仿真折腾了两天，最终仿真了汉明码和卷积码在 AWGN 信道和莱斯信道下的误码性能，还做了下经过交织后的汉明码在莱斯信道下的误码性能，但是效果很差，由于时间紧急，没来得及做交织后的卷积码在莱斯信道下的误码性能分析，实际当中经过交织的卷积码才是用的比较多的。 具体代码在此列出了，放到了 Github 上，新建了一个仓库用来存放所有做过的实验和一些课设的代码，本次课设的代码地址在这里。这里就放几张图吧。 总结仿真而论，本次课设并没有太多可说道的，当然这也不是本次课设的目的，结题答辩时老师告诉我们这次课设不是让我们去计算什么，是为了让我们去尝试在一个系统中设计一些东西，全面考虑问题，做一些折中。深以为然。","content":"<p>又是一篇关于课程内容的文章，这次是卫星通信课设。如题所示，按照要求，我们需要设计一种支持话音业务的卫星通信链路信道编码设计，以达到给定的性能指标，不过稍微想想也能知道，我们现在并不具备这样的能力，我猜测这个课设题的目的是为了让我们熟悉已有的信道编码方式，比较它们的性能并根据需要选择一种方式。先给出题目：</p>\n<blockquote>\n<p>题目三：支持话音业务的卫星通信链路道编码设计 。话音信号的传输速率为 4.8kbps，误码性能为 $1\\times 10^{-3}$，并采用 BPSK 调制方式。设计一种在开阔地区可进行话音通信的信道编码方式。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"题目理解\"><a href=\"#题目理解\" class=\"headerlink\" title=\"题目理解\"></a>题目理解</h2><p>五个人开了两次会，讨论出一个大概的对于题目理解的结果。题目不长，有几个关键点需要抓住：信道编码，传输速率，误码性能，BPSK 和开阔地区。我们的分析结果如下：</p>\n<ol>\n<li>虽然在开阔地区或许不用考虑多径干扰，但是还是需要考虑卫星通信中的突发错误，因此需要考虑交织技术来对抗突发错误，由话音业务中的时延要求确定交织时延的大小，进而通过传输速率确定交织深度。</li>\n<li>最终的比较选择是在误码率 $1\\times 10^{-3}$ 下，我们计算不同的信道编码方式下需要的信噪比即可，这是最主要的方面，同时码率和时延进行分析比较，得出最终的编码方式选择结果。</li>\n</ol>\n<p>好在开题时老师指出了我们的一些问题，也给我们指明了方向：</p>\n<ul>\n<li>在设计信道编码时，必须要考虑到具体的链路参数，最好用一个实际的卫星和地面段进行分析，信道考虑为莱斯信道是正确的；</li>\n<li>信道编码的选择受到很多参数的约束，我们需要在这些参数中间进行折中考虑，如功率效率、误码率、编码效率和带宽。</li>\n</ul>\n<p>按照老师的指导，我们分工了，有人负责链路预算，有人复杂写报告，我负责进行 MATLAB 仿真。</p>\n<h2 id=\"仿真\"><a href=\"#仿真\" class=\"headerlink\" title=\"仿真\"></a>仿真</h2><p>折腾了两天，最终仿真了汉明码和卷积码在 AWGN 信道和莱斯信道下的误码性能，还做了下经过交织后的汉明码在莱斯信道下的误码性能，但是效果很差，由于时间紧急，没来得及做交织后的卷积码在莱斯信道下的误码性能分析，实际当中经过交织的卷积码才是用的比较多的。</p>\n<p>具体代码在此列出了，放到了 Github 上，新建了一个仓库用来存放所有做过的实验和一些课设的代码，本次课设的代码地址在<a href=\"\">这里</a>。这里就放几张图吧。</p>\n<img src=\"/2020/05/curriculum-design-of-satellite-communications/hamming.jpg\" title=\"汉明码性能仿真\">\n<img src=\"/2020/05/curriculum-design-of-satellite-communications/convolutional_213.jpg\" title=\"213卷积码性能仿真\">\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>仿真而论，本次课设并没有太多可说道的，当然这也不是本次课设的目的，结题答辩时老师告诉我们这次课设不是让我们去计算什么，是为了让我们去尝试在一个系统中设计一些东西，全面考虑问题，做一些折中。深以为然。</p>\n","tags":[{"name":"通信","slug":"通信","permalink":"https://jonathan1214.github.io/tags/通信/"}]},{"title":"MPSK 和 MQAM 的误码率仿真","date":"2020-05-21T06:23:28.000Z","path":"2020/05/ber-and-ser-of-PSK-and-QAM/","text":"拖延几日，不觉课程已结课几天了，在此趁着脑中还有些关于课程内容的印象，简单写一篇记录，关于如何使用MATLAB构建一个调制技术的仿真程序。 BPSK首先来看最简单的二进制仿真，以 BPSK 为例，我们来看看如何搭建一个仿真仿真程序，从中得到些一般的仿真设置方法。 在进行仿真之前，先看看我们期待需要得到的是什么——BPSK的误码率 Pe 随信噪比 SNR 的变化曲线，那么这个图像的横坐标就是信噪比，纵坐标就是误码率。这里面还有一个问题需要提前考虑，老师也在上课的时候强调过让我们去思考，即 SNR 和 $\\frac{E_b}{N_0}$ 的关系，我们的结论是 $SNR=2\\frac{E_b}{N_0}$，这里面有一个从带通等效到低通的过程，同时把基带波形的因素也进行一般化，具体的我只是有一个模糊的概念，等我真的理解了，有机会再来补上吧。最终我们要画的就是 Pe 随 $\\frac{E_b}{N_0}$ 的变化曲线。 这里直接给出理论值计算公式，具体推导并不复杂。$$P_e=\\frac{1}{2}erfc(\\frac{E_b}{N_0})$$ 接下来的问题在于我们如何通过 $\\frac{E_b}{N_0}$ 定量描述噪声和信号的大小，在仿真中我们需要实际比较噪声和信号幅度的大小确定最终的判定结果。 先来看一个比较笨的办法，这个办法并不具有一般性，它没有使用到一个特别重要的东西——星座图，后续我会利用星座图给出一个更加简单的方法。考虑如下这个公式：$$SNR = \\frac{P_s}{P_n}=\\frac{E_b/T_s}{N_0\\cdot B}\\times log_2(M)=\\frac{E_b}{N_0}=\\frac{a^2}{2\\sigma^2}$$ 信号幅度a=1，则立即可以得到噪声功率 $$\\sigma^2=\\frac{1}{2E_b/N_0}$$ BPSK 的基带信号是双极性的，用 -1 和 +1 来表示两种不同极性的信号，前面已经得到噪声的功率，那么信号加上噪声幅度就得到接收信号。这就是关键之处，确定信号和噪声的定量关系，已经噪声该如何加到信号上，明白了这个，其余都很简单。最终我们可以得到如下的代码： BPSK.mview raw123456789101112131415161718192021EbN0dB = 0:1:10;EbN0 = 10.^(EbN0dB/10);N = 2*10^6; % 发送比特数即码元数Pb = 0.5*erfc(sqrt(EbN0)); % 理论值ber = zeros(1, length(EbN0dB)); % 仿真误码率 预分配a = sign(randn(1, N)); % 基带信号noise = randn(1, N); % 标准噪声sigma = sqrt(1./EbN0/2); % 噪声功率for n = 1:length(EbN0dB) rk = a + sigma(n)*noise; % 加噪声得到接收信号 dec_a = sign(rk); % 判决 ber(n) = sum(abs(a-dec_a)/2)/length(a);endsemilogy(EbN0dB, Pb, 'LineWidth', 1);hold on;semilogy(EbN0dB, ber, 'rd');legend('理论结果', '仿真结果')xlabel('\\itE_b/N_0\\rm(dB)'); ylabel('Pb');title('BPSK误码率仿真')grid on 得到的结果如下所示： 第二种方法更具有一般性，理解了它，其他调制方式也是一样的可以实现。这需要星座图的帮助，通过星座图，我们可以得到最小欧式距离和平均比特能量的关系。在 BPSK 中，有$$d_{min}=\\sqrt{4E_b}$$ 同时，$\\frac{d_{min}}{2}$ 也正是信号的幅度，令 $d_{min}=2$，则信号的幅度为 $a=1$，由 $\\frac{E_b}{N_0}$ 和 $d_{min}$ 与 $E_b$ 的关系，我们可以得到$$N_0=\\frac{E_b}{E_b/N_0}=\\frac{d_{min}^2}{4}\\cdot\\frac{1}{E_b/N_0}$$ 那么噪声功率就是$\\sigma^2=\\frac{N_0}{2}$。然后按照第一种方法的思路去编写仿真程序即可，非常简单。再来说说它的通用性，使用星座图仿真 AWGN 信道下的调制方式，我们首先需要确定最小欧式距离和平均比特能量的关系，然后得到噪声功率即可，这样就可以得到信号和噪声的定量关系，进行仿真即可。 QPSK利用上面提到的具有一般性的方式，我们需要使用星座图，QPSK有如下两种星座图形式： 以第一种左边的星座图为例，说明仿真过程。对于 MPSK 调制，最小欧式距离为：$$d_{min}=2\\sqrt{(log_2M\\times sin^2\\frac{\\pi}{M})\\varepsilon_b}$$在 QPSK 中，M=4，则 $d_{min}=2\\sqrt{\\varepsilon_b}$。注意到这和之前的 BPSK 不一样，我们可以将 QPSK 看作两路正交的相位调制叠加。仿真中我们令 $d_{min}=2$，则$\\varepsilon =1$，进而可以得到两路信号的幅度都是1，同时还可以确定噪声功率为 $\\sigma^2 = \\frac{1}{2SNR}$。按照上面的仿真思路我们很容易可以写出代码，最终得到的图形如下所示。 16QAM 和 16PSK同理，对16QAM和16PSK也是一样的道理，只不过星座点映射在代码实现上会稍稍复杂一点。分析 16QAM 可以将它看作两路正交的 4PAM 信号的叠加，其余分析方法和上面完全相同。16PSK 就更加简单了，不多说，直接给出代码和最终的波形图，如下所示。 QAMandPSK.mview raw123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125clear all;close all;clc;EbN0dB = 0:1:15;EbN0 = 10.^(EbN0dB/10);M = 16; % 16 QAMN = 64; % 64 QAM%% 16QAM 64QAM theoryPe_16_help = 2*(1-1/sqrt(M))*qfunc(sqrt(3*log2(M)*EbN0/(M-1)));Pe_16 = 1- (1 - Pe_16_help).^2;Pb_16 = Pe_16 / 4;Pe_64_help = 2*(1-1/sqrt(N))*qfunc(sqrt(3*log2(N)*EbN0/(N-1)));Pe_64 = 1- (1 - Pe_64_help).^2;%% 16PSK theoryPe_theory_PSK = 2*qfunc(sin(pi/M)*sqrt(2*log2(M)*EbN0));%% theory plotsemilogy(EbN0dB, Pe_16, 'LineWidth', 1)hold on% semilogy(EbN0dB, Pe_64)% hold onsemilogy(EbN0dB, Pe_theory_PSK, 'k', 'LineWidth', 1)hold onsemilogy(EbN0dB, Pb_16, 'c', 'LineWidth', 1)hold onsemilogy(EbN0dB, Pe_theory_PSK / 4, 'g', 'LineWidth', 1)grid onxlabel('\\it{E_b/N_0} \\rm(dB)')ylabel('P_b and P_e')% 16QAM 仿真% 格雷码映射表gray_code_table = [0 0 0 0; % 0 1 0 0 0; % 1 1 1 0 0; % 2 0 1 0 0; % 3 0 1 1 0; % 4 1 1 1 0; % 5 1 0 1 0; % 6 0 0 1 0; % 7 0 0 1 1; % 8 1 0 1 1; % 9 1 1 1 1; % 10 0 1 1 1; % 11 0 1 0 1; % 12 1 1 0 1; % 13 1 0 0 1; % 14 0 0 0 1;];% 15% 星座点位置表 16QAMstar_table_1 = [-1*(-3:2:3) (-3:2:3) -1*(-3:2:3) (-3:2:3)];star_table_2 = [ones(1, 4)*3 ones(1, 4) -1*ones(1,4) -3*ones(1,4)];star_table = [star_table_1' star_table_2'];star_table_T = star_table';table_used = reshape(star_table_T, 1, M*2);% 星座点位置表 16PSKphase = 0:2*pi/M:(2*pi-2*pi/M);PSK16StarTable = [cos(phase); sin(phase)];PSK_table_used = reshape(PSK16StarTable, M*2, 1);% 基带信号N = 4*10^4; % bit数base = (sign(randn(1, N)) + 1) / 2;mid_modul = reshape(base, [4 N/4]);mid_modul = mid_modul';% 映射到星座点上 QAM 和 QPSKmodulSignalPosi = zeros(N/4, 2);PSK_modulSignalPosi = zeros(2, N/4);for symbol = 1:N/4 dude = gray2int(mid_modul(symbol, :)) + 1; modulSignalPosi(symbol, :) = star_table(dude, :); PSK_modulSignalPosi(:, symbol) = PSK16StarTable(:, dude);end% 噪声sigma = sqrt(4*(M-1)/6/log2(M)./EbN0/2);PSK_sigma = sqrt(1/log2(M)./EbN0/2);% 过信道 解调 求信噪比be = zeros(1, length(EbN0dB));se = zeros(1, length(EbN0dB));PSK_be = zeros(1, length(EbN0dB));PSK_se = zeros(1, length(EbN0dB));for index = 1:length(EbN0dB) % 加噪声 reciPosi = modulSignalPosi + sigma(index) * randn(N/4, 2); % 最小距离解调 QAM distanceMid = repmat(reciPosi, [1 M]) - repmat(table_used, N/4, 1); distanceMid = distanceMid.^2; distance = distanceMid(:, 1:2:(M*2-1)) + distanceMid(:, 2:2:(M*2)); distance = distance'; % decodePosi 即为解调结果对应gray_code_table的位置 [~, decodePosi] = min(distance); % 解调结果映射到基带 QAM toBaseGray = gray_code_table(decodePosi, :); toBaseSignal = reshape(toBaseGray', 1, N); be(index) = sum(abs(base-toBaseSignal)); se_posi = double(mid_modul ~= toBaseGray); se(index) = sum(sign(sum(se_posi, 2))); % PSK PSK_reciPosi = PSK_modulSignalPosi + PSK_sigma(index) * randn(2, N/4); PSK_distanceMid = repmat(PSK_reciPosi, [M 1]) - repmat(PSK_table_used, [1 N/4]); PSK_distanceMid = PSK_distanceMid.^2; PSK_distance = PSK_distanceMid(1:2:(M*2-1), :) + PSK_distanceMid(2:2:(M*2), :); [~, PSK_decodePosi] = min(PSK_distance); PSK_toBaseGray = gray_code_table(PSK_decodePosi, :); PSK_toBaseSignal = reshape(PSK_toBaseGray', 1, N); PSK_be(index) = sum(abs(base-PSK_toBaseSignal)); PSK_se_posi = double(mid_modul ~= PSK_toBaseGray); PSK_se(index) = sum(sign(sum(PSK_se_posi, 2)));endsemilogy(EbN0dB, se/N*4, 'v', 'MarkerEdgeColor', 'r')hold onsemilogy(EbN0dB, be/N, '*', 'MarkerEdgeColor', 'r')hold onsemilogy(EbN0dB, PSK_se/N*4, '^', 'MarkerEdgeColor', 'm')hold onsemilogy(EbN0dB, PSK_be/N, '*', 'MarkerEdgeColor', 'm')legend('16QAM理论误码率', '16PSK理论误码率', '16QAM理论误比特率', '16PSK理论误比特率', ... '16QAM仿真误码率', '16QAM仿真误比特率', '16PSK仿真误码率', '16PSK仿真误比特率')title('16QAM and 16PSK')","content":"<p>拖延几日，不觉课程已结课几天了，在此趁着脑中还有些关于课程内容的印象，简单写一篇记录，关于如何使用MATLAB构建一个调制技术的仿真程序。<br><a id=\"more\"></a></p>\n<h2 id=\"BPSK\"><a href=\"#BPSK\" class=\"headerlink\" title=\"BPSK\"></a>BPSK</h2><p>首先来看最简单的二进制仿真，以 BPSK 为例，我们来看看如何搭建一个仿真仿真程序，从中得到些一般的仿真设置方法。</p>\n<p>在进行仿真之前，先看看我们期待需要得到的是什么——BPSK的误码率 Pe 随信噪比 SNR 的变化曲线，那么这个图像的横坐标就是信噪比，纵坐标就是误码率。这里面还有一个问题需要提前考虑，老师也在上课的时候强调过让我们去思考，即 SNR 和 $\\frac{E_b}{N_0}$ 的关系，我们的结论是 $SNR=2\\frac{E_b}{N_0}$，这里面有一个<strong>从带通等效到低通的过程，同时把基带波形的因素也进行一般化</strong>，具体的我只是有一个模糊的概念，等我真的理解了，有机会再来补上吧。最终我们要画的就是 Pe 随 $\\frac{E_b}{N_0}$ 的变化曲线。</p>\n<p>这里直接给出理论值计算公式，具体推导并不复杂。<br>$$<br>P_e=\\frac{1}{2}erfc(\\frac{E_b}{N_0})<br>$$</p>\n<p>接下来的问题在于我们如何通过 $\\frac{E_b}{N_0}$ 定量描述噪声和信号的大小，在仿真中我们需要实际比较噪声和信号幅度的大小确定最终的判定结果。</p>\n<p>先来看一个比较笨的办法，这个办法并不具有一般性，它没有使用到一个特别重要的东西——<strong>星座图</strong>，后续我会利用星座图给出一个更加简单的方法。考虑如下这个公式：<br>$$<br>SNR = \\frac{P_s}{P_n}=\\frac{E_b/T_s}{N_0\\cdot B}\\times log_2(M)=\\frac{E_b}{N_0}=\\frac{a^2}{2\\sigma^2}<br>$$</p>\n<p>信号幅度a=1，则立即可以得到噪声功率</p>\n<p>$$<br>\\sigma^2=\\frac{1}{2E_b/N_0}<br>$$</p>\n<p>BPSK 的基带信号是双极性的，用 -1 和 +1 来表示两种不同极性的信号，前面已经得到噪声的功率，那么信号加上噪声幅度就得到接收信号。这就是关键之处，确定信号和噪声的定量关系，已经噪声该如何加到信号上，明白了这个，其余都很简单。最终我们可以得到如下的代码：</p>\n<figure class=\"highlight matlab\"><figcaption><span>BPSK.m</span><a href=\"/downloads/code/BPSK.m\">view raw</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EbN0dB = <span class=\"number\">0</span>:<span class=\"number\">1</span>:<span class=\"number\">10</span>;</span><br><span class=\"line\">EbN0 = <span class=\"number\">10.</span>^(EbN0dB/<span class=\"number\">10</span>);</span><br><span class=\"line\">N = <span class=\"number\">2</span>*<span class=\"number\">10</span>^<span class=\"number\">6</span>;                     <span class=\"comment\">% 发送比特数即码元数</span></span><br><span class=\"line\">Pb = <span class=\"number\">0.5</span>*<span class=\"built_in\">erfc</span>(<span class=\"built_in\">sqrt</span>(EbN0));      <span class=\"comment\">% 理论值</span></span><br><span class=\"line\">ber = <span class=\"built_in\">zeros</span>(<span class=\"number\">1</span>, <span class=\"built_in\">length</span>(EbN0dB)); <span class=\"comment\">% 仿真误码率 预分配</span></span><br><span class=\"line\">a = <span class=\"built_in\">sign</span>(<span class=\"built_in\">randn</span>(<span class=\"number\">1</span>, N));          <span class=\"comment\">% 基带信号</span></span><br><span class=\"line\">noise = <span class=\"built_in\">randn</span>(<span class=\"number\">1</span>, N);            <span class=\"comment\">% 标准噪声</span></span><br><span class=\"line\">sigma = <span class=\"built_in\">sqrt</span>(<span class=\"number\">1.</span>/EbN0/<span class=\"number\">2</span>);        <span class=\"comment\">% 噪声功率</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> n = <span class=\"number\">1</span>:<span class=\"built_in\">length</span>(EbN0dB)</span><br><span class=\"line\">    rk = a + sigma(n)*noise;    <span class=\"comment\">% 加噪声得到接收信号</span></span><br><span class=\"line\">    dec_a = <span class=\"built_in\">sign</span>(rk);           <span class=\"comment\">% 判决</span></span><br><span class=\"line\">    ber(n) = sum(<span class=\"built_in\">abs</span>(a-dec_a)/<span class=\"number\">2</span>)/<span class=\"built_in\">length</span>(a);</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">semilogy(EbN0dB, Pb, <span class=\"string\">'LineWidth'</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">hold on;</span><br><span class=\"line\">semilogy(EbN0dB, ber, <span class=\"string\">'rd'</span>);</span><br><span class=\"line\">legend(<span class=\"string\">'理论结果'</span>, <span class=\"string\">'仿真结果'</span>)</span><br><span class=\"line\">xlabel(<span class=\"string\">'\\itE_b/N_0\\rm(dB)'</span>); ylabel(<span class=\"string\">'Pb'</span>);</span><br><span class=\"line\">title(<span class=\"string\">'BPSK误码率仿真'</span>)</span><br><span class=\"line\">grid on</span><br></pre></td></tr></table></figure>\n<p>得到的结果如下所示：</p>\n<img src=\"/2020/05/ber-and-ser-of-PSK-and-QAM/BPSK.png\" title=\"BPSK 仿真结果\">\n<p>第二种方法更具有一般性，理解了它，其他调制方式也是一样的可以实现。这需要星座图的帮助，通过星座图，我们可以得到最小欧式距离和平均比特能量的关系。在 BPSK 中，有<br>$$<br>d_{min}=\\sqrt{4E_b}<br>$$</p>\n<p>同时，$\\frac{d_{min}}{2}$ 也正是信号的幅度，令 $d_{min}=2$，则信号的幅度为 $a=1$，由 $\\frac{E_b}{N_0}$ 和 $d_{min}$ 与 $E_b$ 的关系，我们可以得到<br>$$<br>N_0=\\frac{E_b}{E_b/N_0}=\\frac{d_{min}^2}{4}\\cdot\\frac{1}{E_b/N_0}<br>$$</p>\n<p>那么噪声功率就是$\\sigma^2=\\frac{N_0}{2}$。然后按照第一种方法的思路去编写仿真程序即可，非常简单。再来说说它的通用性，使用星座图仿真 AWGN 信道下的调制方式，我们首先需要确定最小欧式距离和平均比特能量的关系，然后得到噪声功率即可，这样就可以得到信号和噪声的定量关系，进行仿真即可。</p>\n<h2 id=\"QPSK\"><a href=\"#QPSK\" class=\"headerlink\" title=\"QPSK\"></a>QPSK</h2><p>利用上面提到的具有一般性的方式，我们需要使用星座图，QPSK有如下两种星座图形式：</p>\n<img src=\"/2020/05/ber-and-ser-of-PSK-and-QAM/QPSKConstellation.png\" title=\"QPSK 的两种星座图\">\n<p>以第一种左边的星座图为例，说明仿真过程。对于 MPSK 调制，最小欧式距离为：<br>$$<br>d_{min}=2\\sqrt{(log_2M\\times sin^2\\frac{\\pi}{M})\\varepsilon_b}<br>$$<br>在 QPSK 中，M=4，则 $d_{min}=2\\sqrt{\\varepsilon_b}$。注意到这和之前的 BPSK 不一样，我们可以将 QPSK 看作两路正交的相位调制叠加。仿真中我们令 $d_{min}=2$，则$\\varepsilon =1$，进而可以得到两路信号的幅度都是1，同时还可以确定噪声功率为 $\\sigma^2 = \\frac{1}{2SNR}$。按照上面的仿真思路我们很容易可以写出代码，最终得到的图形如下所示。</p>\n<h2 id=\"16QAM-和-16PSK\"><a href=\"#16QAM-和-16PSK\" class=\"headerlink\" title=\"16QAM 和 16PSK\"></a>16QAM 和 16PSK</h2><p>同理，对16QAM和16PSK也是一样的道理，只不过星座点映射在代码实现上会稍稍复杂一点。分析 16QAM 可以将它看作两路正交的 4PAM 信号的叠加，其余分析方法和上面完全相同。16PSK 就更加简单了，不多说，直接给出代码和最终的波形图，如下所示。</p>\n<img src=\"/2020/05/ber-and-ser-of-PSK-and-QAM/QAMandPSK.jpg\" title=\"16QAM和16PSK仿真结果\">\n<figure class=\"highlight matlab\"><figcaption><span>QAMandPSK.m</span><a href=\"/downloads/code/QAMandPSK.m\">view raw</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clear all;</span><br><span class=\"line\">close all;</span><br><span class=\"line\">clc;</span><br><span class=\"line\"></span><br><span class=\"line\">EbN0dB = <span class=\"number\">0</span>:<span class=\"number\">1</span>:<span class=\"number\">15</span>;</span><br><span class=\"line\">EbN0 = <span class=\"number\">10.</span>^(EbN0dB/<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">M = <span class=\"number\">16</span>; <span class=\"comment\">% 16 QAM</span></span><br><span class=\"line\">N = <span class=\"number\">64</span>; <span class=\"comment\">% 64 QAM</span></span><br><span class=\"line\"><span class=\"comment\">%% 16QAM 64QAM theory</span></span><br><span class=\"line\">Pe_16_help = <span class=\"number\">2</span>*(<span class=\"number\">1</span><span class=\"number\">-1</span>/<span class=\"built_in\">sqrt</span>(M))*qfunc(<span class=\"built_in\">sqrt</span>(<span class=\"number\">3</span>*<span class=\"built_in\">log2</span>(M)*EbN0/(M<span class=\"number\">-1</span>)));</span><br><span class=\"line\">Pe_16 = <span class=\"number\">1</span>- (<span class=\"number\">1</span> - Pe_16_help).^<span class=\"number\">2</span>;</span><br><span class=\"line\">Pb_16 = Pe_16 / <span class=\"number\">4</span>;</span><br><span class=\"line\">Pe_64_help = <span class=\"number\">2</span>*(<span class=\"number\">1</span><span class=\"number\">-1</span>/<span class=\"built_in\">sqrt</span>(N))*qfunc(<span class=\"built_in\">sqrt</span>(<span class=\"number\">3</span>*<span class=\"built_in\">log2</span>(N)*EbN0/(N<span class=\"number\">-1</span>)));</span><br><span class=\"line\">Pe_64 = <span class=\"number\">1</span>- (<span class=\"number\">1</span> - Pe_64_help).^<span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"comment\">%% 16PSK theory</span></span><br><span class=\"line\">Pe_theory_PSK = <span class=\"number\">2</span>*qfunc(<span class=\"built_in\">sin</span>(<span class=\"built_in\">pi</span>/M)*<span class=\"built_in\">sqrt</span>(<span class=\"number\">2</span>*<span class=\"built_in\">log2</span>(M)*EbN0));</span><br><span class=\"line\"><span class=\"comment\">%% theory plot</span></span><br><span class=\"line\">semilogy(EbN0dB, Pe_16, <span class=\"string\">'LineWidth'</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">hold on</span><br><span class=\"line\"><span class=\"comment\">% semilogy(EbN0dB, Pe_64)</span></span><br><span class=\"line\"><span class=\"comment\">% hold on</span></span><br><span class=\"line\">semilogy(EbN0dB, Pe_theory_PSK, <span class=\"string\">'k'</span>, <span class=\"string\">'LineWidth'</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">hold on</span><br><span class=\"line\">semilogy(EbN0dB, Pb_16, <span class=\"string\">'c'</span>, <span class=\"string\">'LineWidth'</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">hold on</span><br><span class=\"line\">semilogy(EbN0dB, Pe_theory_PSK / <span class=\"number\">4</span>, <span class=\"string\">'g'</span>, <span class=\"string\">'LineWidth'</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">grid on</span><br><span class=\"line\"></span><br><span class=\"line\">xlabel(<span class=\"string\">'\\it{E_b/N_0} \\rm(dB)'</span>)</span><br><span class=\"line\">ylabel(<span class=\"string\">'P_b and P_e'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 16QAM 仿真</span></span><br><span class=\"line\"><span class=\"comment\">% 格雷码映射表</span></span><br><span class=\"line\">gray_code_table = [<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span>; % <span class=\"number\">0</span></span><br><span class=\"line\">                  <span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span>;  % <span class=\"number\">1</span></span><br><span class=\"line\">                  <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">0</span>;  % <span class=\"number\">2</span></span><br><span class=\"line\">                  <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">0</span>;  % <span class=\"number\">3</span></span><br><span class=\"line\">                  <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">0</span>;  % <span class=\"number\">4</span></span><br><span class=\"line\">                  <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">0</span>;  % <span class=\"number\">5</span></span><br><span class=\"line\">                  <span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">0</span>;  % <span class=\"number\">6</span></span><br><span class=\"line\">                  <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">0</span>;  % <span class=\"number\">7</span></span><br><span class=\"line\">                  <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">1</span>;  % <span class=\"number\">8</span></span><br><span class=\"line\">                  <span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">1</span>;  % <span class=\"number\">9</span></span><br><span class=\"line\">                  <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">1</span>;  % <span class=\"number\">10</span></span><br><span class=\"line\">                  <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">1</span>;  % <span class=\"number\">11</span></span><br><span class=\"line\">                  <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">1</span>;  % <span class=\"number\">12</span></span><br><span class=\"line\">                  <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">1</span>;  % <span class=\"number\">13</span></span><br><span class=\"line\">                  <span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">1</span>;  % <span class=\"number\">14</span></span><br><span class=\"line\">                  <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">1</span>;];<span class=\"comment\">% 15</span></span><br><span class=\"line\"><span class=\"comment\">% 星座点位置表 16QAM</span></span><br><span class=\"line\">star_table_1 = [<span class=\"number\">-1</span>*(<span class=\"number\">-3</span>:<span class=\"number\">2</span>:<span class=\"number\">3</span>) (<span class=\"number\">-3</span>:<span class=\"number\">2</span>:<span class=\"number\">3</span>) <span class=\"number\">-1</span>*(<span class=\"number\">-3</span>:<span class=\"number\">2</span>:<span class=\"number\">3</span>) (<span class=\"number\">-3</span>:<span class=\"number\">2</span>:<span class=\"number\">3</span>)];</span><br><span class=\"line\">star_table_2 = [ones(<span class=\"number\">1</span>, <span class=\"number\">4</span>)*<span class=\"number\">3</span> ones(<span class=\"number\">1</span>, <span class=\"number\">4</span>) <span class=\"number\">-1</span>*ones(<span class=\"number\">1</span>,<span class=\"number\">4</span>) <span class=\"number\">-3</span>*ones(<span class=\"number\">1</span>,<span class=\"number\">4</span>)];</span><br><span class=\"line\">star_table = [star_table_1<span class=\"string\">' star_table_2'</span>];</span><br><span class=\"line\">star_table_T = star_table';</span><br><span class=\"line\">table_used = <span class=\"built_in\">reshape</span>(star_table_T, <span class=\"number\">1</span>, M*<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">% 星座点位置表 16PSK</span></span><br><span class=\"line\">phase = <span class=\"number\">0</span>:<span class=\"number\">2</span>*<span class=\"built_in\">pi</span>/M:(<span class=\"number\">2</span>*<span class=\"built_in\">pi</span><span class=\"number\">-2</span>*<span class=\"built_in\">pi</span>/M);</span><br><span class=\"line\">PSK16StarTable = [cos(phase);</span><br><span class=\"line\">                  sin(phase)];</span><br><span class=\"line\">PSK_table_used = <span class=\"built_in\">reshape</span>(PSK16StarTable, M*<span class=\"number\">2</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">% 基带信号</span></span><br><span class=\"line\">N = <span class=\"number\">4</span>*<span class=\"number\">10</span>^<span class=\"number\">4</span>; <span class=\"comment\">% bit数</span></span><br><span class=\"line\">base = (<span class=\"built_in\">sign</span>(<span class=\"built_in\">randn</span>(<span class=\"number\">1</span>, N)) + <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">mid_modul = <span class=\"built_in\">reshape</span>(base, [<span class=\"number\">4</span> N/<span class=\"number\">4</span>]);</span><br><span class=\"line\">mid_modul = mid_modul';</span><br><span class=\"line\"><span class=\"comment\">% 映射到星座点上 QAM 和 QPSK</span></span><br><span class=\"line\">modulSignalPosi = <span class=\"built_in\">zeros</span>(N/<span class=\"number\">4</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">PSK_modulSignalPosi = <span class=\"built_in\">zeros</span>(<span class=\"number\">2</span>, N/<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> symbol = <span class=\"number\">1</span>:N/<span class=\"number\">4</span></span><br><span class=\"line\">    dude = gray2int(mid_modul(symbol, :)) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    modulSignalPosi(symbol, :) = star_table(dude, :);</span><br><span class=\"line\">    PSK_modulSignalPosi(:, symbol) = PSK16StarTable(:, dude);</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"comment\">% 噪声</span></span><br><span class=\"line\">sigma = <span class=\"built_in\">sqrt</span>(<span class=\"number\">4</span>*(M<span class=\"number\">-1</span>)/<span class=\"number\">6</span>/<span class=\"built_in\">log2</span>(M)./EbN0/<span class=\"number\">2</span>);</span><br><span class=\"line\">PSK_sigma = <span class=\"built_in\">sqrt</span>(<span class=\"number\">1</span>/<span class=\"built_in\">log2</span>(M)./EbN0/<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">% 过信道 解调 求信噪比</span></span><br><span class=\"line\">be = <span class=\"built_in\">zeros</span>(<span class=\"number\">1</span>, <span class=\"built_in\">length</span>(EbN0dB));</span><br><span class=\"line\">se = <span class=\"built_in\">zeros</span>(<span class=\"number\">1</span>, <span class=\"built_in\">length</span>(EbN0dB));</span><br><span class=\"line\">PSK_be = <span class=\"built_in\">zeros</span>(<span class=\"number\">1</span>, <span class=\"built_in\">length</span>(EbN0dB));</span><br><span class=\"line\">PSK_se = <span class=\"built_in\">zeros</span>(<span class=\"number\">1</span>, <span class=\"built_in\">length</span>(EbN0dB));</span><br><span class=\"line\"><span class=\"keyword\">for</span> index = <span class=\"number\">1</span>:<span class=\"built_in\">length</span>(EbN0dB)</span><br><span class=\"line\">    <span class=\"comment\">% 加噪声</span></span><br><span class=\"line\">    reciPosi = modulSignalPosi + sigma(index) * <span class=\"built_in\">randn</span>(N/<span class=\"number\">4</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">% 最小距离解调 QAM</span></span><br><span class=\"line\">    distanceMid = <span class=\"built_in\">repmat</span>(reciPosi, [<span class=\"number\">1</span> M]) - <span class=\"built_in\">repmat</span>(table_used, N/<span class=\"number\">4</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    distanceMid = distanceMid.^<span class=\"number\">2</span>;</span><br><span class=\"line\">    distance = distanceMid(:, <span class=\"number\">1</span>:<span class=\"number\">2</span>:(M*<span class=\"number\">2</span><span class=\"number\">-1</span>)) + distanceMid(:, <span class=\"number\">2</span>:<span class=\"number\">2</span>:(M*<span class=\"number\">2</span>));</span><br><span class=\"line\">    distance = distance';</span><br><span class=\"line\">    <span class=\"comment\">% decodePosi 即为解调结果对应gray_code_table的位置</span></span><br><span class=\"line\">    [~, decodePosi] = min(distance);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">% 解调结果映射到基带 QAM</span></span><br><span class=\"line\">    toBaseGray = gray_code_table(decodePosi, :);</span><br><span class=\"line\">    toBaseSignal = <span class=\"built_in\">reshape</span>(toBaseGray', <span class=\"number\">1</span>, N);</span><br><span class=\"line\">    be(index) = sum(<span class=\"built_in\">abs</span>(base-toBaseSignal));</span><br><span class=\"line\">    se_posi = double(mid_modul ~= toBaseGray);</span><br><span class=\"line\">    se(index) = sum(<span class=\"built_in\">sign</span>(sum(se_posi, <span class=\"number\">2</span>)));</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">% PSK</span></span><br><span class=\"line\">    PSK_reciPosi = PSK_modulSignalPosi + PSK_sigma(index) * <span class=\"built_in\">randn</span>(<span class=\"number\">2</span>, N/<span class=\"number\">4</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    PSK_distanceMid = <span class=\"built_in\">repmat</span>(PSK_reciPosi, [M <span class=\"number\">1</span>]) - <span class=\"built_in\">repmat</span>(PSK_table_used, [<span class=\"number\">1</span> N/<span class=\"number\">4</span>]);</span><br><span class=\"line\">    PSK_distanceMid = PSK_distanceMid.^<span class=\"number\">2</span>;</span><br><span class=\"line\">    PSK_distance = PSK_distanceMid(<span class=\"number\">1</span>:<span class=\"number\">2</span>:(M*<span class=\"number\">2</span><span class=\"number\">-1</span>), :) + PSK_distanceMid(<span class=\"number\">2</span>:<span class=\"number\">2</span>:(M*<span class=\"number\">2</span>), :);</span><br><span class=\"line\">    [~, PSK_decodePosi] = min(PSK_distance);</span><br><span class=\"line\">    </span><br><span class=\"line\">    PSK_toBaseGray = gray_code_table(PSK_decodePosi, :);</span><br><span class=\"line\">    PSK_toBaseSignal = <span class=\"built_in\">reshape</span>(PSK_toBaseGray', <span class=\"number\">1</span>, N);</span><br><span class=\"line\">    PSK_be(index) = sum(<span class=\"built_in\">abs</span>(base-PSK_toBaseSignal));</span><br><span class=\"line\">    PSK_se_posi = double(mid_modul ~= PSK_toBaseGray);</span><br><span class=\"line\">    PSK_se(index) = sum(<span class=\"built_in\">sign</span>(sum(PSK_se_posi, <span class=\"number\">2</span>)));</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\">semilogy(EbN0dB, se/N*<span class=\"number\">4</span>, <span class=\"string\">'v'</span>, <span class=\"string\">'MarkerEdgeColor'</span>, <span class=\"string\">'r'</span>)</span><br><span class=\"line\">hold on</span><br><span class=\"line\">semilogy(EbN0dB, be/N, <span class=\"string\">'*'</span>, <span class=\"string\">'MarkerEdgeColor'</span>, <span class=\"string\">'r'</span>)</span><br><span class=\"line\">hold on</span><br><span class=\"line\">semilogy(EbN0dB, PSK_se/N*<span class=\"number\">4</span>, <span class=\"string\">'^'</span>, <span class=\"string\">'MarkerEdgeColor'</span>, <span class=\"string\">'m'</span>)</span><br><span class=\"line\">hold on</span><br><span class=\"line\">semilogy(EbN0dB, PSK_be/N, <span class=\"string\">'*'</span>, <span class=\"string\">'MarkerEdgeColor'</span>, <span class=\"string\">'m'</span>)</span><br><span class=\"line\">legend(<span class=\"string\">'16QAM理论误码率'</span>, <span class=\"string\">'16PSK理论误码率'</span>, <span class=\"string\">'16QAM理论误比特率'</span>,  <span class=\"string\">'16PSK理论误比特率'</span>, ...</span><br><span class=\"line\">    <span class=\"string\">'16QAM仿真误码率'</span>, <span class=\"string\">'16QAM仿真误比特率'</span>, <span class=\"string\">'16PSK仿真误码率'</span>, <span class=\"string\">'16PSK仿真误比特率'</span>)</span><br><span class=\"line\">title(<span class=\"string\">'16QAM and 16PSK'</span>)</span><br></pre></td></tr></table></figure>","tags":[{"name":"MATLAB","slug":"MATLAB","permalink":"https://jonathan1214.github.io/tags/MATLAB/"},{"name":"通信","slug":"通信","permalink":"https://jonathan1214.github.io/tags/通信/"}]},{"title":"LeetCode | 61 旋转链表","date":"2020-05-09T08:09:36.000Z","path":"2020/05/rotate-LinkedList-rightly/","text":"题目给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。 示例 输入：1-&gt;2-&gt;3-&gt;4-&gt;5，k=2 输出：4-&gt;5-&gt;1-&gt;2-&gt;3 题解题目名字叫旋转链表，其实就是循环移动。最简单的思路是：遍历链表找到尾节点的前一节点，然后把尾节点从头插入链表，对这个过程执行 k 次即可。这样做算法的时间复杂度为 O(kn)。考虑到是循环移动，我们可以对算法进行改进。 首先考虑 k 小于链表长度的情况，链表循环向右移动 k 次，不就相当于把链表练成环，然后尾节点位置向左移动 k 次吗？下面这个图展示了这个过程。 对于 k 大于链表长度的情况，先构成环，沿着环一直移动就行。这种方法的问题在于我们需要逆向移动单链表的指针，即每次需要找到单链表前驱的前驱，这是很难做到的，但我们可以先行将单链表进行逆序，然后移动指针，确定最终的头尾节点后再把链表逆序回来即可。 更进一步的，在环中逆序移动指针 k 次，就相当于顺序移动指针 n-k 次，其中 n 是链表的长度。基于这种想法，我们再加以改进，得到下面的解法。 先把指针 p 从头向后移动到尾，直到循环移动的次数 k==0。在此过程中，如果 p 指向了空节点，说明到了链表尾部，k 大于链表的长度，这时候我们可以利用循环的特点，对链表的长度减一值进行取模运算，得到的值是我们需要再移动到位置。然后按照上述的方法进行指针移动即可。最终代码如下所示。 LeetCodeSolution61.cview raw1234567891011121314151617181920212223242526272829303132333435ListNode *rotateRight(ListNode *head, int k){ if (head == NULL || k &lt;= 0) return head; ListNode *pre, *last, *p; ListNode tmpNode; tmpNode.next = head; last = &amp;tmpNode; p = head; int ak = k; while (k &gt; 0){ // 滑动指针来代替循环 if (p == NULL) { int tmp = ak - k; pre = &amp;tmpNode; p = head; k = ak % tmp; if (k == 0) break; } pre = p; p = p-&gt;next; k--; } while (p != NULL) { last = last-&gt;next; pre = p; p = p-&gt;next; } if (last != &amp;tmpNode) { pre-&gt;next = head; tmpNode.next = last-&gt;next; last-&gt;next = NULL; } return tmpNode.next;}","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><ul>\n<li>输入：<code>1-&gt;2-&gt;3-&gt;4-&gt;5</code>，<code>k=2</code></li>\n<li>输出：<code>4-&gt;5-&gt;1-&gt;2-&gt;3</code></li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>题目名字叫旋转链表，其实就是循环移动。最简单的思路是：遍历链表找到尾节点的前一节点，然后把尾节点从头插入链表，对这个过程执行 k 次即可。这样做算法的时间复杂度为 <code>O(kn)</code>。考虑到是循环移动，我们可以对算法进行改进。</p>\n<p>首先考虑 <code>k</code> 小于链表长度的情况，链表循环向右移动 <code>k</code> 次，不就相当于把链表练成环，然后尾节点位置向左移动 <code>k</code> 次吗？下面这个图展示了这个过程。</p>\n<img src=\"/2020/05/rotate-LinkedList-rightly/illustration.png\" title=\"循环移动\">\n<p>对于 <code>k</code> 大于链表长度的情况，先构成环，沿着环一直移动就行。这种方法的问题在于我们需要逆向移动单链表的指针，即每次需要找到单链表前驱的前驱，这是很难做到的，但我们可以先行将单链表进行逆序，然后移动指针，确定最终的头尾节点后再把链表逆序回来即可。</p>\n<p>更进一步的，在环中逆序移动指针 <code>k</code> 次，就相当于顺序移动指针 <code>n-k</code> 次，其中 <code>n</code> 是链表的长度。基于这种想法，我们再加以改进，得到下面的解法。</p>\n<p>先把指针 <code>p</code> 从头向后移动到尾，直到循环移动的次数 <code>k==0</code>。在此过程中，如果 <code>p</code> 指向了空节点，说明到了链表尾部，<code>k</code> 大于链表的长度，这时候我们可以利用循环的特点，对链表的长度减一值进行取模运算，得到的值是我们需要再移动到位置。然后按照上述的方法进行指针移动即可。最终代码如下所示。</p>\n<figure class=\"highlight c\"><figcaption><span>LeetCodeSolution61.c</span><a href=\"/downloads/code/LeetCodeSolution61.c\">view raw</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode *<span class=\"title\">rotateRight</span><span class=\"params\">(ListNode *head, <span class=\"keyword\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"literal\">NULL</span> || k &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    ListNode *pre, *last, *p;</span><br><span class=\"line\">    ListNode tmpNode;</span><br><span class=\"line\">    tmpNode.next = head;</span><br><span class=\"line\">    last = &amp;tmpNode;</span><br><span class=\"line\">    p = head;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ak = k;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (k &gt; <span class=\"number\">0</span>){</span><br><span class=\"line\">        <span class=\"comment\">// 滑动指针来代替循环</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = ak - k;</span><br><span class=\"line\">            pre = &amp;tmpNode;</span><br><span class=\"line\">            p = head;</span><br><span class=\"line\">            k = ak % tmp;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (k == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        pre = p;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">        k--;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p != <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        last = last-&gt;next;</span><br><span class=\"line\">        pre = p;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (last != &amp;tmpNode) {</span><br><span class=\"line\">        pre-&gt;next = head;</span><br><span class=\"line\">        tmpNode.next = last-&gt;next;</span><br><span class=\"line\">        last-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmpNode.next;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n","tags":[{"name":"算法","slug":"算法","permalink":"https://jonathan1214.github.io/tags/算法/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://jonathan1214.github.io/tags/LeetCode/"}]},{"title":"LeetCode | 2 两数相加","date":"2020-05-08T05:33:25.000Z","path":"2020/05/add-two-numbers/","text":"题目给定两个非空链表表示两个非负整数，位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加并返回一个新的链表。 可以假设除了数字 0 之外，这两个数字都不会以 0 开头。 示例 输入：(2-&gt;4-&gt;3) + (5-&gt;6-&gt;4) 输出：7-&gt;0-&gt;8 原因：342 + 465 = 807 题解这是一道链表题，我们对单链表的节点定义如下： 1234typedef struct NODE&#123; int val; struct NODE *next;&#125; ListNode; 链表是逆序表示数字的，这对我们执行加法操作非常有利，因为在进行加法运算时，我们习惯从低位开始执行，并向高位进行进位。事实上如果它是顺序表示数字的话，我们也该想到将它进行逆序。 正确完成算法的关键在于把进位考虑进去，而且需要注意到在单链表中执行插入操作时，最快的插入位置是从表头插入，但是这样插入我们得到的结果是顺序的，之后再反转单链表即可。 以示例中的例子为例，来看看算法的执行过程。初始化进位值 carry 和待保留值 tmp，两个指针 p1 和 p2 分别指向两个链表的头部，对应的值为 2 和 5；2 + 5 = 7，故 tmp = 7，carry = 0，将 7 插入结果链表得到 7；指针分别向后移动；4 + 6 = 10，故 tmp = 0，carry = 1，将结果 0 插入链表得到 0-&gt;7；指针分别向后移动；3+4+carry=8，故 tmp=8，carry=0，将结果插入链表得到 8-&gt;0-&gt;7；然后对结果链表进行反转得到最终的结果 7-&gt;0-&gt;8。 上述的是一个典型的执行过程，实际上还有一些其他情况需要考虑，如输入两个链表的长度并不一样，计算完时 carry 不为 0。对于前者，我们在上述环节之外在添加两个处理过程即可，如第 17 行和 26 行所示。对于后者，我们只需在反转链表前加一个判断，当进位值不为 0 时，在结果链表的头部插入一个节点即可，如 36 行所示。 最终我们得到的代码如下所示，算法的时间复杂度为 O(m+n)。 LeetCodeSolution2.cview raw123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354ListNode *addTwoNumbers(ListNode *num1, ListNode *num2){ ListNode *theSum, *p = NULL; int tmp = 0; // 保存值 int carry = 0; // 进位 while (num1 &amp;&amp; num2) { tmp = (num1-&gt;val + num2-&gt;val + carry) % 10; carry = (num1-&gt;val + num2-&gt;val + carry) / 10; theSum = (ListNode *)malloc(sizeof(ListNode)); theSum-&gt;val = tmp; theSum-&gt;next = p; p = theSum; num1 = num1-&gt;next; num2 = num2-&gt;next; } // 链表长度不同 while (num1) { tmp = (num1-&gt;val + carry) % 10; carry = (num1-&gt;val + carry) / 10; theSum = (ListNode *)malloc(sizeof(ListNode)); theSum-&gt;val = tmp; theSum-&gt;next = p; p = theSum; num1 = num1-&gt;next; } while (num2) { tmp = (num2-&gt;val + carry) % 10; carry = (num2-&gt;val + carry) / 10; theSum = (ListNode *)malloc(sizeof(ListNode)); theSum-&gt;val = tmp; theSum-&gt;next = p; p = theSum; num2 = num2-&gt;next; } // 最后进位值不为 0 if (carry) { theSum = (ListNode *)malloc(sizeof(ListNode)); theSum-&gt;val = carry; theSum-&gt;next = p; } theSum = reverseLinkedList(theSum);}// 反转链表ListNode *reverseLinkedList(ListNode *head){ ListNode *p = NULL, *q; while (head) { q = head-&gt;next; head-&gt;next = p; p = head; head = q; } return p;}","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定两个非空链表表示两个非负整数，位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加并返回一个新的链表。</p>\n<p>可以假设除了数字 0  之外，这两个数字都不会以 0 开头。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><ul>\n<li>输入：(2-&gt;4-&gt;3) + (5-&gt;6-&gt;4)</li>\n<li>输出：7-&gt;0-&gt;8</li>\n<li>原因：342 + 465 = 807<a id=\"more\"></a></li>\n</ul>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>这是一道链表题，我们对单链表的节点定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">NODE</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">NODE</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125; ListNode;</span><br></pre></td></tr></table></figure>\n<p>链表是逆序表示数字的，这对我们执行加法操作非常有利，因为在进行加法运算时，我们习惯从低位开始执行，并向高位进行进位。事实上如果<span style=\"color:red\">它是顺序表示数字的话，我们也该想到将它进行逆序</span>。</p>\n<p>正确完成算法的关键在于把进位考虑进去，而且需要注意到在单链表中执行插入操作时，最快的插入位置是从表头插入，但是这样插入我们得到的结果是顺序的，之后再反转单链表即可。</p>\n<p>以<a href=\"#示例\">示例</a>中的例子为例，来看看算法的执行过程。初始化进位值 <code>carry</code> 和待保留值 <code>tmp</code>，两个指针 <code>p1</code> 和 <code>p2</code> 分别指向两个链表的头部，对应的值为 2 和 5；<code>2 + 5 = 7</code>，故 <code>tmp = 7</code>，<code>carry = 0</code>，将 7 插入结果链表得到 <code>7</code>；指针分别向后移动；<code>4 + 6 = 10</code>，故 <code>tmp = 0</code>，<code>carry = 1</code>，将结果 0 插入链表得到 <code>0-&gt;7</code>；指针分别向后移动；<code>3+4+carry=8</code>，故 <code>tmp=8</code>，<code>carry=0</code>，将结果插入链表得到 <code>8-&gt;0-&gt;7</code>；然后对结果链表进行反转得到最终的结果 <code>7-&gt;0-&gt;8</code>。</p>\n<p>上述的是一个典型的执行过程，实际上还有一些其他情况需要考虑，如输入两个链表的长度并不一样，计算完时 <code>carry</code> 不为 0。对于前者，我们在上述环节之外在添加两个处理过程即可，如第 17 行和 26 行所示。对于后者，我们只需在反转链表前加一个判断，当进位值不为 0 时，在结果链表的头部插入一个节点即可，如 36 行所示。</p>\n<p>最终我们得到的代码如下所示，算法的时间复杂度为 <code>O(m+n)</code>。</p>\n<figure class=\"highlight c\"><figcaption><span>LeetCodeSolution2.c</span><a href=\"/downloads/code/LeetCodeSolution2.c\">view raw</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode *<span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode *num1, ListNode *num2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    ListNode *theSum, *p = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmp = <span class=\"number\">0</span>;   <span class=\"comment\">// 保存值</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> carry = <span class=\"number\">0</span>; <span class=\"comment\">// 进位</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (num1 &amp;&amp; num2) {</span><br><span class=\"line\">        tmp = (num1-&gt;val + num2-&gt;val + carry) % <span class=\"number\">10</span>;</span><br><span class=\"line\">        carry = (num1-&gt;val + num2-&gt;val + carry) / <span class=\"number\">10</span>;</span><br><span class=\"line\">        theSum = (ListNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(ListNode));</span><br><span class=\"line\">        theSum-&gt;val = tmp;</span><br><span class=\"line\">        theSum-&gt;next = p;</span><br><span class=\"line\">        p = theSum;</span><br><span class=\"line\">        num1 = num1-&gt;next;</span><br><span class=\"line\">        num2 = num2-&gt;next;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// 链表长度不同</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (num1) {</span><br><span class=\"line\">        tmp = (num1-&gt;val + carry) % <span class=\"number\">10</span>;</span><br><span class=\"line\">        carry = (num1-&gt;val + carry) / <span class=\"number\">10</span>;</span><br><span class=\"line\">        theSum = (ListNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(ListNode));</span><br><span class=\"line\">        theSum-&gt;val = tmp;</span><br><span class=\"line\">        theSum-&gt;next = p;</span><br><span class=\"line\">        p = theSum;</span><br><span class=\"line\">        num1 = num1-&gt;next;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (num2) {</span><br><span class=\"line\">        tmp = (num2-&gt;val + carry) % <span class=\"number\">10</span>;</span><br><span class=\"line\">        carry = (num2-&gt;val + carry) / <span class=\"number\">10</span>;</span><br><span class=\"line\">        theSum = (ListNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(ListNode));</span><br><span class=\"line\">        theSum-&gt;val = tmp;</span><br><span class=\"line\">        theSum-&gt;next = p;</span><br><span class=\"line\">        p = theSum;</span><br><span class=\"line\">        num2 = num2-&gt;next;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// 最后进位值不为 0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (carry) {</span><br><span class=\"line\">        theSum = (ListNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(ListNode));</span><br><span class=\"line\">        theSum-&gt;val = carry;</span><br><span class=\"line\">        theSum-&gt;next = p;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    theSum = reverseLinkedList(theSum);</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// 反转链表</span></span><br><span class=\"line\"><span class=\"function\">ListNode *<span class=\"title\">reverseLinkedList</span><span class=\"params\">(ListNode *head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    ListNode *p = <span class=\"literal\">NULL</span>, *q;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (head) {</span><br><span class=\"line\">        q = head-&gt;next;</span><br><span class=\"line\">        head-&gt;next = p;</span><br><span class=\"line\">        p = head;</span><br><span class=\"line\">        head = q;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>","tags":[{"name":"算法","slug":"算法","permalink":"https://jonathan1214.github.io/tags/算法/"},{"name":"链表","slug":"链表","permalink":"https://jonathan1214.github.io/tags/链表/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://jonathan1214.github.io/tags/LeetCode/"}]},{"title":"LeetCode | 11 盛最多水的容器","date":"2020-05-07T06:36:57.000Z","path":"2020/05/max-area/","text":"题目给定 n 个非负整数 a1, a2, ..., an，每个数代表坐标中的一个点 (i, ai)。画 n 条垂直线，使得垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 注意：不能倾斜容器，n 至少是 2。 题解如果使用暴力算法，那么时间复杂度为 $O(n^2)$。如果使用双指针法，那么时间复杂度降为 $O(n)$。如下所示。 初始化两个指针 first 和 last 分别指向数组头和尾； 当 last 指向的值较小时，计算一个面积，并决定是否保留，然后 last-- ； 当 first 指向的值较小时，计算一个面积，并决定是否保留，然后 first++； 从第 2 步重新执行，直到 first == last，返回最大值。 1234567891011121314151617int maxArea(int *height, int heightSize)&#123; int res = 0, aux = 0; int first = 0, last = heightSize - 1; while (first &lt; last) &#123; if (height[first] &lt; height[last]) &#123; aux = height[first] * (last - first); res = aux &gt; res ? aux : res; first++; &#125; else &#123; aux = height[last] * (last - first); res = aux &gt; res ? aux : res; last--; &#125; &#125; return res;&#125; 我们还可以对上面的算法进行一些改进。在上面的算法中，我们每次将指针挪动一个位置（向左或向右），然后计算面积并进行比较。这个面积的计算是否每次都有必要呢？其实并不必要，每次挪动指针后，所求区域的长度都会减小，只有区域的宽度增加我们才有重新计算面积的必要，即指针新指向的值大于它原来指向的值，我们才需要再次计算面积。基于此，我们可以对算法进行改进，如下所示。 LeetCodeSolution11.cview raw12345678910111213141516171819int maxArea(int *height, int heightSize){ int res = 0, aux = 0; int first = 0, last = heightSize - 1; while (first &lt; last) { aux = (last - first) * (height[first] &lt; height[last] ? height[first] : height[last]); res = aux &gt; res ? aux : res; if (height[first] &lt; height[last]) while (++first &lt; max &amp;&amp; height[min] &lt;= height[min-1]) // 新指针指向的值不大于原来的值 继续减小指针即可 continue; else while (--last &gt; first &amp;&amp; height[last] &lt;= height[last+1]) // 新指针指向的值不大于原来的值 继续减小指针即可 continue; } return res;}","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定 <code>n</code> 个非负整数 <code>a1, a2, ..., an</code>，每个数代表坐标中的一个点 <code>(i, ai)</code>。画 <code>n</code> 条垂直线，使得垂直线 <code>i</code> 的两个端点分别为 <code>(i, ai)</code> 和 <code>(i, 0)</code>。找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p>\n<p>注意：不能倾斜容器，<code>n</code> 至少是 2。<br><a id=\"more\"></a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>如果使用暴力算法，那么时间复杂度为 $O(n^2)$。如果使用双指针法，那么时间复杂度降为 $O(n)$。如下所示。</p>\n<ol>\n<li>初始化两个指针 <code>first</code> 和 <code>last</code> 分别指向数组头和尾；</li>\n<li>当 <code>last</code> 指向的值较小时，计算一个面积，并决定是否保留，然后 <code>last--</code> ；</li>\n<li>当 <code>first</code> 指向的值较小时，计算一个面积，并决定是否保留，然后 <code>first++</code>；</li>\n<li>从第 2 步重新执行，直到 <code>first == last</code>，返回最大值。</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxArea</span><span class=\"params\">(<span class=\"keyword\">int</span> *height, <span class=\"keyword\">int</span> heightSize)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>, aux = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> first = <span class=\"number\">0</span>, last = heightSize - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (first &lt; last) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (height[first] &lt; height[last]) &#123;</span><br><span class=\"line\">            aux = height[first] * (last - first);</span><br><span class=\"line\">            res = aux &gt; res ? aux : res;</span><br><span class=\"line\">            first++;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            aux = height[last] * (last - first);</span><br><span class=\"line\">            res = aux &gt; res ? aux : res;</span><br><span class=\"line\">            last--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们还可以对上面的算法进行一些改进。在上面的算法中，我们每次将指针挪动一个位置（向左或向右），然后计算面积并进行比较。这个面积的计算是否每次都有必要呢？其实并不必要，每次挪动指针后，所求区域的长度都会减小，只有<strong>区域的宽度增加我们才有重新计算面积的必要</strong>，即指针新指向的值大于它原来指向的值，我们才需要再次计算面积。基于此，我们可以对算法进行改进，如下所示。</p>\n<figure class=\"highlight c\"><figcaption><span>LeetCodeSolution11.c</span><a href=\"/downloads/code/LeetCodeSolution11.c\">view raw</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxArea</span><span class=\"params\">(<span class=\"keyword\">int</span> *height, <span class=\"keyword\">int</span> heightSize)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>, aux = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> first = <span class=\"number\">0</span>, last = heightSize - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (first &lt; last) {</span><br><span class=\"line\">        aux = (last - first) * </span><br><span class=\"line\">            (height[first] &lt; height[last] ? height[first] : height[last]);</span><br><span class=\"line\">        res = aux &gt; res ? aux : res;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (height[first] &lt; height[last])</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (++first &lt; max &amp;&amp; height[min] &lt;= height[min<span class=\"number\">-1</span>])</span><br><span class=\"line\">                <span class=\"comment\">// 新指针指向的值不大于原来的值 继续减小指针即可</span></span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (--last &gt; first &amp;&amp; height[last] &lt;= height[last+<span class=\"number\">1</span>])</span><br><span class=\"line\">                <span class=\"comment\">// 新指针指向的值不大于原来的值 继续减小指针即可</span></span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>","tags":[{"name":"算法","slug":"算法","permalink":"https://jonathan1214.github.io/tags/算法/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://jonathan1214.github.io/tags/LeetCode/"}]},{"title":"LeetCode | 4 两个排序数组的中位数","date":"2020-05-06T10:01:40.000Z","path":"2020/05/find-median-sorted-arrays/","text":"题目给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。找出这两个有序数组的中位数。要求算法的时间复杂度为O(log(m+n))。 示例 nums1 = [1, 3]，nums2 = [2]，中位数是 2.0； nums1 = [1, 2]，nums2 = [3, 4]，中位数是 2.5； 题解整体上是一个分而治之的思想，将问题分解，使用递归可以很方便的完成。这个问题是『寻找两个有序数组中的第 k 大元素』问题的特殊形式，我们直接实现寻址第 k 大元素的函数 find_kth() 即可，然后在 findMedianSortedArrays() 中调用它即可。 我们使用递归方式实现 find_kth()，对于递归算法，我们要注意递归终止条件。首先要确保第一个参数数组的长度是较短的， 较短数组 a 的长度（未搜索区域长度）变为 0，返回 b 中第 k 个元素； 待寻找的序数 k = 1，返回a 和 b 的第一个元素中的较小者。 然后我们需要确定每个数组的搜索长度。对于较小数组 a，搜索长度为数组长和 k/2 的较大者，余下的长度则为数组 b 待搜索的长度。 代码如下： LeetCodeSolution4.cview raw123456789101112131415161718192021222324252627282930313233// 辅助函数 选择两个有序数组中第 k 大的数int find_kth(int *a, int alen, int *b, int blen, int k){ // 确保 alen &lt; blen if (alen &gt; blen) return find_kth(b, blen, a, alen, k); if (alen == 0) return b[k-1]; if (k == 1) return a[0] &lt; b[0] ? a[0] : b[0]; int ia = alen &gt; k/2 ? k/2 : alen; int ib = k - ia; if (b[ib-1] &gt; a[ia-1]) return find_kth(a+ia, alen-ia, b, blen, k-ia); else if (b[ib-1] &lt; a[ia-1]) return find_kth(a, alen, b+ib, blen-ib, k-ib); else // 注意这种情况 return a[ia-1];}// 找出两个有序数组中的中位数double findMedianSortedArrays(int *nums1, int nums1Size, int *nums2, int nums2Size){ int mid = nums2Size + (nums1Size - nums2Size) / 2; // if ((nums1Size &amp; 0x1) ^ (nums2Size &amp; 0x1)) // 和为奇数 if ((nums1Size+nums2Size) &amp; 0x1) return find_kth(nums1, nums1Size, nums2, nums2Size, mid+1); else // 和为偶数 return (find_kth(nums1, nums1Size, nums2, nums2Size, mid) + find_kth(nums1, nums1Size, nums2, nums2Size, mid+1)) / 2.0;}","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定两个大小为 <code>m</code> 和 <code>n</code> 的有序数组 <code>nums1</code> 和 <code>nums2</code>。找出这两个有序数组的中位数。要求算法的时间复杂度为<code>O(log(m+n))</code>。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><ul>\n<li><code>nums1 = [1, 3]</code>，<code>nums2 = [2]</code>，中位数是 2.0；</li>\n<li><code>nums1 = [1, 2]</code>，<code>nums2 = [3, 4]</code>，中位数是 2.5；<a id=\"more\"></a>\n</li>\n</ul>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>整体上是一个分而治之的思想，将问题分解，使用递归可以很方便的完成。这个问题是『寻找两个有序数组中的第 k 大元素』问题的特殊形式，我们直接实现寻址第 k 大元素的函数  <code>find_kth()</code> 即可，然后在 <code>findMedianSortedArrays()</code> 中调用它即可。</p>\n<p>我们使用递归方式实现 <code>find_kth()</code>，对于递归算法，我们要注意递归终止条件。首先要确保第一个参数数组的长度是较短的，</p>\n<ul>\n<li>较短数组 <code>a</code> 的长度（未搜索区域长度）变为 0，返回 <code>b</code> 中第 <code>k</code> 个元素；</li>\n<li>待寻找的序数 <code>k = 1</code>，返回<code>a</code> 和 <code>b</code> 的第一个元素中的较小者。</li>\n</ul>\n<p>然后我们需要确定每个数组的搜索长度。对于较小数组 <code>a</code>，搜索长度为数组长和 <code>k/2</code> 的较大者，余下的长度则为数组 <code>b</code> 待搜索的长度。</p>\n<p>代码如下：</p>\n<figure class=\"highlight c\"><figcaption><span>LeetCodeSolution4.c</span><a href=\"/downloads/code/LeetCodeSolution4.c\">view raw</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 辅助函数 选择两个有序数组中第 k 大的数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find_kth</span><span class=\"params\">(<span class=\"keyword\">int</span> *a, <span class=\"keyword\">int</span> alen, <span class=\"keyword\">int</span> *b, <span class=\"keyword\">int</span> blen, <span class=\"keyword\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"comment\">// 确保 alen &lt; blen</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (alen &gt; blen)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> find_kth(b, blen, a, alen, k);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (alen == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> b[k<span class=\"number\">-1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k == <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a[<span class=\"number\">0</span>] &lt; b[<span class=\"number\">0</span>] ? a[<span class=\"number\">0</span>] : b[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ia = alen &gt; k/<span class=\"number\">2</span> ? k/<span class=\"number\">2</span> : alen;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ib = k - ia;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (b[ib<span class=\"number\">-1</span>] &gt; a[ia<span class=\"number\">-1</span>])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> find_kth(a+ia, alen-ia, b, blen, k-ia);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (b[ib<span class=\"number\">-1</span>] &lt; a[ia<span class=\"number\">-1</span>])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> find_kth(a, alen, b+ib, blen-ib, k-ib);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"comment\">// 注意这种情况</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> a[ia<span class=\"number\">-1</span>];</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// 找出两个有序数组中的中位数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">findMedianSortedArrays</span><span class=\"params\">(<span class=\"keyword\">int</span> *nums1, <span class=\"keyword\">int</span> nums1Size,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                        <span class=\"keyword\">int</span> *nums2, <span class=\"keyword\">int</span> nums2Size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = nums2Size + (nums1Size - nums2Size) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"comment\">// if ((nums1Size &amp; 0x1) ^ (nums2Size &amp; 0x1)) // 和为奇数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((nums1Size+nums2Size) &amp; <span class=\"number\">0x1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> find_kth(nums1, nums1Size, nums2, nums2Size, mid+<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span>    <span class=\"comment\">// 和为偶数</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (find_kth(nums1, nums1Size, nums2, nums2Size, mid)</span><br><span class=\"line\">                    + find_kth(nums1, nums1Size, nums2, nums2Size, mid+<span class=\"number\">1</span>)) / <span class=\"number\">2.0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>","tags":[{"name":"算法","slug":"算法","permalink":"https://jonathan1214.github.io/tags/算法/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://jonathan1214.github.io/tags/LeetCode/"}]},{"title":"LeetCode | 24 两两交换链表中的节点","date":"2020-05-05T12:25:38.000Z","path":"2020/05/swap-pairs-in-LinkdedList/","text":"题目给定一个单链表，两两交换其中相邻的节点，并返回交换后的链表。 示例给定 1-&gt;2-&gt;3-&gt;4，返回 2-&gt;1-&gt;4-&gt;3。 说明： 算法只能使用常数的额外空间； 不能只是单纯的交换节点内部的值，而是需要实际的进行节点交换。 题解这个题目非常并不难，简单叙述下思路如下： 链表为空或只有一个节点时时直接返回头节点； p1 指向第一个节点，p2 指向第二个节点，进行交换；交换之后 p2 成为头节点，更新头节点；p1 指向第二个节点； 现在 p1 成为第二个 pair 的头节点； 当 p1-&gt;next和 p1-&gt;next-&gt;next 不为空时执行： 交换 p1-&gt;next和 p1-&gt;next-&gt;next p1 = p1-&gt;next-&gt;next 代码如下： LeetCodeSolution24.cview raw1234567891011121314151617181920212223242526272829303132// 链表节点定义typedef struct ListNode{ int val; struct ListNode *next;} ListNode;ListNode *swapPairs(ListNode *head){ if (head == NULL || head-&gt;next == NULL) return head; ListNode *p1, *p2; p1 = head; p2 = p1-&gt;next; // 第一次交换 p1-&gt;next = p2-&gt;next; p2-&gt;next = p1; head = p2; // 其他 while (p1-&gt;next &amp;&amp; p1-&gt;next-&gt;next) { exch(p1, p1-&gt;next); p1 = p1-&gt;next-&gt;next; } return head;}void exch(ListNode *p1, ListNode *p2){ p1-&gt;next = p2-&gt;next; p2-&gt;next = p2-&gt;next-&gt;next; p1-&gt;next-&gt;next = p2;}","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个单链表，两两交换其中相邻的节点，并返回交换后的链表。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>给定 <code>1-&gt;2-&gt;3-&gt;4</code>，返回 <code>2-&gt;1-&gt;4-&gt;3</code>。<a id=\"more\"></a></p>\n<p>说明：</p>\n<ul>\n<li>算法只能使用常数的额外空间；</li>\n<li>不能只是单纯的交换节点内部的值，而是需要实际的进行节点交换。</li>\n</ul>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>这个题目非常并不难，简单叙述下思路如下：</p>\n<ol>\n<li>链表为空或只有一个节点时时直接返回头节点；</li>\n<li><code>p1</code> 指向第一个节点，<code>p2</code> 指向第二个节点，进行交换；交换之后 <code>p2</code> 成为头节点，更新头节点；<code>p1</code> 指向第二个节点；</li>\n<li>现在 <code>p1</code> 成为第二个 <code>pair</code> 的头节点；</li>\n<li>当 <code>p1-&gt;next</code>和 <code>p1-&gt;next-&gt;next</code> 不为空时执行：<ul>\n<li>交换 <code>p1-&gt;next</code>和 <code>p1-&gt;next-&gt;next</code></li>\n<li><code>p1 = p1-&gt;next-&gt;next</code></li>\n</ul>\n</li>\n</ol>\n<p>代码如下：</p>\n<figure class=\"highlight c\"><figcaption><span>LeetCodeSolution24.c</span><a href=\"/downloads/code/LeetCodeSolution24.c\">view raw</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 链表节点定义</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>{</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">} ListNode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ListNode *<span class=\"title\">swapPairs</span><span class=\"params\">(ListNode *head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"literal\">NULL</span> || head-&gt;next == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    ListNode *p1, *p2;</span><br><span class=\"line\">    p1 = head;</span><br><span class=\"line\">    p2 = p1-&gt;next;</span><br><span class=\"line\">    <span class=\"comment\">// 第一次交换</span></span><br><span class=\"line\">    p1-&gt;next = p2-&gt;next;</span><br><span class=\"line\">    p2-&gt;next = p1;</span><br><span class=\"line\">    head = p2;</span><br><span class=\"line\">    <span class=\"comment\">// 其他</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p1-&gt;next &amp;&amp; p1-&gt;next-&gt;next)</span><br><span class=\"line\">    {</span><br><span class=\"line\">        exch(p1, p1-&gt;next);</span><br><span class=\"line\">        p1 = p1-&gt;next-&gt;next;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">exch</span><span class=\"params\">(ListNode *p1, ListNode *p2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    p1-&gt;next = p2-&gt;next;</span><br><span class=\"line\">    p2-&gt;next = p2-&gt;next-&gt;next;</span><br><span class=\"line\">    p1-&gt;next-&gt;next = p2;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>","tags":[{"name":"算法","slug":"算法","permalink":"https://jonathan1214.github.io/tags/算法/"},{"name":"C/C++","slug":"C-C","permalink":"https://jonathan1214.github.io/tags/C-C/"},{"name":"链表","slug":"链表","permalink":"https://jonathan1214.github.io/tags/链表/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://jonathan1214.github.io/tags/LeetCode/"}]},{"title":"LeetCode | 19 删除链表的倒数第N个节点","date":"2020-05-04T10:27:01.000Z","path":"2020/05/delete-numN-node-at-reverse-order-in-list/","text":"题目给定一个链表，删除链表的倒数第 n 个节点，并返回链表的头结点。 示例给定一个链表：1-&gt;2&gt;3-&gt;4-&gt;5，和 n=2。当删除倒数第二个节点后，链表变为 1-&gt;2&gt;3-&gt;5。 说明给定的 n 保证是有效的。 解题这个题使用双指针即可很快解决： 初始化两个指针 p1 和 p2 均指向链表的头部 p2 不动，p1 指针向后滑动 n 个位置 p1 和 p2 一起向后滑动，当 p1 指向节点的下一个节点为空时，p2 指向的节点即为待删除节点的前一个节点，执行删除操作。 返回头指针 使用 C 语言实现如下： LeetCodeSolution19.cview raw12345678910111213141516171819202122232425// 链表节点定义typedef struct ListNode { int val; struct ListNode *next;} ListNode;ListNode *delete(ListNode *head, int n) { if (head == NULL) return; ListNode *p1 = head, *p2 = head; // 滑动指针 p1 for (; n &gt; 0; n--) p1 = p1-&gt;next; // 同时滑动 p1 和 p2 直到 p1 指向最后一个节点 while (p1-&gt;next != NULL) { p1 = p1-&gt;next; p2 = p2-&gt;next; } // 删除节点 ListNode *tmp = p2-&gt;next; p2-&gt;next = tmp-&gt;next; if (tmp == head) head = tmp-&gt;next; free(tmp); // 释放 return head;}","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个链表，删除链表的倒数第 n 个节点，并返回链表的头结点。<br><a id=\"more\"></a></p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>给定一个链表：<code>1-&gt;2&gt;3-&gt;4-&gt;5</code>，和 <code>n=2</code>。当删除倒数第二个节点后，链表变为 <code>1-&gt;2&gt;3-&gt;5</code>。</p>\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>给定的 <code>n</code> 保证是有效的。</p>\n<h2 id=\"解题\"><a href=\"#解题\" class=\"headerlink\" title=\"解题\"></a>解题</h2><p>这个题使用双指针即可很快解决：</p>\n<ol>\n<li>初始化两个指针 <code>p1</code> 和 <code>p2</code> 均指向链表的头部</li>\n<li><code>p2</code> 不动，<code>p1</code> 指针向后滑动 <code>n</code> 个位置</li>\n<li><code>p1</code> 和 <code>p2</code> 一起向后滑动，当 <code>p1</code> 指向节点的下一个节点为空时，<code>p2</code> 指向的节点即为待删除节点的前一个节点，执行删除操作。</li>\n<li>返回头指针</li>\n</ol>\n<img src=\"/2020/05/delete-numN-node-at-reverse-order-in-list/illustration.png\" title=\"算法执行图示\">\n<p>使用 C 语言实现如下：</p>\n<figure class=\"highlight c\"><figcaption><span>LeetCodeSolution19.c</span><a href=\"/downloads/code/LeetCodeSolution19.c\">view raw</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 链表节点定义</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> {</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">} ListNode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ListNode *<span class=\"title\">delete</span><span class=\"params\">(ListNode *head, <span class=\"keyword\">int</span> n)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    ListNode *p1 = head, *p2 = head;</span><br><span class=\"line\">    <span class=\"comment\">// 滑动指针 p1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; n &gt; <span class=\"number\">0</span>; n--)</span><br><span class=\"line\">        p1 = p1-&gt;next;</span><br><span class=\"line\">    <span class=\"comment\">// 同时滑动 p1 和 p2 直到 p1 指向最后一个节点</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p1-&gt;next != <span class=\"literal\">NULL</span>) {</span><br><span class=\"line\">        p1 = p1-&gt;next;</span><br><span class=\"line\">        p2 = p2-&gt;next;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// 删除节点</span></span><br><span class=\"line\">    ListNode *tmp = p2-&gt;next;</span><br><span class=\"line\">    p2-&gt;next = tmp-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tmp == head)</span><br><span class=\"line\">        head = tmp-&gt;next;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(tmp); <span class=\"comment\">// 释放</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>","tags":[{"name":"算法","slug":"算法","permalink":"https://jonathan1214.github.io/tags/算法/"},{"name":"链表","slug":"链表","permalink":"https://jonathan1214.github.io/tags/链表/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://jonathan1214.github.io/tags/LeetCode/"}]},{"title":"呓语——一次申请的记录","date":"2020-04-22T13:58:15.000Z","path":"2020/04/a-whisper-story-of-an-application/","text":"日前，我又在为某件事犹豫不决一拖再拖了，这次是研究生申请。 最终我说服了自己，在那一段短暂的时间，我变得勇敢去追求自己想要的：我就是要争取成为这个老师的学生。那么第一步就应该是提出申请，没人能替我做这个事，面对这样的事，很难想象别人也会有同我一样的感受，我害怕被拒绝，考虑到会被拒绝都让我很难受，认为拒绝是对整个人的否定，不过我承认与否，我能感受到自己心中的感觉就是这样。好在这次我赢了，我暂胜了它，虽然托了较长一段时间。从外部看来，这仅仅就是一次申请一封邮件而言，不过厚着脸皮说一句：对我而言这是一次对自己的突破。希望自己能坚持敢于面对否定。 敢于开始做一件会被否定的事，结果对于我而言就不那么重要了，好消息是这次结果还算不错。老师没有拒绝，希望在疫情结束后返校面对面谈谈。现在我又多了一个盼望开学的理由了。我不想放弃这次不算机会的机会，放弃其他选项是值得的，我接受了老师的提议，希望能有师徒缘分吧。 申请之事告一段落，感谢『终身成长』带来的力量，开卷有益当真不错。现在先做好手上的事，顺便复习下基础知识，尽人事先。 5月11日到23更新 这两周蹭了老师的一门课，使用MATLAB实现一写通信技术的仿真，从课程中学到一些东西了，明白了之前一直迷迷糊糊的内容，当然最重要的是我的最终目的，希望这两周的表现能让老师满意。 5月25日更新 很开心，算是被老师接收了，等待一个多月，时间不长不短刚刚好。接下来是准备周三与学长学姐们的线上见面会，顺利通过之后就算是正式入门了，我需要准备一些问题以及准备回答一些问题，希望会有好结果。 5月26日更新 心终于沉下来了，这里列出我准备好的 15 个要问学长学姐们的问题。好吧，我的拖延症又犯了，再坚持努力克服下。 缓解压力的办法？ 怎样发现好的想法？ 介绍下实验室。 介绍下自己。 喜欢什么球类运动。 好吧，我没能写完。 5月28日更新 昨天下午面试一下午，完事儿之后心情久不能平静，还是老问题，我害怕失败，不过我不断说服自己：不要将这看成是对你自己的最终审判，无论结果如何这都是一次很好的成长机会。虽然还没收到最终的结果，但是今天心情稍微缓和些了，能够简单记录下昨天的过程，学长们（还是先不叫师兄的好）的有些问题值得深思。 开场一片欢声笑语，氛围很轻松，被告知成瑶和我得全程开摄像头，提问我们的学长学姐依次开摄像头和我们见面向我们提问，前辈们按照入学顺序依次向我们提问，成瑶先答我后答。这就是昨天下午面试的场景。 很遗憾没能记下全部问题，只有一些印象深刻的问题，列出如下： 会做饭吗？ 读研的动机是什么？有没有未来的规划。 希望从研究生经历中学到什么。 印象最深刻的一本书，为什么。 印象最深的一句名言，为什么。 人在低/高处如何自处。 如何面对自己的紧张情绪。 篮球喜欢哪个球队和球星。 大学经历中让你印象最深刻的事。 大学经历中让你最自豪的事。 关于人工智能等新技术的未来畅想。 2FSK 和 4FSK 谁的误码性能更好，为什么。 BPSK 和 QPSK 谁的误码性能更好，为什么。 如果你现在很想打球，如何说服你的正在干活的朋友跟着去。 如果实验室中别的同学在大声讨论，影响到你工作了，如何处理。 喜欢柯南吗？ 说一句除汉语和英语之外的语言。 有些问题很喜欢，有些问题没答上来，需要好好考虑。最后补充下于老师的问题，她问我朋政学长提的什么问题，检验我有没有认真听，碰巧我记得这个学长的问题，回答上了。事后我想了想，大概是对我上次课上没有认真听别人提问的再一次测试，老师实在是费心了，这一点我终身难忘，感谢。回头我又想了想，这个测试问题本就是不公平的，她只需记一个即可，而我所需要记得全部，还要分辨开来，不过问题本就是不对等的，我想太多了，老师的出发点是好的。 大致就这么些，还在焦急地等待最终的结果。 5月29日更新 昨天下午终于收到了回复，经过老师和师兄们的再三确认，我的确是个好相处的人，师兄师姐们同意我进组了。之所以等了这么久，是因为师兄们在确认我是不是个好相处的人，有人觉得我比较低沉。感谢他们的接纳，我会继续努力的。至此，这件事就算告一段落了，过程曲折问题多多，如何让陌生人感受到自己最想表达出来的东西，我需要好好总结。好在结果完美，感谢威哥和成瑶的帮助。","content":"<p>日前，我又在为某件事犹豫不决一拖再拖了，这次是研究生申请。</p>\n<p>最终我说服了自己，在那一段短暂的时间，我变得勇敢去追求自己想要的：<a id=\"more\"></a>我就是要争取成为这个老师的学生。那么第一步就应该是提出申请，没人能替我做这个事，面对这样的事，很难想象别人也会有同我一样的感受，我害怕被拒绝，考虑到会被拒绝都让我很难受，认为拒绝是对整个人的否定，不过我承认与否，我能感受到自己心中的感觉就是这样。好在这次我赢了，我暂胜了它，虽然托了较长一段时间。从外部看来，这仅仅就是一次申请一封邮件而言，不过厚着脸皮说一句：对我而言这是一次对自己的突破。希望自己能坚持敢于面对否定。</p>\n<p>敢于开始做一件会被否定的事，结果对于我而言就不那么重要了，好消息是这次结果还算不错。老师没有拒绝，希望在疫情结束后返校面对面谈谈。现在我又多了一个盼望开学的理由了。我不想放弃这次不算机会的机会，放弃其他选项是值得的，我接受了老师的提议，希望能有师徒缘分吧。</p>\n<p>申请之事告一段落，感谢『终身成长』带来的力量，开卷有益当真不错。现在先做好手上的事，顺便复习下基础知识，尽人事先。</p>\n<hr>\n<p>5月11日到23更新</p>\n<p>这两周蹭了老师的一门课，使用MATLAB实现一写通信技术的仿真，从课程中学到一些东西了，明白了之前一直迷迷糊糊的内容，当然最重要的是我的最终目的，希望这两周的表现能让老师满意。</p>\n<hr>\n<p>5月25日更新</p>\n<p>很开心，算是被老师接收了，等待一个多月，时间不长不短刚刚好。接下来是准备周三与学长学姐们的线上见面会，顺利通过之后就算是正式入门了，我需要准备一些问题以及准备回答一些问题，希望会有好结果。</p>\n<hr>\n<p>5月26日更新</p>\n<p>心终于沉下来了，这里列出我准备好的 15 个要问学长学姐们的问题。好吧，我的拖延症又犯了，再坚持努力克服下。</p>\n<blockquote>\n<ol>\n<li>缓解压力的办法？</li>\n<li>怎样发现好的想法？</li>\n<li>介绍下实验室。</li>\n<li>介绍下自己。</li>\n<li>喜欢什么球类运动。</li>\n</ol>\n</blockquote>\n<p>好吧，我没能写完。</p>\n<hr>\n<p>5月28日更新</p>\n<p>昨天下午面试一下午，完事儿之后心情久不能平静，还是老问题，我害怕失败，不过我不断说服自己：不要将这看成是对你自己的最终审判，无论结果如何这都是一次很好的成长机会。虽然还没收到最终的结果，但是今天心情稍微缓和些了，能够简单记录下昨天的过程，学长们（还是先不叫师兄的好）的有些问题值得深思。</p>\n<p>开场一片欢声笑语，氛围很轻松，被告知成瑶和我得全程开摄像头，提问我们的学长学姐依次开摄像头和我们见面向我们提问，前辈们按照入学顺序依次向我们提问，成瑶先答我后答。这就是昨天下午面试的场景。</p>\n<p>很遗憾没能记下全部问题，只有一些印象深刻的问题，列出如下：</p>\n<blockquote>\n<ol>\n<li>会做饭吗？</li>\n<li>读研的动机是什么？有没有未来的规划。</li>\n<li>希望从研究生经历中学到什么。</li>\n<li>印象最深刻的一本书，为什么。</li>\n<li>印象最深的一句名言，为什么。</li>\n<li>人在低/高处如何自处。</li>\n<li>如何面对自己的紧张情绪。</li>\n<li>篮球喜欢哪个球队和球星。</li>\n<li>大学经历中让你印象最深刻的事。</li>\n<li>大学经历中让你最自豪的事。</li>\n<li>关于人工智能等新技术的未来畅想。</li>\n<li>2FSK 和 4FSK 谁的误码性能更好，为什么。</li>\n<li>BPSK 和 QPSK 谁的误码性能更好，为什么。</li>\n<li>如果你现在很想打球，如何说服你的正在干活的朋友跟着去。</li>\n<li>如果实验室中别的同学在大声讨论，影响到你工作了，如何处理。</li>\n<li>喜欢柯南吗？</li>\n<li>说一句除汉语和英语之外的语言。</li>\n</ol>\n</blockquote>\n<p>有些问题很喜欢，有些问题没答上来，需要好好考虑。最后补充下于老师的问题，她问我朋政学长提的什么问题，检验我有没有认真听，碰巧我记得这个学长的问题，回答上了。事后我想了想，大概是对我上次课上没有认真听别人提问的再一次测试，老师实在是费心了，这一点我终身难忘，感谢。回头我又想了想，这个测试问题本就是不公平的，她只需记一个即可，而我所需要记得全部，还要分辨开来，不过问题本就是不对等的，我想太多了，老师的出发点是好的。</p>\n<p>大致就这么些，还在焦急地等待最终的结果。</p>\n<hr>\n<p>5月29日更新</p>\n<p>昨天下午终于收到了回复，经过老师和师兄们的再三确认，我的确是个好相处的人，师兄师姐们同意我进组了。之所以等了这么久，是因为师兄们在确认我是不是个好相处的人，有人觉得我比较低沉。感谢他们的接纳，我会继续努力的。至此，这件事就算告一段落了，过程曲折问题多多，<strong>如何让陌生人感受到自己最想表达出来的东西</strong>，我需要好好总结。好在结果完美，感谢威哥和成瑶的帮助。</p>\n","tags":[{"name":"记录","slug":"记录","permalink":"https://jonathan1214.github.io/tags/记录/"}]},{"title":"Notes of Satellite Communications","date":"2020-04-18T10:29:25.000Z","path":"2020/04/stallite-communications-notes/","text":"卫星通信课的笔记，持续更新。 1. Overview of Satellite Systems1.1. Frequency Allocations频率资源非常紧张，国际上由 ITU ( International TelecommunicationUnion ) 同一管理分配。在卫星通信中，为了更好地对频率资源进行管理，将世界分成三个区域。 Region 1: Europe, Africa, what was formerly the Soviet Union, and Mongolia Region 2: North and South America and Greenland Region 3: Asia (excluding region 1 areas), Australia, and the southwest Pacific 在区域内，全频带可使用。这些频率资源基本上是用于提供下面这些服务，当然它们也可以细分出很多内容，如 Mobile satellite services 中包含了 land mobile，maritime mobile 和 aeronautical mobile。 Fixed satellite service (FSS) Broadcasting satellite service (BSS) Mobile satellite services Navigational satellite services Meteorological satellite services 下表展示了常用的频带和它们的名称，这些都是常识。 还有一种 ITU 的频段划分方式，不在卫星通信中使用： 2. Orbits and Launching Methods","content":"<p>卫星通信课的笔记，持续更新。<br><a id=\"more\"></a></p>\n<h2 id=\"1-Overview-of-Satellite-Systems\"><a href=\"#1-Overview-of-Satellite-Systems\" class=\"headerlink\" title=\"1. Overview of Satellite Systems\"></a>1. Overview of Satellite Systems</h2><h3 id=\"1-1-Frequency-Allocations\"><a href=\"#1-1-Frequency-Allocations\" class=\"headerlink\" title=\"1.1. Frequency Allocations\"></a>1.1. Frequency Allocations</h3><p>频率资源非常紧张，国际上由 ITU ( International Telecommunication<br>Union ) 同一管理分配。在卫星通信中，为了更好地对频率资源进行管理，将世界分成三个区域。</p>\n<ul>\n<li>Region 1: Europe, Africa, what was formerly the Soviet Union, and Mongolia</li>\n<li>Region 2: North and South America and Greenland</li>\n<li>Region 3: Asia (excluding region 1 areas), Australia, and the southwest Pacific</li>\n</ul>\n<p>在区域内，全频带可使用。这些频率资源基本上是用于提供下面这些服务，当然它们也可以细分出很多内容，如 Mobile satellite services 中包含了 land mobile，maritime mobile 和 aeronautical mobile。</p>\n<ul>\n<li>Fixed satellite service (FSS)</li>\n<li>Broadcasting satellite service (BSS)</li>\n<li>Mobile satellite services</li>\n<li>Navigational satellite services</li>\n<li>Meteorological satellite services</li>\n</ul>\n<p>下表展示了常用的频带和它们的名称，这些都是常识。</p>\n<img src=\"/2020/04/stallite-communications-notes/frequency_band_designations.png\" title=\"Frequency Band Designations\">\n<p>还有一种 ITU 的频段划分方式，不在卫星通信中使用：</p>\n<img src=\"/2020/04/stallite-communications-notes/itu_frequency_band_designations.png\" title=\"ITU Frequency Band Designations\">\n<h2 id=\"2-Orbits-and-Launching-Methods\"><a href=\"#2-Orbits-and-Launching-Methods\" class=\"headerlink\" title=\"2. Orbits and Launching Methods\"></a>2. Orbits and Launching Methods</h2>","tags":[{"name":"notes","slug":"notes","permalink":"https://jonathan1214.github.io/tags/notes/"}]},{"title":"无线自组织网络路由协议","date":"2020-04-15T12:12:20.000Z","path":"2020/04/adhoc-routing-protocol/","text":"路，径之大者。由，从也。 路由，即建立、选择与遵循路径。在网络中，路由就是分组从源节点到目的节点时，决定端到端路径的网络范围的进程。路由工作在 OSI 参考模型的第三层——网络层，它解决了信息传递时的路径选择问题。 1. 路由协议引论路由回答了从出发点到达终点如何走的问题，以及如何走消耗的资源最少。 1.1. 传统路由在详细介绍 Ad-Hoc 中的路由协议之前，我们需要了解下传统路由，需要注意的是它与 Ad-Hoc 中的有所不同，这是由于 Ad-Hoc 的特点与传统网络有很大区别。在传统路由中，主机与路由器是分开的，主机需要通过路由器连接到网络中，路由工作由路由器实现。具体来看传统路由的建立过程如下： 发送端发出指令经路由器转发到达接收端； 路由器收到数据包后，解析目的节点，随后根据路由表寻找下一跳路由器节点； 一旦连接主机的路由器无法工作，将导致链路中段。 1.2. Ad-Hoc 网络中的路由Ad-Hoc 网络有其自身无中心等特点，导致其路由有如下特点： 网络中的终端兼有主机和路由两种功能，网络拓扑改变仍然额可以组网； 每个终端都存有自己的路由表； 网络中的单个链路中断或终端的变化不会对整体造成影响； Ad-Hoc 网络路由也面临着一些问题： 动态变化的网络拓扑，这将导致网络中路由表的频繁更新，常规的路由协议无法处理这种情况； 单向信道的存在，这点与常规路由路由协议需要处理的问题大不相同，它会造成认知的单向性、路由的单向性和信息不可达； 传输带宽有限； 无线移动终端的局限性。 1.3. 路由的分类在深入了解路由协议之前，下面先来对路由协议进行分类。我们需要关注的是分类的原则而不是分类的结果，关注这些原则对我们的理解大有好处，也许现在我们不太理解为何如此划分，当对它有一定的了解之后，回过头再来看就会理解的。 按照路由协议依据 基于链路状态的路由协议 基于距离矢量的路由协议 按照路由建立的方式 先应式路由协议 按需路由协议 按照网络逻辑结构 平面结构的路由协议 分层结构的路由协议 按照路由协议适用的网络规模 中、小规模自组网的路由协议 大规模网络的路由协议 其他类型 主要是专门用途的路由协议，如基于地理信息的路由协议 LAR 和 GPSR 等。 按照这种划分，我们在这里只介绍按照第一种划分方式（按照路由协议依据）和第二种划分方式（按照路由建立的方式）下的一些典型的路由协议。 2. 链路状态与距离矢量路由协议2.1. 链路状态路由协议该协议下，基于链路状态，汇总区域内所有的路由器的链路状态信息。根据状态信息生成网络拓扑结构，每一个路由器再根据拓扑结构计算出路由。对链路状态路由协议，我们通过一个典型的协议来研究，它就是 OSPF（开放式最短路径优先）协议。 OSPF 协议是一种典型的链路状态路由协议，基于 IP，采用 Dijkstra 算法 计算节点间的最短路径，它将链路状态广播数据包传送给区域内的所有路由器，区域内路由器共同维护同一张完整的网络图，保存在数据库中，每条记录都代表网络的一条从当前节点到其他节点的最短路径。 OSPF 工作分为如下三个过程：邻居表的建立，拓扑表的建立，计算路由。 邻居表的建立一台新加入 OSPF 区域的路由器首先要和邻居表建立邻接关系。 加入进来后，它会主动向其他路由广播 hello 分组，介绍自己 发送第一个 hello 完毕后，它会在四个 hello 的时间内等待应答，这被称为路由器的 初始状态。 网络中的其他路由器收到它发来的 hello 后，将它的信息加入到数据库中，并回应 hello 分组。 新路由器看到自己的 ID 出现在其他路由器应答的 hello 中时，就建立了邻接关系，将自己的状态改为双向。 拓扑表的建立此阶段依次涉及如下四个状态，经过这四个阶段后，此OSPF区域的所有路由器的数据拓扑图都达到了同步。 exstart state：其中一台路由器成为主路由器，两个邻居根据接口的IP地址的大小来确定主/从关系，主路由器负责发起通信。 exchange state：OSPF让每一个路由器和相邻路由器交换己有的链路状态摘要信息（邻接节点间发送 DBD，Database Description）。接收之后，与自己的拓扑表进行比较。找出自己所需要的信息。 loading state：经过与相邻路由器交换摘要信息后，新路由器需要更详细的信息（邻接节点间发送 LSR，Link State Request）。经过一系列的分组交换，全网同步的链路数据库就建立了。 full state：收到邻居发送的链路状态信息并更新和同步拓扑数据库后邻居便处于完全邻接状态。 计算路由在前一阶段，各个节点都有了全网的拓扑信息。在此阶段，每个路由器按照产生的全区域数据拓扑图（保存在它们的 LSDB 中），再运行 Dijkstra 算法，产生到目标网段的路由条目。 关于 Dijkstra 算法，这里不介绍了，详细可参考 Dijkstra算法。 2.2. 距离矢量路由协议该协议下具有如下特点，路由器直接传送各自的路由表信息。网络中的路由器从自己的邻居路由器得到路由信息，并将这些路由信息连同自己的本地路由信息发送给其他邻居，这样一级级的传递下去以达到全网同步。每个路由器并不了解整个网络拓扑。 距离矢量路由协议和链路状态协议的设计思想都被引用在 Ad-Hoc 等很多网络中。距离矢量（distance vector, DV）路由算法是动态路由算法，在该算法下，每个路由器维护一张矢量表，表中列出了当前已知的到每个目标的最当距离，以及所使用的线路。通过邻居之间相互交换信息，路由器不断更新它们内部的表。 路由度量：路由度量采用距离，距离表示本节点到达目的地址所需要的费用。这个距离可以是跳数，或队列长度，或时延； 网络信息发布：周期性的向相邻节点进行广播，发布的内容直接来源于本节点的路由表。经过相互的交换，每个节点可获得网络所有节点的距离信息； 路由选择：基于所获得的距离信息，以最短距离为标准，选择到信宿的下一跳节点； 路由表：每个节点维护一个路由表，表项包括信宿地址、到信宿的下一跳、到信宿节点的费用等； Ad-Hoc 网络中距离通过跳数体现，矢量就表现为下一跳的节点是谁。路由器之间广播自己的路由表中的信息，更具体将 Next 和 Metric 广播出去，广播的同时自己的位置天然携带了。接收到信息的其他路由器根据需要更新自己的路由表。从下图中的例子展示了细节。 看起来很好，不过这种算法却没有在 Ad-Hoc 直接被使用，因为它会带来路由环路问题。下面这个例子展示了这个问题。 在维护路由表信息的时候，如果在拓扑发生改变后，网络收敛缓慢产生了不协调或者矛盾的路由选择条目，就会发生路由环路的问题。这种条件下，路由器对无法到达的网络路由不予理睬，导致用户的数据包不停在网络上循环发送，最终造成网络资源的严重浪费。 通过一定的调整对 DV 算法进行改进，我们可以解决路由环路问题，一般而言，有如下常见解决方案： 定义最大跳数：设置最大跳数为 16，超过 16 的，网络视为不可达； 水平分割：路由器从某个接口学到的路由，不会从该接口再发回给邻居路由器； 触发更新：当路由信息发生变化时，立即向邻居设备发送触发更新报文； 路由毒化：在路由信息在路由表中失效时，先将度量值变为无穷大，再向邻居路由发送相关路由更新信息。 3. 主动路由协议该协议下，无论是否有通信需求，每个节点周期性广播并交换路由信息，维护一张包含到其他节点的路由信息的路由表，也被称为前摄式路由协议。这种协议下，节点主动发送路由更新包，故也叫作主动路由协议，包括RIP协议、DSDV协议、OSPF协议等。 这是一种传统的分布式最短路径路由协议，不难发现它有如下特点：每个节点维护到网络中所有节点的路由，所有路由都已经存在且随时可用，路由请求的延迟低，但路由开销高。 我们以 DSDV（Destination Sequenced Distance Vector，目的序列距离矢量）路由协议为例，来看看主动路由协议的细节。 3.1. DSDV 工作原理DSDV 是一种基于 Bellman-ford 算法的距离矢量路由协议，采用序列号机制来区分路由的新旧程度，防止可能发生的路由环路。 路由信息格式每个节点维护一张距离-矢量表，表中列出所有可达的目的节点及到达该目的节点的跳数，同时每条路由条目包含目的节点产生的序列号，用来区分新旧路由。我们先来看看 DSDV 协议下的路由表格式，将其与 DV 协议对比，注意其改进之处。 Destination Next Hop Metric Seq.No Install Time A A 0 S550_A 001000 B B 1 S102_B 001200 C B 3 S588_C 001200 D B 4 S312_D 001200 各列的含义如下： Destination：目的节点地址； Next Hop：下一跳节点地址； Metric：从该节点到目的节点的路由的跳数； Seq.No：目的节点序列号，是偶数，由目的端产生，防止出现路由环路，并确保路由信息是最新的，记作 SNNN_Dest； Install Time：记录路由建立的时间，用于删除过期的路由。 如上所示为路由条目信息，注意到在更新路由条目时，遵循两个原则：序列号新和度量值小。将更新信息和节点的路由表对比，选择序列号值大的路由信息，这样就能保证到达目的节点的路由信息是最新的。当序列号值相等时，选择度量值最佳（例如最小跳数）的路由信息。 信息公告各节点周期性的向邻居节点通告其当前的路由表，而不是采用洪泛法。这意味着各节点对收到的其他节点的信息进行处理以后再进行广播通告，大大减少了通过的信息量。后面我们还会讲到洪泛法，注意区分。 为了进一步减少路由信息的传输开销，DSDV 中使用了两类更新报文。第一种是完全转存，将路由表项中的所有信息进行通告。第二种是递增更新，仅通告更新信息。 举几个例子来说明如何公告： 广播更新的路由表：当节点的路由表更新后，它会同时更新以自己为 Dest 的路由条目的序号。它向周围广播的路由表时，会包括自己的已更新的序列号信息。 新节点的加入：新节点 D 加入网络后，会进行广播，接收到的信息的节点 C 会更新自己的路由表，然后向周围的节点广播更新的路由表。值得注意的是，C 在更新路由表时不止增加 D 的路由条目，同时会更新以自己为 Dest 的路由条目的 Seq.No。 链路断：如果在相当长的一段时间内不能收到相邻节点的广播消息，可推断出链路断。DSDV 下，断的链路度量值等于无穷。下一跳经过该链路的路由表项的度量值表为无穷，并分配一个新的序列号，且为奇数。出现无穷项时，立即触发递增更新报文发送，将链路断裂信息通告到全网。举个例子，节点 C 检测到链路断裂，序列号增加 1，然后其邻居更新路由表。注意若 B 在 C 发送更新报文前，发送了断裂链路的更新报文，那么由于其序列号小 1，不会触发 C 进行更新，也就避免了路由环路。 DSDV 的优缺点DSDV 协议基于 DV 算法，简单易实现，因只需和邻居节点交换路由信息，需要的存储空间小。而且我们可以看到，DSDV 解决了路由环路问题，且能对拓扑变化作出快速反应。再次强调，它是一种先验式（表驱动）路由。总结其优缺点如下。 优点 简单 无路由环路问题 无路由发现延迟 缺点 所有节点都必须公告路由，因此不支持休眠 收敛慢（距离矢量路由的特性） 开销大，大部分的路由信息从不使用 可扩展性是一个主要问题 4. 按需路由协议介绍完主动路由协议，我们再来看看按需路由协议。 当需要一条从源节点到目的节点的路径进行数据发送时才查找路由。节点并不保存整个网络的及时准确的路由信息。当源节点要向目的节点发送报文时，源节点在网络中发起路由查找过程，找到相应的路由后，才开始发送报文。也被称为后验式。 4.1. 动态 DSR 协议DSR 是最早采用按需路由思想的协议，它采用了源路由的路由机制，在每一个分组的头部都携带整条路由的信息，路由器按照该路由纪录来转发分组。 DSR 协议使用源路由，采用 Cache（缓冲器）存放路由信息，且中间节点不必存储转发分组所需的路由信息，网络开销较少，却因此存在陈旧路由。 4.1.1. 路由发现当一个节点欲发送数据到目的节点时，它首先查询路由缓冲器是否有到目的节点的路由。如果有，则按此路由发送数据；如果没有，源节点就开始启动路由发现程序。路由发现过程中使用洪泛路由（Flooding Routing）。 当节点 S 需要向节点 D 发送数据，但不知到节点 D 的路由于是节点 S 就开始路由发现过程。源节点 S 洪泛『路由请求』分组 Route Request(RREQ)，每个请求分组通过序列号和源节点 S 标识唯一确定。 路由请求源节点向邻居节点广播路由请求（RREQ）消息，RREQ 的格式及含义如下所示。 其中，Sid 为源节点 ID 号，Did 为目的节点 ID 号，Route record 是路由记录，记录了从源节点到目的节点所经过的节点序列，Request ID 为路由请求序列号，由源节点设置。 当一个节点收到 RREQ 时，如果该节点满足： 不是目的节点D； 请求分组头部的源路由序列中不包含该节点； 没有接收过同样的路由请求分组； 且路由表中没有目的节点D的路由信息。 那么节点将自己的地址附加到『路由请求』分组头部的 Route record 中，并将该分组转发给所有相邻节点。 重复检测上面提到的第 2、3 点其实就是对 RREQ 重复的检测，这种检测是为了避免路由环路问题。我们再次重复一下这个 RREQ 重复的检测：如果（1）节点接收到的RREQ消息中的 &lt;源节点地址、请求 ID&gt; 存在于本节点的序列对列表中，或者（2）如果节点接收到的RREQ消息中的路由记录中包含本节点的地址，那么我们认为这个 RREQ 是重复的，将它丢弃。 路由应答当 RREQ 分组最终传递到目的节点 D 时，D 会往回发送 RREP 分组，分组的格式如下： 其中，Did 表示目的节点 ID 或者说是请求路由分组的源节点 ID，Date Route 表示启动路由请求的源节点发送的数据分组要经过的路由（节点序列），而 Reply Route 是路由应答分组 RREP 所要经过的路由（节点序列，不难发现将 Date Route 反向即可）。 获得新路由的方式节点在转发 RREQ 时也会获得到源节点的，如 E 转发来自 C 的 RREQ（A-B-C），它就会获得到 A 的路由（E-C-B-A）。 节点也会监听相邻节点发送的分组（包括 RREQ，RREP，数据分组），查看需要的路由信息。 节点转发 RREP 时，获得到目的节点的路径上的所有节点的路由。 节点转发数据分组时，获得从本节点到源节点的路由。 路由缓存当源节点 S 接到 RREP 分组后，就将 RREP 分组中从源节点 S 到目的节点 D 的路由信息进行缓存；当源节点 S 向目的节点 D 发送数据分组时，此路由信息就包含在每个分组的头部。所有的中间节点利用源路由信息进行分组转发。 4.1.2. 路由维护路由缓存的优化当中间节点的缓存中包含到目的节点的路由时，就由这个中间节点发送 RREP 给源节点，这将缩短路由寻址时间。 但是，这种优化也会带来问题。 错误路由缓存网络拓扑的变化使得缓存的路由失效。影响和感染其它节点，使用该路由缓存的路由将不可用；当节点根据路由缓存回应 RREP 时，其它监听到此 RREP 的节点会更改自己缓存的路由，从而感染错误路由缓存。对于这种问题，我们可以设置缓存路由的有效期，过期删除。 RREP 风暴当某个节点广播某个目的节点的 RREQ 时，当其邻居节点的路由缓存中都有到该目的节点的路由时，每个邻居节点都试图以自己缓存的路由响应，由此造成 RREP 风暴。RREP风暴将浪费网络带宽，并且加剧局部网络冲突。 为解决这个问题，让所有欲发送 RREP 的节点，先延时 D，再发送。D=H*(h-1+r)，其中 H 是每条链路的传播延时，h 是自己返回的路径长度即到目的节点的跳数，r 是 0 或者 1。可以看到，D 与节点到目的节点的跳数成正比，使得到目的节点的最短路径的 RREP 最先发送。同时，所有的节点都设置成混杂模式，监听是否存在比自己更短的到目的节点的路径，如果有，就不发送本节点的 RREP。 路由故障分组 RERR如果中间节点发现路由表中显示的下一跳节点链路层不可到达，向源节点发送一个RERR。源节点从路由缓冲条目中删除所有不可到达的链路（这条路径的中间节点也利用这个信息更新路由缓冲器） 。源节点将重新启动新的路由发现过程。RERR 的格式如下： 其中 Node1 表示链路出错的一端节点 ID 号，Node2 是链路出错的另一端节点 ID 号，Did 表示目的节点 ID 或遇到链路出错的数据分组的源节点 ID ，Rerr route 是路由出错分组所要经过的路由（节点序号）。 下图展示了一个例子，从中我们可以看出 RERR 是如何工作的。 4.1.3. DSR 总结从上面的描述中，我们不难发现 DSR 协议的特点，这里再对其进行一个总结，它具有如下优点： 采用源路由机制、避免了路由环路； 它是一种按需路由协议，只有当两个节点间进行通信时，才会缓存路由纪录； 因此相对主动路由来说，减小了路由维护的开销； 通过采用路由缓存技术，减少路由请求信息对信道的占用。 虽然 DSR 存在一定的缺陷，但是也有一些解决办法，一并列出来。 随着路经跳数的增加，分组头长度线性增加、开销大； 路由请求分组 RREQ 采用洪泛发向全网扩散，导致网络负荷大； 来自邻居节点的 RREQ 分组在某个节点可能会发生碰撞，解决办法是：在发送 RREQ 分组时引入随机时延； 当源节点发送路由请求分组 RREQ 时，可能会收到多个节点缓存的到达目的节点的路由信息，引起竞争。解决办法：若某节点听到其它节点发出的 RREQ 分组中路由信息含有较少跳数，此节点停止发送。 当源节点发送路由请求分组 RREQ 时，可能会收到多个节点缓存的到达目的节点的路由信息，但有些路由信息可能是过时的。解决办法：引入定时器、链路断的情况应进行全网洪泛。 4.2. AODV 协议AODV，Ad Hoc on demand distance vector，按需距离矢量路由协议。 AODV 在 DSR 的基础上进行了一些改进，在 AODV 中，参与通信过程的节点需要维护路由表，那些不再路径上的节点不保存路由信息，数据分组不需要包含从源到目的节点的路由信息，即采用逐跳转发分组方式。 AODV路由协议是为Ad hoc网络节点设计的，它提供对动态链路状况的快速自适应、处理开销和存储开销低、路由开销低、确定到达 Ad Hoc 网络内目的节点的单目标传输路由。 AODV 有四种基本的报文：RREQ（路由请求帧），RREP（路由应答帧），RERR（路由错误帧），HELLO（活跃路由链路监测帧）。 4.2.1 AODV 路由表路由请求发送 RREQ 过程建立反向路由表，转发 RREP 时建立正向路由表，路由维护时更新路由表。路由表主要构成如下： 目的节点地址 n_dst：用于标志使用此路由的最终目的节点，决定了数据分组转 发方向。 目的节点序列号 rt_seqno：反映此路由的新鲜度，一般序列号越大路由越新鲜， 这是保证开环的重要措施，在路由发现和路由应答更新路由时需要进行序列号的 比较。 路由状态标志 rt_flags(有效、无效、正在修复等)：反映此路由目前的状态，主要 用于告知数据分组经过此节点的时候处理方式。 网络接口 rt_interface：移动节点访问信道的接口 跳数 rt_hops：到达目的节点所需要的跳数。 下一跳rt_nexthop：：数据分组经过本节点之后，数据分组将被直接转发的中继节点，通常下一跳节点应该出现在当前节点的邻节点列表中。 前驱节点列表 rt_pcliSt：使用这条路由的所有直接前驱节点列表。 路由生命期 rt_expire：路由有效的生命期，在数据分组转发使用当前路由时会更新路由的有效生命期，当较长时间不使用此路由时，此路由的有效期将会过期，在路由管理时将会使路由失效。 网络中的每个节点维护自身的序列号，它表征了路由的新旧。节点在发生路由请求时，会先增加自己的序列号，再发送，发送的 RREQ 中会携带自己的序列号。目的节点只接受最新的序列号，这样一来就可以避免路由环路问题。 4.2.2. 路由建立简单概括成以下几个过程： 源节点广播路由请求帧 RREQ； 中间节点转发 RREQ，转发过程类似 DSR 协议； 当目标节点接到 RREQ 分组时，它回应 RREP 分组，RREP 沿着方向路径传输。 源节点 S 打算向目的节点 D 发送一个数据包，在路由表中未查找到能到达D的路由，向其邻居广播 RREQ 分组用于路由发现。为避免节点重复接收处理 RREQ 消息，用源节点和路由请求编号的组合唯一标识一个 RREQ 请求。 接收到RREQ的节点作如下处理：中间节点更新各自到源节点S的路由表，记录并维护指向源节点的反向路由；设置到源节点路由表的『过时定时器』。 如果收到 RREQ 的节点不是目的节点，更新 RREQ 分组（将 RREQ中 的信宿序列号设为节点收到的该信宿 D 相关的最大序列号，跳计数加1），并转发更新后的 RREQ 分组。如果在『路由发现定时』内已收到一个具有相同标识的RREQ分组，则抛弃该分组，不作任何处理。 如果满足如下条件之一，则节点产生 RREP，并单播发送到源节点 S，否则继续广播 RREQ，且表项的序列号大于 RREQ 中的信宿序列号。 该节点就是目的节点D，； 节点的路由表中有到目的节点D的活动表项。 转发 RREP 的中间节点创建『前向路由表』并更新，记录转发路由的下游节点、跳数、生存时间、目的序列号等内容；将跳计数加 1，并根据先前记录的反向路由将 RREP 报文转发给上游节点。上游节点收到RREP后按照相同规则更新路由表并转发 RREP，直至源节点 S。 4.2.3. 路由维护AODV的路由也同样存在过期问题，因此参与通信的节点，需要维护路由表。通过设一个定时器，当超过设定时间时，则认为路由表中的反向路径信息无效。 AODV链路状态检测机制，活跃路径节点以HELLO_INTERVAL为周期发送HELLO，用来保持联系，当在设定的时间内，如果没有来自路由表中的前向路径的HELLO，则认为前向路径信息失效（即使路由信息是可用的）。 与活动路由无关的节点移动，并不影响信源到信宿的寻径。 如果信源节点移动导致路由不可用，则由信源重新发起路由发现的过程。 当由于信宿节点或活动路由的中间节点移动等原因导致链路中断链路的『上游节点』主动发送一个 RERR，该 RERR 的信宿序列号大于其所储存的信宿序列号，并传播到所有的邻居，邻居节点会继续转发 RERR 分组。其他节点收到RERR分组后，更新路由表（将包含e的链路设为无效），并继续转发RERR分组。该过程不断重复，直至所有的相关节点被通告到。 中间节点收到发送到目的节点的数据包时，如果发现到达目的节点的路由失效，该中间节点可以缓存该数据包，并发起到目的节点的路由请求，等待路由重新建立后再据需发送数据包。 4.2.4. AODV 总结优点：传统的距离向量路由机制；支持中间节点应答，能使源节点迅速获得路由，有效减少了广播数，但存在过时路由问题；节点只存储需要的路由，减少了内存的需要和不必要的复制；快速响应路径上的断链，避免路由环路；具有网络的可扩充性； 缺点是路由建立时延较大。 5. 主动路由协议与按需路由协议 主动路由协议是按路由发现和建立路由方式的角度分类下的一种路由协议，也叫表驱动路由协议，与之相对的是按需路由协议，前面介绍的两种路由协议 OSPF、DSDV 均属于主动路由协议。 主动路由协议的特点： 传统的分布式最短路径路由协议，基于链路状态或者距离向量，所有节点连续更新『可达』信息； 每个节点维护到网络中所有节点的路由； 所有路由都已经存在并且随时可用； 路由请求的延迟低； 路由开销高。 按需路由特点： 在源端需要时候通过路由发现过程来确定路由控制信息采用洪泛（flooding）方式，路由请求延迟高，路由开销低； 两种实现技术：源路由（报文头携带完整的路由信息）和逐跳路由（类似现有的Internet路由）。 由于他们建立的方式不同，在应对不同的场合他们会有不同的效率表现。主动协议因全程维护所有的路由而具备低延迟；按需协议因只在需要时才发现所需路由而导致高延迟。主动协议因连续更新路由可能导致高开销；按需协议因只在需要时才维护路由而具备低开销。 具体选择哪种类型的路由取决于业务负载和节点的移动模式（是否频繁移动）。","content":"<blockquote>\n<p>路，径之大者。<br>由，从也。</p>\n</blockquote>\n<p>路由，即建立、选择与遵循路径。在网络中，路由就是分组从源节点到目的节点时，决定端到端路径的网络范围的进程。路由工作在 OSI 参考模型的第三层——网络层，它解决了信息传递时的路径选择问题。<br><a id=\"more\"></a></p>\n<h2 id=\"1-路由协议引论\"><a href=\"#1-路由协议引论\" class=\"headerlink\" title=\"1. 路由协议引论\"></a>1. 路由协议引论</h2><p>路由回答了从出发点到达终点如何走的问题，以及如何走消耗的资源最少。</p>\n<h3 id=\"1-1-传统路由\"><a href=\"#1-1-传统路由\" class=\"headerlink\" title=\"1.1. 传统路由\"></a>1.1. 传统路由</h3><p>在详细介绍 Ad-Hoc 中的路由协议之前，我们需要了解下传统路由，需要注意的是它与 Ad-Hoc 中的有所不同，这是由于 Ad-Hoc 的特点与传统网络有很大区别。在传统路由中，主机与路由器是分开的，主机需要通过路由器连接到网络中，路由工作由路由器实现。具体来看传统路由的建立过程如下：</p>\n<ul>\n<li>发送端发出指令经路由器转发到达接收端；</li>\n<li>路由器收到数据包后，解析目的节点，随后根据路由表寻找下一跳路由器节点；</li>\n<li>一旦连接主机的路由器无法工作，将导致链路中段。</li>\n</ul>\n<h3 id=\"1-2-Ad-Hoc-网络中的路由\"><a href=\"#1-2-Ad-Hoc-网络中的路由\" class=\"headerlink\" title=\"1.2. Ad-Hoc 网络中的路由\"></a>1.2. Ad-Hoc 网络中的路由</h3><p>Ad-Hoc 网络有其自身无中心等特点，导致其路由有如下特点：</p>\n<ul>\n<li>网络中的终端兼有主机和路由两种功能，网络拓扑改变仍然额可以组网；</li>\n<li>每个终端都存有自己的路由表；</li>\n<li>网络中的单个链路中断或终端的变化不会对整体造成影响；</li>\n</ul>\n<p>Ad-Hoc 网络路由也面临着一些问题：</p>\n<ul>\n<li>动态变化的网络拓扑，这将导致网络中路由表的频繁更新，常规的路由协议无法处理这种情况；</li>\n<li>单向信道的存在，这点与常规路由路由协议需要处理的问题大不相同，它会造成认知的单向性、路由的单向性和信息不可达；</li>\n<li>传输带宽有限；</li>\n<li>无线移动终端的局限性。</li>\n</ul>\n<h3 id=\"1-3-路由的分类\"><a href=\"#1-3-路由的分类\" class=\"headerlink\" title=\"1.3. 路由的分类\"></a>1.3. 路由的分类</h3><p>在深入了解路由协议之前，下面先来对路由协议进行分类。我们需要关注的是分类的原则而不是分类的结果，关注这些原则对我们的理解大有好处，也许现在我们不太理解为何如此划分，当对它有一定的了解之后，回过头再来看就会理解的。</p>\n<ul>\n<li>按照路由协议依据<ul>\n<li>基于链路状态的路由协议</li>\n<li>基于距离矢量的路由协议</li>\n</ul>\n</li>\n<li>按照路由建立的方式<ul>\n<li>先应式路由协议</li>\n<li>按需路由协议</li>\n</ul>\n</li>\n<li>按照网络逻辑结构<ul>\n<li>平面结构的路由协议</li>\n<li>分层结构的路由协议</li>\n</ul>\n</li>\n<li>按照路由协议适用的网络规模<ul>\n<li>中、小规模自组网的路由协议</li>\n<li>大规模网络的路由协议</li>\n</ul>\n</li>\n<li>其他类型<ul>\n<li>主要是专门用途的路由协议，如基于地理信息的路由协议 LAR 和 GPSR 等。</li>\n</ul>\n</li>\n</ul>\n<img src=\"/2020/04/adhoc-routing-protocol/common_routing_protocol.png\" title=\"常用路由协议名称\">\n<img src=\"/2020/04/adhoc-routing-protocol/common_routing_protocol2.png\" title=\"常用路由协议归类\">\n<p>按照这种划分，我们在这里只介绍按照第一种划分方式（按照路由协议依据）和第二种划分方式（按照路由建立的方式）下的一些典型的路由协议。</p>\n<h2 id=\"2-链路状态与距离矢量路由协议\"><a href=\"#2-链路状态与距离矢量路由协议\" class=\"headerlink\" title=\"2. 链路状态与距离矢量路由协议\"></a>2. 链路状态与距离矢量路由协议</h2><h3 id=\"2-1-链路状态路由协议\"><a href=\"#2-1-链路状态路由协议\" class=\"headerlink\" title=\"2.1. 链路状态路由协议\"></a>2.1. 链路状态路由协议</h3><p>该协议下，基于链路状态，汇总区域内所有的路由器的链路状态信息。根据状态信息生成网络拓扑结构，每一个路由器再根据拓扑结构计算出路由。<br>对链路状态路由协议，我们通过一个典型的协议来研究，它就是 OSPF（开放式最短路径优先）协议。</p>\n<p>OSPF 协议是一种典型的链路状态路由协议，<strong>基于 IP</strong>，采用 <strong>Dijkstra 算法</strong> 计算节点间的最短路径，它将链路状态广播数据包传送给区域内的所有路由器，区域内路由器共同维护同一张完整的网络图，保存在数据库中，每条记录都代表网络的一条从当前节点到其他节点的最短路径。</p>\n<p>OSPF 工作分为如下三个过程：邻居表的建立，拓扑表的建立，计算路由。</p>\n<h4 id=\"邻居表的建立\"><a href=\"#邻居表的建立\" class=\"headerlink\" title=\"邻居表的建立\"></a>邻居表的建立</h4><p>一台新加入 OSPF 区域的路由器首先要和邻居表建立邻接关系。</p>\n<ol>\n<li>加入进来后，它会主动向其他路由广播 hello 分组，介绍自己</li>\n<li>发送第一个 hello 完毕后，它会在四个 hello 的时间内等待应答，这被称为路由器的 <strong>初始状态</strong>。</li>\n<li>网络中的其他路由器收到它发来的 hello 后，将它的信息加入到数据库中，并回应 hello 分组。</li>\n<li>新路由器看到自己的 ID 出现在其他路由器应答的 hello 中时，就建立了邻接关系，将自己的状态改为双向。</li>\n</ol>\n<img src=\"/2020/04/adhoc-routing-protocol/OSPF_build_adjacent_table.png\" title=\"OSPF 下邻接表建立\">\n<h4 id=\"拓扑表的建立\"><a href=\"#拓扑表的建立\" class=\"headerlink\" title=\"拓扑表的建立\"></a>拓扑表的建立</h4><p>此阶段依次涉及如下四个状态，经过这四个阶段后，此OSPF区域的所有路由器的数据拓扑图都达到了同步。</p>\n<ol>\n<li>exstart state：其中一台路由器成为主路由器，两个邻居根据接口的IP地址的大小来确定主/从关系，主路由器负责发起通信。</li>\n<li>exchange state：OSPF让每一个路由器和相邻路由器交换己有的链路状态摘要信息（邻接节点间发送 DBD，Database Description）。接收之后，与自己的拓扑表进行比较。找出自己所需要的信息。</li>\n<li>loading state：经过与相邻路由器交换摘要信息后，新路由器需要更详细的信息（邻接节点间发送 LSR，Link State Request）。经过一系列的分组交换，全网同步的链路数据库就建立了。</li>\n<li>full state：收到邻居发送的链路状态信息并更新和同步拓扑数据库后邻居便处于完全邻接状态。</li>\n</ol>\n<h4 id=\"计算路由\"><a href=\"#计算路由\" class=\"headerlink\" title=\"计算路由\"></a>计算路由</h4><p>在前一阶段，各个节点都有了全网的拓扑信息。在此阶段，每个路由器按照产生的全区域数据拓扑图（保存在它们的 LSDB 中），再运行 Dijkstra 算法，产生到目标网段的路由条目。</p>\n<p>关于 Dijkstra 算法，这里不介绍了，详细可参考 <a href=\"https://blog.csdn.net/qq_35644234/article/details/60870719\" target=\"_blank\" rel=\"noopener\">Dijkstra算法</a>。</p>\n<h3 id=\"2-2-距离矢量路由协议\"><a href=\"#2-2-距离矢量路由协议\" class=\"headerlink\" title=\"2.2. 距离矢量路由协议\"></a>2.2. 距离矢量路由协议</h3><p>该协议下具有如下特点，路由器直接传送各自的路由表信息。网络中的路由器从自己的邻居路由器得到路由信息，并将这些路由信息连同自己的本地路由信息发送给其他邻居，这样一级级的传递下去以达到全网同步。每个路由器并不了解整个网络拓扑。</p>\n<p>距离矢量路由协议和链路状态协议的设计思想都被引用在 Ad-Hoc 等很多网络中。距离矢量（distance vector, DV）路由算法是动态路由算法，在该算法下，每个路由器维护一张矢量表，表中列出了当前已知的到每个目标的最当距离，以及所使用的线路。通过邻居之间相互交换信息，路由器不断更新它们内部的表。</p>\n<ul>\n<li>路由度量：路由度量采用距离，距离表示本节点到达目的地址所需要的费用。这个距离可以是跳数，或队列长度，或时延；</li>\n<li>网络信息发布：周期性的向相邻节点进行广播，发布的内容直接来源于本节点的路由表。经过相互的交换，每个节点可获得网络所有节点的距离信息；</li>\n<li>路由选择：基于所获得的距离信息，以最短距离为标准，选择到信宿的下一跳节点；</li>\n<li>路由表：每个节点维护一个路由表，表项包括信宿地址、到信宿的下一跳、到信宿节点的费用等；</li>\n</ul>\n<p>Ad-Hoc 网络中距离通过跳数体现，矢量就表现为下一跳的节点是谁。路由器之间广播自己的路由表中的信息，更具体将 Next 和 Metric 广播出去，广播的同时自己的位置天然携带了。接收到信息的其他路由器根据需要更新自己的路由表。从下图中的例子展示了细节。</p>\n<img src=\"/2020/04/adhoc-routing-protocol/dv_phase1_init.png\" title=\"DV 算法初始化\">\n<img src=\"/2020/04/adhoc-routing-protocol/dv_phase2_update_route.png\" title=\"DV 算法路由更新\">\n<p>看起来很好，不过这种算法却没有在 Ad-Hoc 直接被使用，因为它会带来路由环路问题。下面这个例子展示了这个问题。</p>\n<img src=\"/2020/04/adhoc-routing-protocol/dv_route_loop1.png\">\n<img src=\"/2020/04/adhoc-routing-protocol/dv_route_loop2.png\" title=\"路由环路问题示例\">\n<p>在维护路由表信息的时候，如果在<span style=\"color:red\">拓扑发生改变</span>后，网络收敛缓慢产生了不协调或者<span style=\"color:red\">矛盾的路由选择条目</span>，就会发生路由环路的问题。这种条件下，路由器对无法到达的网络路由不予理睬，导致用户的数据包不停在网络上<span style=\"color:red\">循环发送</span>，最终造成网络资源的严重浪费。</p>\n<p>通过一定的调整对 DV 算法进行改进，我们可以解决路由环路问题，一般而言，有如下常见解决方案：</p>\n<ul>\n<li>定义最大跳数：设置最大跳数为 16，超过 16 的，网络视为不可达；</li>\n<li>水平分割：路由器从某个接口学到的路由，不会从该接口再发回给邻居路由器；</li>\n<li>触发更新：当路由信息发生变化时，立即向邻居设备发送触发更新报文；</li>\n<li>路由毒化：在路由信息在路由表中失效时，先将度量值变为无穷大，再向邻居路由发送相关路由更新信息。</li>\n</ul>\n<h2 id=\"3-主动路由协议\"><a href=\"#3-主动路由协议\" class=\"headerlink\" title=\"3. 主动路由协议\"></a>3. 主动路由协议</h2><p>该协议下，无论是否有通信需求，每个节点周期性广播并交换路由信息，维护一张包含到其他节点的路由信息的路由表，也被称为前摄式路由协议。这种协议下，节点主动发送路由更新包，故也叫作<span style=\"color:red\">主动路由协议</span>，包括<span style=\"color:red\">RIP协议、DSDV协议、OSPF协议</span>等。</p>\n<p>这是一种传统的分布式最短路径路由协议，不难发现它有如下特点：每个节点维护到网络中所有节点的路由，所有路由都已经存在且随时可用，路由请求的延迟低，但路由开销高。</p>\n<p>我们以 DSDV（Destination Sequenced Distance Vector，目的序列距离矢量）路由协议为例，来看看主动路由协议的细节。</p>\n<h3 id=\"3-1-DSDV-工作原理\"><a href=\"#3-1-DSDV-工作原理\" class=\"headerlink\" title=\"3.1. DSDV 工作原理\"></a>3.1. DSDV 工作原理</h3><p>DSDV 是一种基于 Bellman-ford 算法的<span style=\"color:red\">距离矢量路由协议</span>，采用<span style=\"color:red\">序列号</span>机制来区分路由的新旧程度，防止可能发生的路由环路。</p>\n<h4 id=\"路由信息格式\"><a href=\"#路由信息格式\" class=\"headerlink\" title=\"路由信息格式\"></a>路由信息格式</h4><p>每个节点维护一张<span style=\"color:red\">距离-矢量表</span>，表中列出所有可达的目的节点及到达该目的节点的跳数，同时每条路由条目包含目的节点产生的序列号，用来区分新旧路由。我们先来看看 DSDV 协议下的路由表格式，将其与 DV 协议对比，注意其改进之处。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Destination</th>\n<th style=\"text-align:center\">Next Hop</th>\n<th style=\"text-align:center\">Metric</th>\n<th style=\"text-align:center\">Seq.No</th>\n<th style=\"text-align:center\">Install Time</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">S550_A</td>\n<td style=\"text-align:center\">001000</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">B</td>\n<td style=\"text-align:center\">B</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">S102_B</td>\n<td style=\"text-align:center\">001200</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C</td>\n<td style=\"text-align:center\">B</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">S588_C</td>\n<td style=\"text-align:center\">001200</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">D</td>\n<td style=\"text-align:center\">B</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">S312_D</td>\n<td style=\"text-align:center\">001200</td>\n</tr>\n</tbody>\n</table>\n<p>各列的含义如下：</p>\n<ul>\n<li>Destination：目的节点地址；</li>\n<li>Next Hop：下一跳节点地址；</li>\n<li>Metric：从该节点到目的节点的路由的跳数；</li>\n<li>Seq.No：目的节点序列号，是<span style=\"color:red\">偶数</span>，由目的端产生，防止出现路由环路，并确保路由信息是最新的，记作 SNNN_Dest；</li>\n<li>Install Time：记录路由建立的时间，用于删除过期的路由。</li>\n</ul>\n<p>如上所示为路由条目信息，注意到在更新路由条目时，遵循两个<span style=\"color:red\">原则</span>：<span style=\"color:red\">序列号新和度量值小</span>。将更新信息和节点的路由表对比，选择<span style=\"color:red\">序列号值大的路由信息</span>，这样就能保证到达目的节点的路由信息是最新的。当序列号值相等时，选择<span style=\"color:red\">度量值最佳</span>（例如最小跳数）的路由信息。</p>\n<h4 id=\"信息公告\"><a href=\"#信息公告\" class=\"headerlink\" title=\"信息公告\"></a>信息公告</h4><p>各节点周期性的向邻居节点通告其当前的路由表，而不是采用洪泛法。这意味着各节点对收到的其他节点的信息进行处理以后再进行广播通告，大大减少了通过的信息量。后面我们还会讲到洪泛法，注意区分。</p>\n<p>为了进一步减少路由信息的传输开销，DSDV 中使用了两类更新报文。第一种是<span style=\"color:red\">完全转存</span>，将路由表项中的所有信息进行通告。第二种是<span style=\"color:red\">递增更新</span>，仅通告更新信息。</p>\n<p>举几个例子来说明如何公告：</p>\n<ol>\n<li>广播更新的路由表：当节点的路由表更新后，它会同时更新以自己为 Dest 的路由条目的序号。它向周围广播的路由表时，会包括自己的已更新的序列号信息。</li>\n<li>新节点的加入：新节点 D 加入网络后，会进行广播，接收到的信息的节点  C 会更新自己的路由表，然后向周围的节点广播更新的路由表。值得注意的是，C 在更新路由表时不止增加 D 的路由条目，同时会更新以自己为 Dest 的路由条目的 Seq.No。</li>\n<li>链路断：如果在相当长的一段时间内不能收到相邻节点的广播消息，可推断出链路断。DSDV 下，断的链路度量值<span style=\"color:red\">等于无穷</span>。下一跳经过该链路的路由表项的度量值表为无穷，并分配一个新的序列号，且为<span style=\"color:red\">奇数</span>。出现无穷项时，立即触发<span style=\"color:red\">递增更新</span>报文发送，将链路断裂信息通告到全网。<br>举个例子，节点 C 检测到链路断裂，序列号增加 1，然后其邻居更新路由表。注意若 B 在 C 发送更新报文前，发送了断裂链路的更新报文，那么由于其序列号小 1，不会触发 C 进行更新，也就<span style=\"color:red\">避免了路由环路</span>。</li>\n</ol>\n<h4 id=\"DSDV-的优缺点\"><a href=\"#DSDV-的优缺点\" class=\"headerlink\" title=\"DSDV 的优缺点\"></a>DSDV 的优缺点</h4><p>DSDV 协议基于 DV 算法，简单易实现，因只需和邻居节点交换路由信息，需要的存储空间小。而且我们可以看到，DSDV 解决了路由环路问题，且能对拓扑变化作出快速反应。再次强调，它是一种<span style=\"color:red\">先验式（表驱动）路由</span>。总结其优缺点如下。</p>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li>简单</li>\n<li>无路由环路问题</li>\n<li>无路由发现延迟</li>\n</ul>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ul>\n<li>所有节点都必须公告路由，因此不支持休眠</li>\n<li>收敛慢（距离矢量路由的特性）</li>\n<li>开销大，大部分的路由信息从不使用</li>\n<li>可扩展性是一个主要问题</li>\n</ul>\n<h2 id=\"4-按需路由协议\"><a href=\"#4-按需路由协议\" class=\"headerlink\" title=\"4. 按需路由协议\"></a>4. 按需路由协议</h2><p>介绍完主动路由协议，我们再来看看按需路由协议。</p>\n<p>当需要一条从源节点到目的节点的路径进行数据发送时才查找路由。节点并不保存整个网络的及时准确的路由信息。当源节点要向目的节点发送报文时，源节点在网络中发起路由查找过程，找到相应的路由后，才开始发送报文。也被称为后验式。</p>\n<h3 id=\"4-1-动态-DSR-协议\"><a href=\"#4-1-动态-DSR-协议\" class=\"headerlink\" title=\"4.1. 动态 DSR 协议\"></a>4.1. 动态 DSR 协议</h3><p>DSR 是最早采用<span style=\"color:red\">按需路由</span>思想的协议，它采用了<span style=\"color:red\">源路由</span>的路由机制，在每一个分组的头部都携带整条路由的信息，路由器按照该路由纪录来转发分组。</p>\n<p>DSR 协议使用源路由，采用 Cache（缓冲器）存放路由信息，且中间节点不必存储转发分组所需的路由信息，网络开销较少，却因此存在陈旧路由。</p>\n<h4 id=\"4-1-1-路由发现\"><a href=\"#4-1-1-路由发现\" class=\"headerlink\" title=\"4.1.1. 路由发现\"></a>4.1.1. 路由发现</h4><p>当一个节点欲发送数据到目的节点时，它首先查询路由缓冲器是否有到目的节点的路由。如果有，则按此路由发送数据；如果没有，源节点就开始启动路由发现程序。路由发现过程中使用<span style=\"color:red\">洪泛路由</span>（Flooding Routing）。</p>\n<p>当节点 S 需要向节点 D 发送数据，但不知到节点 D 的路由于是节点 S 就开始路由发现过程。源节点 S 洪泛『路由请求』分组 Route Request(RREQ)，每个请求分组通过序列号和源节点 S 标识唯一确定。</p>\n<h5 id=\"路由请求\"><a href=\"#路由请求\" class=\"headerlink\" title=\"路由请求\"></a>路由请求</h5><p>源节点向邻居节点广播路由请求（RREQ）消息，RREQ 的格式及含义如下所示。</p>\n<img src=\"/2020/04/adhoc-routing-protocol/dsr_rreq_format.png\" title=\"RREQ 格式\">\n<p>其中，Sid 为源节点 ID 号，Did 为目的节点 ID 号，Route record 是路由记录，记录了从源节点到目的节点所经过的节点序列，Request ID 为路由请求序列号，由源节点设置。</p>\n<p>当一个节点收到 RREQ 时，如果该节点满足：</p>\n<ol>\n<li>不是目的节点D；</li>\n<li>请求分组头部的源路由序列中不包含该节点；</li>\n<li>没有接收过同样的路由请求分组；</li>\n<li>且路由表中没有目的节点D的路由信息。</li>\n</ol>\n<p>那么<span style=\"color:red\">节点将自己的地址附加到『路由请求』分组头部的 Route record 中，并将该分组转发给所有相邻节点</span>。</p>\n<h5 id=\"重复检测\"><a href=\"#重复检测\" class=\"headerlink\" title=\"重复检测\"></a>重复检测</h5><p>上面提到的第 2、3 点其实就是对 RREQ 重复的检测，这种检测是为了避免路由环路问题。我们再次重复一下这个 RREQ 重复的检测：如果（1）节点接收到的RREQ消息中的 &lt;源节点地址、请求 ID&gt; 存在于本节点的序列对列表中，或者（2）如果节点接收到的RREQ消息中的路由记录中包含本节点的地址，那么我们认为这个 RREQ 是重复的，将它丢弃。</p>\n<h5 id=\"路由应答\"><a href=\"#路由应答\" class=\"headerlink\" title=\"路由应答\"></a>路由应答</h5><p>当 RREQ 分组最终传递到目的节点 D 时，D 会往回发送 RREP 分组，分组的格式如下：</p>\n<img src=\"/2020/04/adhoc-routing-protocol/dsr_rrep_format.png\" title=\"RREP 格式\">\n<p>其中，Did 表示目的节点 ID 或者说是请求路由分组的源节点 ID，Date Route 表示启动路由请求的源节点发送的数据分组要经过的路由（节点序列），而 Reply Route 是路由应答分组 RREP 所要经过的路由（节点序列，不难发现将 Date Route 反向即可）。</p>\n<h5 id=\"获得新路由的方式\"><a href=\"#获得新路由的方式\" class=\"headerlink\" title=\"获得新路由的方式\"></a>获得新路由的方式</h5><p>节点在转发 RREQ 时也会获得到源节点的，如 E 转发来自 C 的 RREQ（A-B-C），它就会获得到 A 的路由（E-C-B-A）。</p>\n<p>节点也会监听相邻节点发送的分组（包括 RREQ，RREP，数据分组），查看需要的路由信息。</p>\n<p>节点转发 RREP 时，获得到目的节点的路径上的所有节点的路由。</p>\n<p>节点转发数据分组时，获得从本节点到源节点的路由。</p>\n<h5 id=\"路由缓存\"><a href=\"#路由缓存\" class=\"headerlink\" title=\"路由缓存\"></a>路由缓存</h5><p>当源节点 S 接到 RREP 分组后，就将 RREP 分组中从源节点 S 到目的节点 D 的路由信息进行缓存；当源节点 S 向目的节点 D 发送数据分组时，此路由信息就包含在每个分组的头部。所有的中间节点利用源路由信息进行分组转发。</p>\n<h4 id=\"4-1-2-路由维护\"><a href=\"#4-1-2-路由维护\" class=\"headerlink\" title=\"4.1.2. 路由维护\"></a>4.1.2. 路由维护</h4><h5 id=\"路由缓存的优化\"><a href=\"#路由缓存的优化\" class=\"headerlink\" title=\"路由缓存的优化\"></a>路由缓存的优化</h5><p>当中间节点的缓存中包含到目的节点的路由时，就由这个中间节点发送 RREP 给源节点，这将缩短路由寻址时间。</p>\n<p>但是，这种优化也会带来问题。</p>\n<h5 id=\"错误路由缓存\"><a href=\"#错误路由缓存\" class=\"headerlink\" title=\"错误路由缓存\"></a>错误路由缓存</h5><p>网络拓扑的变化使得缓存的路由失效。影响和感染其它节点，使用该路由缓存的路由将不可用；当节点根据路由缓存回应 RREP 时，其它监听到此 RREP 的节点会更改自己缓存的路由，从而感染错误路由缓存。对于这种问题，我们可以<span style=\"color:red\">设置缓存路由的有效期，过期删除</span>。</p>\n<h5 id=\"RREP-风暴\"><a href=\"#RREP-风暴\" class=\"headerlink\" title=\"RREP 风暴\"></a>RREP 风暴</h5><p>当某个节点广播某个目的节点的 RREQ 时，当其邻居节点的路由缓存中都有到该目的节点的路由时，每个邻居节点都试图以自己缓存的路由响应，由此造成 RREP 风暴。RREP风暴将浪费网络带宽，并且加剧局部网络冲突。</p>\n<p>为解决这个问题，让所有欲发送 RREP 的节点，先延时 D，再发送。<code>D=H*(h-1+r)</code>，其中 H 是每条链路的传播延时，h 是自己返回的路径长度即到目的节点的跳数，r 是 0 或者 1。可以看到，D 与节点到目的节点的跳数成正比，使得到目的节点的最短路径的 RREP 最先发送。同时，所有的节点都设置成混杂模式，监听是否存在比自己更短的到目的节点的路径，如果有，就不发送本节点的 RREP。</p>\n<h5 id=\"路由故障分组-RERR\"><a href=\"#路由故障分组-RERR\" class=\"headerlink\" title=\"路由故障分组 RERR\"></a>路由故障分组 RERR</h5><p>如果中间节点发现路由表中显示的下一跳节点链路层不可到达，向源节<br>点发送一个RERR。源节点从路由缓冲条目中删除所有不可到达的链路（这条路径的中间节点也利用这个信息更新路由缓冲器） 。源节点将重新启动新的路由发现过程。RERR 的格式如下：</p>\n<img src=\"/2020/04/adhoc-routing-protocol/dsr_rerr_format.png\" title=\"RERR 格式\">\n<p>其中 Node1 表示链路出错的一端节点 ID 号，Node2 是链路出错的另一端节点 ID 号，Did 表示目的节点 ID 或遇到链路出错的数据分组的源节点 ID ，Rerr route 是路由出错分组所要经过的路由（节点序号）。</p>\n<p>下图展示了一个例子，从中我们可以看出 RERR 是如何工作的。</p>\n<img src=\"/2020/04/adhoc-routing-protocol/rerr_example.png\" title=\"RERR 示例\">\n<h4 id=\"4-1-3-DSR-总结\"><a href=\"#4-1-3-DSR-总结\" class=\"headerlink\" title=\"4.1.3. DSR 总结\"></a>4.1.3. DSR 总结</h4><p>从上面的描述中，我们不难发现 DSR 协议的特点，这里再对其进行一个总结，它具有如下优点：</p>\n<ul>\n<li>采用源路由机制、避免了路由环路；</li>\n<li>它是一种按需路由协议，只有当两个节点间进行通信时，才会缓存路由纪录；</li>\n<li>因此相对主动路由来说，减小了路由维护的开销；</li>\n<li>通过采用路由缓存技术，减少路由请求信息对信道的占用。</li>\n</ul>\n<p>虽然 DSR 存在一定的缺陷，但是也有一些解决办法，一并列出来。</p>\n<ul>\n<li>随着路经跳数的增加，分组头长度线性增加、开销大；</li>\n<li>路由请求分组 RREQ 采用洪泛发向全网扩散，导致网络负荷大；</li>\n<li>来自邻居节点的 RREQ 分组在某个节点可能会发生碰撞，解决<br>办法是：在发送 RREQ 分组时引入随机时延；</li>\n<li>当源节点发送路由请求分组 RREQ 时，可能会收到多个节点缓<br>存的到达目的节点的路由信息，引起竞争。解决办法：若某节<br>点听到其它节点发出的 RREQ 分组中路由信息含有较少跳数，<br>此节点停止发送。</li>\n<li>当源节点发送路由请求分组 RREQ 时，可能会收到多个节点缓<br>存的到达目的节点的路由信息，但有些路由信息可能是过时的。解决办法：引入定时器、链路断的情况应进行全网洪泛。</li>\n</ul>\n<h3 id=\"4-2-AODV-协议\"><a href=\"#4-2-AODV-协议\" class=\"headerlink\" title=\"4.2. AODV 协议\"></a>4.2. AODV 协议</h3><p>AODV，Ad Hoc on demand distance vector，按需距离矢量路由协议。</p>\n<p>AODV 在 DSR 的基础上进行了一些改进，在 AODV 中，参与通信过程的节点需要维护路由表，那些不再路径上的节点不保存路由信息，数据分组不需要包含从源到目的节点的路由信息，即采用逐跳转发分组方式。</p>\n<p>AODV路由协议是为Ad hoc网络节点设计的，它提供对动态链路状况的快速自适应、处理开销和存储开销低、路由开销低、确定到达 Ad Hoc 网络内目的节点的单目标传输路由。</p>\n<p>AODV 有四种基本的报文：RREQ（路由请求帧），RREP（路由应答帧），RERR（路由错误帧），HELLO（活跃路由链路监测帧）。</p>\n<h4 id=\"4-2-1-AODV-路由表\"><a href=\"#4-2-1-AODV-路由表\" class=\"headerlink\" title=\"4.2.1 AODV 路由表\"></a>4.2.1 AODV 路由表</h4><p>路由请求发送 RREQ 过程建立反向路由表，转发 RREP 时建立正向路由表，路由维护时更新路由表。路由表主要构成如下：</p>\n<ol>\n<li>目的节点地址 n_dst：用于标志使用此路由的最终目的节点，决定了数据分组转<br> 发方向。</li>\n<li>目的节点序列号 rt_seqno：反映此路由的新鲜度，一般序列号越大路由越新鲜，<br> 这是保证开环的重要措施，在路由发现和路由应答更新路由时需要进行序列号的<br> 比较。</li>\n<li>路由状态标志 rt_flags(有效、无效、正在修复等)：反映此路由目前的状态，主要<br> 用于告知数据分组经过此节点的时候处理方式。</li>\n<li>网络接口 rt_interface：移动节点访问信道的接口</li>\n<li>跳数 rt_hops：到达目的节点所需要的跳数。</li>\n<li>下一跳rt_nexthop：：数据分组经过本节点之后，数据分组将被直接转发的中继<br>节点，通常下一跳节点应该出现在当前节点的邻节点列表中。</li>\n<li>前驱节点列表 rt_pcliSt：使用这条路由的所有直接前驱节点列表。</li>\n<li>路由生命期 rt_expire：路由有效的生命期，在数据分组转发使用当前路由时会更<br>新路由的有效生命期，当较长时间不使用此路由时，此路由的有效期将会过期，<br>在路由管理时将会使路由失效。</li>\n</ol>\n<p>网络中的每个<strong>节点维护自身的序列号</strong>，它表征了路由的新旧。节点在发生路由请求时，会先增加自己的序列号，再发送，发送的 RREQ 中会携带自己的序列号。目的节点只接受最新的序列号，这样一来就可以避免路由环路问题。</p>\n<h4 id=\"4-2-2-路由建立\"><a href=\"#4-2-2-路由建立\" class=\"headerlink\" title=\"4.2.2. 路由建立\"></a>4.2.2. 路由建立</h4><p>简单概括成以下几个过程：</p>\n<ul>\n<li>源节点广播路由请求帧 RREQ；</li>\n<li>中间节点转发 RREQ，转发过程类似 DSR 协议；</li>\n<li>当目标节点接到 RREQ 分组时，它回应 RREP 分组，RREP 沿着方向路径传输。</li>\n</ul>\n<p>源节点 S 打算向目的节点 D 发送一个数据包，在路由表中未查找到能到达D的路由，向其邻居广播 RREQ 分组用于路由发现。为避免节点重复接收处理 RREQ 消息，用源节点和路由请求编号的组合唯一标识一个 RREQ 请求。</p>\n<p>接收到RREQ的节点作如下处理：中间节点更新各自到源节点S的路由表，记录并维护指向源节点的反向路由；设置到源节点路由表的『过时定时器』。</p>\n<p>如果收到 RREQ 的节点不是目的节点，更新 RREQ 分组（将 RREQ中 的信宿序列号设为节点收到的该信宿 D 相关的最大序列号，跳计数加1），并转发更新后的 RREQ 分组。如果在『路由发现定时』内已收到一个具有相同标识的RREQ分组，则抛弃该分组，不作任何处理。</p>\n<p>如果满足如下条件之一，则节点产生 RREP，并单播发送到源节点 S，否则继续广播 RREQ，且表项的序列号大于 RREQ 中的信宿序列号。</p>\n<ul>\n<li>该节点就是目的节点D，；</li>\n<li>节点的路由表中有到目的节点D的活动表项。</li>\n</ul>\n<p>转发 RREP 的中间节点创建『前向路由表』并更新，记录转发路由的下游节点、跳数、生存时间、目的序列号等内容；将跳计数加 1，并根据先前记录的反向路由将 RREP 报文转发给上游节点。上游节点收到RREP后按照相同规则更新路由表并转发 RREP，直至源节点 S。</p>\n<h4 id=\"4-2-3-路由维护\"><a href=\"#4-2-3-路由维护\" class=\"headerlink\" title=\"4.2.3. 路由维护\"></a>4.2.3. 路由维护</h4><p>AODV的路由也同样存在过期问题，因此参与通信的节点，需要维护路由表。通过设一个定时器，当超过设定时间时，则认为路由表中的反向路径信息无效。</p>\n<p>AODV链路状态检测机制，活跃路径节点以HELLO_INTERVAL为周期发送HELLO，用来保持联系，当在设定的时间内，如果没有来自路由表中的前向路径的HELLO，则认为前向路径信息失效（即使路由信息是可用的）。</p>\n<p>与活动路由无关的节点移动，并不影响信源到信宿的寻径。</p>\n<p>如果信源节点移动导致路由不可用，则由信源重新发起路由发现的过程。</p>\n<p>当由于信宿节点或活动路由的中间节点移动等原因导致链路中断链路的『上游节点』主动发送一个 RERR，该 RERR 的信宿序列号大于其所储存的信宿序列号，并传播到所有的邻居，邻居节点会继续转发 RERR 分组。其他节点收到RERR分组后，更新路由表（将包含e的链路设为无效），并继续转发RERR分组。该过程不断重复，直至所有的相关节点被通告到。</p>\n<p>中间节点收到发送到目的节点的数据包时，如果发现到达目的节点的路由失效，该中间节点可以缓存该数据包，并发起到目的节点的路由请求，等待路由重新建立后再据需发送数据包。</p>\n<h4 id=\"4-2-4-AODV-总结\"><a href=\"#4-2-4-AODV-总结\" class=\"headerlink\" title=\"4.2.4. AODV 总结\"></a>4.2.4. AODV 总结</h4><p>优点：传统的距离向量路由机制；支持中间节点应答，能使源节点迅速获得路由，有效减少了广播数，但存在过时路由问题；节点只存储需要的路由，减少了内存的需要和不必要的复制；快速响应路径上的断链，避免路由环路；具有网络的可扩充性；</p>\n<p>缺点是路由建立时延较大。</p>\n<h2 id=\"5-主动路由协议与按需路由协议\"><a href=\"#5-主动路由协议与按需路由协议\" class=\"headerlink\" title=\"5. 主动路由协议与按需路由协议\"></a>5. 主动路由协议与按需路由协议</h2><img src=\"/2020/04/adhoc-routing-protocol/proactive_reactive_route.png\" title=\"主动路由和按需路由\">\n<p>主动路由协议是按路由发现和建立路由方式的角度分类下的一种路由协议，也叫表驱动路由协议，与之相对的是按需路由协议，前面介绍的两种路由协议 OSPF、DSDV 均属于主动路由协议。</p>\n<p>主动路由协议的特点：</p>\n<ul>\n<li>传统的分布式最短路径路由协议，基于链路状态或者距离向量，所有节点连续更新『可达』信息；</li>\n<li>每个节点维护到网络中所有节点的路由；</li>\n<li>所有路由都已经存在并且随时可用；</li>\n<li>路由请求的延迟低；</li>\n<li>路由开销高。</li>\n</ul>\n<p>按需路由特点：</p>\n<ul>\n<li>在源端需要时候通过路由发现过程来确定路由控制信息采用洪泛（flooding）方式，路由请求延迟高，路由开销低；</li>\n<li>两种实现技术：源路由（报文头携带完整的路由信息）和逐跳路由（类似现有的Internet路由）。</li>\n</ul>\n<p>由于他们建立的方式不同，在应对不同的场合他们会有不同的效率表现。主动协议因全程维护所有的路由而具备低延迟；按需协议因只在需要时才发现所需路由而导致高延迟。主动协议因连续更新路由可能导致高开销；按需协议因只在需要时才维护路由而具备低开销。</p>\n<p>具体选择哪种类型的路由取决于业务负载和节点的移动模式（是否频繁移动）。</p>\n","tags":[{"name":"notes","slug":"notes","permalink":"https://jonathan1214.github.io/tags/notes/"},{"name":"Ad-Hoc","slug":"Ad-Hoc","permalink":"https://jonathan1214.github.io/tags/Ad-Hoc/"}]},{"title":"NS2 的介绍（七）—— RED 队列监视示例","date":"2020-04-15T06:15:03.000Z","path":"2020/04/ns2-redQueue-monitor-ex/","text":"本文将展示一个 RED 队列监视示例。下面这段 OTcl 脚本建立了如图所示网络拓扑然后运行模拟场景，可以看到，在 r1 和 r2 间的 link 使用的 RED 队列可以保存至多 25 个 packet，我们通过测量当前队列和平均队列大小的动态变化，以观察 RED 队列是如何工作的。点击下载代码 red.tcl 。 red.tclview raw123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081set ns [new Simulator]set node_(s1) [$ns node]set node_(s2) [$ns node]set node_(r1) [$ns node]set node_(r2) [$ns node]set node_(s3) [$ns node]set node_(s4) [$ns node]$ns duplex-link $node_(s1) $node_(r1) 10Mb 2ms DropTail$ns duplex-link $node_(s2) $node_(r1) 10Mb 3ms DropTail$ns duplex-link $node_(r1) $node_(r2) 1.5Mb 20ms RED$ns queue-limit $node_(r1) $node_(r2) 25$ns queue-limit $node_(r2) $node_(r1) 25$ns duplex-link $node_(s3) $node_(r2) 10Mb 4ms DropTail$ns duplex-link $node_(s4) $node_(r2) 10Mb 5ms DropTail$ns duplex-link-op $node_(s1) $node_(r1) orient right-down$ns duplex-link-op $node_(s2) $node_(r1) orient right-up$ns duplex-link-op $node_(r1) $node_(r2) orient right$ns duplex-link-op $node_(r1) $node_(r2) queuePos 0$ns duplex-link-op $node_(r2) $node_(r1) queuePos 0$ns duplex-link-op $node_(s3) $node_(r2) orient left-down$ns duplex-link-op $node_(s4) $node_(r2) orient left-upset tcp1 [$ns create-connection TCP/Reno $node_(s1) TCPSink $node_(s3) 0]$tcp1 set window_ 15set tcp2 [$ns create-connection TCP/Reno $node_(s2) TCPSink $node_(s3) 1]$tcp2 set window_ 15set ftp1 [$tcp1 attach-source FTP]set ftp2 [$tcp2 attach-source FTP]# Tracing a queueset redq [[$ns link $node_(r1) $node_(r2)] queue]set tchan_ [open all.q w]$redq trace curq_$redq trace ave_$redq attach $tchan_$ns at 0.0 \"$ftp1 start\"$ns at 3.0 \"$ftp2 start\"$ns at 10 \"finish\"# Define 'finish' procedure (include post-simulation processes)proc finish {} { global tchan_ set awkCode { { if ($1 == \"Q\" &amp;&amp; NF&gt;2) { print $2, $3 &gt;&gt; \"temp.q\"; set end $2 } else if ($1 == \"a\" &amp;&amp; NF&gt;2) print $2, $3 &gt;&gt; \"temp.a\"; } } set f [open temp.queue w] puts $f \"TitleText: red\" puts $f \"Device: Postscript\" if { [info exists tchan_] } { close $tchan_ } exec rm -f temp.q temp.a exec touch temp.a temp.q exec awk $awkCode all.q puts $f \\\"queue exec cat temp.q &gt;@ $f puts $f \\n\\\"ave_queue exec cat temp.a &gt;@ $f close $f exec xgraph -bb -tk -x time -y queue temp.queue &amp; exit 0}$ns run 有几件事需要注意。首先，更高级的 Simulator 对象成员函数 create-connection 被用于创建 TCP 连接。其次，仔细观察代码中的队列跟踪部分，可以发现我们创建了一个指向 RED 队列对象的变量，调用它的成员函数 trace 监视当前队列大小（cur_q）和平均队列大小（avg_），然后把结果写入文件 all.q 中。 运行结果： 参考：WPI","content":"<p>本文将展示一个 RED 队列监视示例。下面这段 OTcl 脚本建立了如图所示网络拓扑然后运行模拟场景，可以看到，在 r1 和 r2 间的 link 使用的 RED 队列可以保存至多 25 个 packet，我们通过测量当前队列和平均队列大小的动态变化，以观察 RED 队列是如何工作的。点击下载代码<a href=\"/downloads/code/red.tcl\"> red.tcl </a>。<a id=\"more\"></a></p>\n<img src=\"/2020/04/ns2-redQueue-monitor-ex/red_queue_monitor_setup.png\" title=\"网络设置\">\n<figure class=\"highlight tcl\"><figcaption><span>red.tcl</span><a href=\"/downloads/code/red.tcl\">view raw</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">set</span> ns [new Simulator]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">set</span> node_(s1) [$ns node]</span><br><span class=\"line\"><span class=\"keyword\">set</span> node_(s2) [$ns node]</span><br><span class=\"line\"><span class=\"keyword\">set</span> node_(r1) [$ns node]</span><br><span class=\"line\"><span class=\"keyword\">set</span> node_(r2) [$ns node]</span><br><span class=\"line\"><span class=\"keyword\">set</span> node_(s3) [$ns node]</span><br><span class=\"line\"><span class=\"keyword\">set</span> node_(s4) [$ns node]</span><br><span class=\"line\"></span><br><span class=\"line\">$ns duplex-link $node_(s1) $node_(r1) <span class=\"number\">10</span>Mb <span class=\"number\">2</span>ms DropTail</span><br><span class=\"line\">$ns duplex-link $node_(s2) $node_(r1) <span class=\"number\">10</span>Mb <span class=\"number\">3</span>ms DropTail</span><br><span class=\"line\">$ns duplex-link $node_(r1) $node_(r2) <span class=\"number\">1.5</span>Mb <span class=\"number\">20</span>ms RED</span><br><span class=\"line\">$ns queue-limit $node_(r1) $node_(r2) <span class=\"number\">25</span></span><br><span class=\"line\">$ns queue-limit $node_(r2) $node_(r1) <span class=\"number\">25</span></span><br><span class=\"line\">$ns duplex-link $node_(s3) $node_(r2) <span class=\"number\">10</span>Mb <span class=\"number\">4</span>ms DropTail</span><br><span class=\"line\">$ns duplex-link $node_(s4) $node_(r2) <span class=\"number\">10</span>Mb <span class=\"number\">5</span>ms DropTail</span><br><span class=\"line\"></span><br><span class=\"line\">$ns duplex-link-op $node_(s1) $node_(r1) orient right-down</span><br><span class=\"line\">$ns duplex-link-op $node_(s2) $node_(r1) orient right-up</span><br><span class=\"line\">$ns duplex-link-op $node_(r1) $node_(r2) orient right</span><br><span class=\"line\"></span><br><span class=\"line\">$ns duplex-link-op $node_(r1) $node_(r2) queuePos <span class=\"number\">0</span></span><br><span class=\"line\">$ns duplex-link-op $node_(r2) $node_(r1) queuePos <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ns duplex-link-op $node_(s3) $node_(r2) orient left-down</span><br><span class=\"line\">$ns duplex-link-op $node_(s4) $node_(r2) orient left-up</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">set</span> tcp1 [$ns create-connection TCP/Reno $node_(s1) TCPSink $node_(s3) <span class=\"number\">0</span>]</span><br><span class=\"line\">$tcp1 <span class=\"keyword\">set</span> window_ <span class=\"number\">15</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> tcp2 [$ns create-connection TCP/Reno $node_(s2) TCPSink $node_(s3) <span class=\"number\">1</span>]</span><br><span class=\"line\">$tcp2 <span class=\"keyword\">set</span> window_ <span class=\"number\">15</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> ftp1 [$tcp1 attach-<span class=\"keyword\">source</span> FTP]</span><br><span class=\"line\"><span class=\"keyword\">set</span> ftp2 [$tcp2 attach-<span class=\"keyword\">source</span> FTP]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Tracing a queue</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> redq [[$ns link $node_(r1) $node_(r2)] queue]</span><br><span class=\"line\"><span class=\"keyword\">set</span> tchan_ [<span class=\"keyword\">open</span> all.q w]</span><br><span class=\"line\">$redq <span class=\"keyword\">trace</span> curq_</span><br><span class=\"line\">$redq <span class=\"keyword\">trace</span> ave_</span><br><span class=\"line\">$redq attach $tchan_</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">$ns at <span class=\"number\">0.0</span> <span class=\"string\">\"$ftp1 start\"</span></span><br><span class=\"line\">$ns at <span class=\"number\">3.0</span> <span class=\"string\">\"$ftp2 start\"</span></span><br><span class=\"line\">$ns at <span class=\"number\">10</span> <span class=\"string\">\"finish\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Define 'finish' procedure (include post-simulation processes)</span></span><br><span class=\"line\"><span class=\"keyword\">proc</span><span class=\"title\"> finish</span> {} {</span><br><span class=\"line\">    <span class=\"keyword\">global</span> tchan_</span><br><span class=\"line\">    <span class=\"keyword\">set</span> awkCode {</span><br><span class=\"line\">    {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ($<span class=\"number\">1</span> == <span class=\"string\">\"Q\"</span> &amp;&amp; NF&gt;<span class=\"number\">2</span>) {</span><br><span class=\"line\">        print $<span class=\"number\">2</span>, $<span class=\"number\">3</span> &gt;&gt; <span class=\"string\">\"temp.q\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">set</span> end $<span class=\"number\">2</span></span><br><span class=\"line\">        }</span><br><span class=\"line\">        else <span class=\"keyword\">if</span> ($<span class=\"number\">1</span> == <span class=\"string\">\"a\"</span> &amp;&amp; NF&gt;<span class=\"number\">2</span>)</span><br><span class=\"line\">        print $<span class=\"number\">2</span>, $<span class=\"number\">3</span> &gt;&gt; <span class=\"string\">\"temp.a\"</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">set</span> f [<span class=\"keyword\">open</span> temp.queue w]</span><br><span class=\"line\">    <span class=\"keyword\">puts</span> $f <span class=\"string\">\"TitleText: red\"</span></span><br><span class=\"line\">    <span class=\"keyword\">puts</span> $f <span class=\"string\">\"Device: Postscript\"</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> { [<span class=\"keyword\">info</span> exists tchan_] } {</span><br><span class=\"line\">    <span class=\"keyword\">close</span> $tchan_</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">exec</span> rm -f temp.q temp.a </span><br><span class=\"line\">    <span class=\"keyword\">exec</span> touch temp.a temp.q</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">exec</span> awk $awkCode all.q</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">puts</span> $f \\<span class=\"string\">\"queue</span></span><br><span class=\"line\"><span class=\"string\">    exec cat temp.q &gt;@ $f  </span></span><br><span class=\"line\"><span class=\"string\">    puts $f \\n\\\"ave_queue</span></span><br><span class=\"line\"><span class=\"string\">    exec cat temp.a &gt;@ $f</span></span><br><span class=\"line\"><span class=\"string\">    close $f</span></span><br><span class=\"line\"><span class=\"string\">    exec xgraph -bb -tk -x time -y queue temp.queue &amp;</span></span><br><span class=\"line\"><span class=\"string\">    exit 0</span></span><br><span class=\"line\"><span class=\"string\">}</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">$ns run</span></span><br></pre></td></tr></table></figure>\n<p>有几件事需要注意。首先，更高级的 Simulator 对象成员函数 <code>create-connection</code> 被用于创建 TCP 连接。其次，仔细观察代码中的队列跟踪部分，可以发现我们创建了一个指向 RED 队列对象的变量，调用它的成员函数 <code>trace</code> 监视当前队列大小（cur_q）和平均队列大小（avg_），然后把结果写入文件 <code>all.q</code> 中。</p>\n<p>运行结果：<br><img src=\"/2020/04/ns2-redQueue-monitor-ex/result.png\" title=\"运行结果\"></p>\n<hr>\n<p>参考：<a href=\"http://nile.wpi.edu.cn/NS/\" target=\"_blank\" rel=\"noopener\">WPI</a></p>\n","tags":[{"name":"网络","slug":"网络","permalink":"https://jonathan1214.github.io/tags/网络/"},{"name":"NS2","slug":"NS2","permalink":"https://jonathan1214.github.io/tags/NS2/"}]},{"title":"算法笔记 —— 图","date":"2020-04-10T03:03:42.000Z","path":"2020/04/algorithm-map/","text":"在许多计算机应用中，由相连的结点所表示的模型起到了关键的作用。这些结点之间的连接很自然地会让人们产生一连串的疑问：沿着这些连接能否从一个结点到达另一个结点？有多少个结点和指定的结点相连？两个结点之间最短的连接是哪一条？要描述这些问题，我们要使用一种抽象的数学对象，叫做图。 1. 无向图无向图的定义：无向图是由一组顶点和一组能够将两个顶点相连的边组成的。在无向图中，边（edge）仅仅是两个顶点（vertex）间的连接。根据这个定义，顶点叫什么名字无关紧要，我们使用 0 到 V-1 来表示一张含有 V 个顶点的图中的各个顶点，这样的表示便于使用数组的索引来访问各个结点，我们可以直接用数组的索引作为结点的名称，事实上如果顶点不符合我们的预设，我们也可以把它们映射到 0 到 V-1 上来。 在这个定义下，允许出现下面两种特殊情况： 自环：即一条连接一个顶点和其自身的边； 连接同一对顶点的两条边称为平行边。 1.1. 一些术语这里先介绍一些关于图的术语。 相邻：两个顶点通过用一条边相连，称两个顶点相邻，边依附于这两个顶点； 度数：顶点的度数为依附于它的边的总数； 子图：一幅图的所有边的一个子集（包括所依附的结点）组成的图； 路径：由边顺序连接的一系列顶点，简单路径没有重复顶点； 连通图：从任意一个顶点都存在一条路径到达另一个任意顶点； 树：树是一副无环连通图，互不相连的树组成的集合称为森林；当且仅当一幅含有 V 个结点的图 G 满足下列 5 个条件之一时，它就是一棵树： G 有 V-1 条边且不含有环； G 有 V-1 条边且是连通的； G 是连通的，但删除任意一条边都会使它不再连通； G 是无环图，但添加任意一条边都会产生一条环； G 中的任意一对顶点之间仅存在一条简单路径。 稠密图与稀疏图： 二分图：可将所有结点分为两部分，其中图的每条边所接的两个顶点术语不用的部分； 1.2. 无向图的表示对于一个顶点数为 V，边数为 E 的无向图，我们可以用以下几种方式表示： 邻接矩阵：使用 V 乘 V 的布尔矩阵，顶点 v 和 w 间存在连接时，则矩阵的 v 行 w 列和 w 行 v 列置为 true； 边的数组： 邻接表数组：使用一个以顶点为索引的列表数组，其中每个元素都是和该顶点相邻的顶点列表。 我们使用 邻接表 表示非稠密图，它将每个顶点的所有相邻顶点都保存在该顶点对应的元素所指向的一张链表中，使用这个数组可以快速访问给定顶点的邻接顶点列表。用这种表示方法，使用的空间和 V+E 成正比；添加一条边所需的时间为常数；遍历顶点 v 的所有相邻顶点所需的时间和 v 的度数成正比。 1.3. 深度优先搜索 DFS我们可以通过系统地检查每一个顶点和每一条边来获取图的各种性质，在此基础上获得一些我们感兴趣的东西。在图中，很多性质是和路径相关的，我们经常需要从一个顶点移动到另一个顶点。许多图算法的抽象模型都非常简单，比如 DFS。 在讲 DFS 之前，让我们先来看看走迷宫问题，迷宫和图是非常相似的，用通道代替边，路口代替顶点，思考迷宫问题有助于我们理解 DFS。我们按照如下策略探索迷宫中的所有通道： 选择一条没有标记过的通道，在你走过的路上铺一条绳子； 标记所有你第一次路过的路口和通道； 当来到一个标记过的路口时（用绳子）回退到上个路口； 当回退到的路口已没有可走的通道时继续回退。 绳子可以保证我们总能找到一条出路，标记保证我们不会两次经过同一个通道或路口。理解迷宫问题，对于 DFS 自然也就不在话下了，甚至描述起来更加简单： 访问当前顶点，标记其标记已访问； 递归地访问它所有没有被标记过的所有邻居顶点。 这就是 DFS 的全部思路了，很容易发现在递归调用中我们使用了栈这种数据结构，这对我们标记顶点而言，是 LIFO 的，这是 DFS 和 BFS 的不同之处，BFS 是 FIFO 的，我们马上会讲到 BFS。 DFS 可以有效处理许多和图有关的任务，如： 连通性：给定两个顶点是否连通； 单点路径：从 s 到 v 是否存在一条路径。 其实这是同一个问题，只不过路径问题需要使用额外的数组保存遍历过的路径而已，这样我们就可以从某一顶点出发构造出一棵树，树中所有结点均是该顶点可到达的。 1.4. 广度优先搜索 BFS基于 DFS，我们可以确定到某一结点的是否存在路径，很自然的地我们会考虑这是不是最短路径，如果不是有没有别的办法寻找到最短路径。这正是 BFS 要解决的问题，BFS 是很多图算法的基石，需要重点掌握。而 DFS 无法解决这个问题，这是由它们遍历图的顺序决定的。如上面提到的，在 DFS 中，我们使用一个下压栈（递归方法体现了出来），在这种 LIFO 的规则下的探索和走迷宫探索相邻的通道非常类似。在 BFS 中，我们希望按照距离起点的距离的顺序来遍历所有的顶点，使用 FIFO 队列代替 LIFO 栈即可：重复以下步骤直到队列为空： 取队列中的下一个顶点 v 并标记它； 将与 v 相邻的所有未被标记过的顶点加入队列。 同时，我们还可以使用一个数组保存遍历的路径，索引是顶点，数组的值为该顶点的已知路径上的最后一个顶点。 1.5. DFS 和 BFS 的总结如同前面谈到的，DFS 和 BFS 的基本思路是一样的。在搜索中，我们先将起点存入数据结构中，然后重复以下步骤直到数据被清空： 取其中的下一个顶点并标记它； 将 v 的所有相邻而又未被标记的顶点加入数据结构。 两个算法的不同之处仅仅在于从数据结构中获取下一个顶点的规则不同，BFS 是最早加入的顶点，DFS 是最晚加入的顶点。这种差异得到了处理图的两种完全不同的视角，无论如何，最早我们都可以遍历所有与起点连通的顶点和边。 1.6. 更多问题有了 DFS 和 BFS 两种策略，我们可以处理更多问题： 连通分量； 检测环； 双色问题。 2. 有向图定义：有向图是由一组顶点和有方向的边的组成，每条有方向的边都连接着有序的一对顶点。 2.1. 有向图的表示这里先给出有向图的一些术语。 顶点的出度：该顶点指向的边的总数； 顶点的入度：指向该顶点的边的总数； 有向边的头：它的第一个顶点； 有向边的尾：它的第二个顶点； 有向路径：由一些列顶点组成，每个顶点都存在一条有向边从它指向序列中下一个顶点； 有向环：一条至少含有一条边且起点和终点相同的有向路径； 简单有向环：一条（除了起点和终点必须相同之外）不含有重复的顶点和边的环； v 能够到达 w：v 到 w 存在有向路径（注意：这并不意味着从 w 可以达到 v）。 有向图的表示和无向图类似，我们仍然可以使用邻接表数组来表示有向图，甚至更加简单，因为边是单向的，只需保存一个相邻结点。数组索引为某个顶点，索引下的邻接表为该顶点所指向的顶点构成的链表。 2.2. 可达性问题在无向图中我们处理过单点连通性问题，即判断其他顶点和给定的顶点是否连通，而在有向图中，也可以解决类似的问题，而且思路非常相似。 单点可达性：给定一副有向图和起点 s，是否存在一条从 s 到达给定顶点 v 的有向图； 多点可达性：给定一副图和顶点的集合，是否存在一条从集合中的任意顶点到达给定顶点 v 的路径。 解决这个问题的算法是基于 DFS 的，稍作修改即可： 121. 访问当前顶点，标记为已访问；2. 递归地访问它所谓未被标记过的顶点。 在此基础上，稍作修改我们就可以跟进一步地求出起点 s 和 终点 v 之间的路径或最短路径，算法和无向图中的完全一样。 2.3. 环和有向无环图对于有向图中环进行研究可以解决很多问题，如 优先级限制下调度问题：给定一组需要完成的任务，以及一组关于任务完成的先后次序的优先级限制。在满足限制条件的前提下应该如何安排并完成所有任务？ 拓扑排序：给定一幅有向图，将所有的顶点排序，使得所有的有向边均从排在前面的元素指向排在后面的元素（或者说明无法做到这一点）。 为什么说环和这些问题是相关的呢？举个例子，考虑一个调度问题：A 必须在 B 之前完成，B 必须在 C 之前完成，C 又必须在 A 之前完成。这显然是不可能实现的，这在有向图就构成了一个环。处理这些调度问题我们必须对图中的环进行检测。 有向无环图（DAG）就是一副不含有环的有向图。实现有向图中的环检测算法并不困难，我们可以基于 DFS 来解决这个问题。系统维护的递归调用栈表示的正是『当前』正在遍历的有向路径，一旦我们找到了一条有向边 v –&gt; w 且 w 已经在栈中，就找到了一个环，如果没有，那就说明这是无环图。如果更进一步，多加一个栈，我们就可以找出构成环的顶点。 DAG 检测算法1234561. 访问当前顶点，标记为已访问，标记为在当前搜索的路径的栈中2. 对当前顶点指向的顶点 如果未被标记，将其来源标记当前顶点，为其跳转到 1 如果在栈中，说明图中存在环 记录环到另一个栈中3. 当前顶点调用完毕，标记为不在当前搜索的路径的栈中 可以看到这个无向图中 DFS 路径搜索算法是类似的，这再次说明了 DFS 的重要性。 拓扑排序同样的，拓扑排序也是基于 DFS 的，只需稍作修改就可以实现拓扑排序。DFS 正好只会访问每个顶点一次，如果将递归调用函数 dfs 的参数顶点保存在一个数据结构中，遍历这个数据结构实际上就能访问图中的所有顶点，遍历的顺序取决于这个数据结构的性质以及是在递归调用之前还是之后进行保存。我们关心下面三种顺序： 前序：在递归调用之前将顶点加入队列。 后序：在递归调用之后将顶点加入队列。 逆后序：在递归调用之后将顶点压入栈。 可以证明，一幅有向无环图的拓扑顺序即为所有顶点的逆后续排列。 我们可以看到，拓扑排序和调度问题离不开有向环的检测，而且这两个问题可以看作是一个问题。在调度时，必须保证有向图中没有环，因此，解决任务调度类应用通常需要以下3 步： 指明任务和优先级条件； 不断检测并去除有向图中的所有环，以确保存在可行的方案； 使用拓扑排序解决调度问题。 2.4. 强连通性类似无向图中的连通性，我们在有向图中定义了强连通性：在有向图 G 中，如果两个顶点 v 和 w 是互相可达的，则称它们是强连通的。联想到环的定义，我们很容易想到两个顶点是强连通的等价于它们在同一个有向环中。 有向图中的强连通性也是一种顶点之间的等价关系，满足以下性质： 自反性：任意顶点 v 和自己都是强连通的。 对称性：如果 v 和 w 是强连通的，那么 w 和 v 也是强连通的。 传递性：如果 v 和 w 是强连通的且 w 和 x 也是强连通的，那么 v 和 x 也是强连通的。 强连通性将所有的顶点分为两一些等价类，每个等价类都是由相互均为强连通的顶点的最大子集组成的，我们称这些子集为强连通分量。对于理解有向图的结构，强连通性是一种非常重要的抽象，它突出了相互关联的几组顶点，如可以帮助决定话题分类和理解食物链中的能量流动问题。 对于强连通分量问题，我们可以使用 Kosaraju 算法来解决，本质上这个算法还是基于 DFS 的， 首先对 G 进行反转，即改变所有边的指向和原来相反，得到图 H； 然后对 H 进行逆后序排列； 按照这个排列顺序对 G 中的顶点调用标准 DFS，每一次非标记的顶点遍历完表示做完了一个强连通分量的搜索。 举个例子，如上图所示。证明如下： 3. 最小生成树加权图是为每条边关联一个权值或是成本的图模型。这种图能够自然地表示许多应用。在一幅电路图中，边表示导线，权值则可能表示导线的长度即成本，或是信号通过这条线路所需的时间。在这些情形中，最令人感兴趣的自然是将成本最小化。我们将学习加权无向图模型并用算法回答这个问题。 最小生成树：给定一副加权无向图，找到它的一棵最小生成树。 在解决这个问题之前，我们需要对之前的数据结构进行一些改变。 3.1. Prim 算法这是一种得到加权无向图的有效算法，基本思想如下： 将一个节点加入队列，将它的所有邻边加入队列 3.2. Kruskal 算法4. 最短路径","content":"<p>在许多计算机应用中，由相连的结点所表示的模型起到了关键的作用。这些结点之间的连接很自然地会让人们产生一连串的疑问：沿着这些连接能否从一个结点到达另一个结点？有多少个结点和指定的结点相连？两个结点之间最短的连接是哪一条？要描述这些问题，我们要使用一种抽象的数学对象，叫做图。<br><a id=\"more\"></a></p>\n<h2 id=\"1-无向图\"><a href=\"#1-无向图\" class=\"headerlink\" title=\"1. 无向图\"></a>1. 无向图</h2><p><em>无向图的定义</em>：无向图是由一组顶点和一组能够将两个顶点相连的边组成的。在无向图中，边（edge）仅仅是两个顶点（vertex）间的连接。根据这个定义，顶点叫什么名字无关紧要，我们使用 0 到 V-1 来表示一张含有 V 个顶点的图中的各个顶点，这样的表示便于使用数组的索引来访问各个结点，我们可以直接用数组的索引作为结点的名称，事实上如果顶点不符合我们的预设，我们也可以把它们映射到 0 到 V-1 上来。</p>\n<p>在这个定义下，允许出现下面两种特殊情况：</p>\n<ul>\n<li>自环：即一条连接一个顶点和其自身的边；</li>\n<li>连接同一对顶点的两条边称为平行边。</li>\n</ul>\n<h3 id=\"1-1-一些术语\"><a href=\"#1-1-一些术语\" class=\"headerlink\" title=\"1.1. 一些术语\"></a>1.1. 一些术语</h3><p>这里先介绍一些关于图的术语。</p>\n<ul>\n<li>相邻：两个顶点通过用一条边相连，称两个顶点<em>相邻</em>，边<em>依附于</em>这两个顶点；</li>\n<li>度数：顶点的度数为依附于它的边的总数；</li>\n<li>子图：一幅图的所有边的一个子集（包括所依附的结点）组成的图；</li>\n<li>路径：由边顺序连接的一系列顶点，简单路径没有重复顶点；</li>\n<li>连通图：从任意一个顶点都存在一条路径到达另一个任意顶点；</li>\n<li>树：树是一副无环连通图，互不相连的树组成的集合称为森林；当且仅当一幅含有 V 个结点的图 G 满足下列 5 个条件之一时，它就是一棵树：<ul>\n<li>G 有 V-1 条边且不含有环；</li>\n<li>G 有 V-1 条边且是连通的；</li>\n<li>G 是连通的，但删除任意一条边都会使它不再连通；</li>\n<li>G 是无环图，但添加任意一条边都会产生一条环；</li>\n<li>G 中的任意一对顶点之间仅存在一条简单路径。</li>\n</ul>\n</li>\n<li>稠密图与稀疏图：</li>\n<li>二分图：可将所有结点分为两部分，其中图的每条边所接的两个顶点术语不用的部分；</li>\n</ul>\n<h3 id=\"1-2-无向图的表示\"><a href=\"#1-2-无向图的表示\" class=\"headerlink\" title=\"1.2. 无向图的表示\"></a>1.2. 无向图的表示</h3><p>对于一个顶点数为 V，边数为 E 的无向图，我们可以用以下几种方式表示：</p>\n<ul>\n<li>邻接矩阵：使用 V 乘 V 的布尔矩阵，顶点 v 和 w 间存在连接时，则矩阵的 v 行 w 列和 w 行 v 列置为 true；</li>\n<li>边的数组：</li>\n<li>邻接表数组：使用一个以顶点为索引的列表数组，其中每个元素都是和该顶点相邻的顶点列表。</li>\n</ul>\n<img src=\"/2020/04/algorithm-map/adjacency_list.png\" title=\"邻接表\">\n<p>我们使用 <em>邻接表</em> 表示非稠密图，它将每个顶点的所有相邻顶点都保存在该顶点对应的元素所指向的一张链表中，使用这个数组可以快速访问给定顶点的邻接顶点列表。用这种表示方法，使用的空间和 V+E 成正比；添加一条边所需的时间为常数；遍历顶点 v 的所有相邻顶点所需的时间和 v 的度数成正比。</p>\n<h3 id=\"1-3-深度优先搜索-DFS\"><a href=\"#1-3-深度优先搜索-DFS\" class=\"headerlink\" title=\"1.3. 深度优先搜索 DFS\"></a>1.3. 深度优先搜索 DFS</h3><p>我们可以通过系统地检查每一个顶点和每一条边来获取图的各种性质，在此基础上获得一些我们感兴趣的东西。在图中，很多性质是和路径相关的，我们经常需要从一个顶点移动到另一个顶点。许多图算法的抽象模型都非常简单，比如 DFS。</p>\n<p>在讲 DFS 之前，让我们先来看看走迷宫问题，迷宫和图是非常相似的，用<em>通道</em>代替<em>边</em>，<em>路口</em>代替<em>顶点</em>，思考迷宫问题有助于我们理解 DFS。我们按照如下策略探索迷宫中的所有通道：</p>\n<ul>\n<li>选择一条没有标记过的通道，在你走过的路上铺一条<br>绳子；</li>\n<li>标记所有你第一次路过的路口和通道；</li>\n<li>当来到一个标记过的路口时（用绳子）回退到上个路口；</li>\n<li>当回退到的路口已没有可走的通道时继续回退。</li>\n</ul>\n<p>绳子可以保证我们总能找到一条出路，标记保证我们不会两次经过同一个通道或路口。理解迷宫问题，对于 DFS 自然也就不在话下了，甚至描述起来更加简单：</p>\n<ul>\n<li>访问当前顶点，标记其标记已访问；</li>\n<li>递归地访问它所有没有被标记过的所有邻居顶点。</li>\n</ul>\n<p>这就是 DFS 的全部思路了，很容易发现在递归调用中我们使用了栈这种数据结构，这对我们标记顶点而言，是 LIFO 的，这是 DFS 和 BFS 的不同之处，BFS 是 FIFO 的，我们马上会讲到 BFS。</p>\n<p>DFS 可以有效处理许多和图有关的任务，如：</p>\n<ul>\n<li>连通性：给定两个顶点是否连通；</li>\n<li>单点路径：从 s 到 v 是否存在一条路径。</li>\n</ul>\n<p>其实这是同一个问题，只不过路径问题需要使用额外的数组保存遍历过的路径而已，这样我们就可以从某一顶点出发构造出一棵树，树中所有结点均是该顶点可到达的。</p>\n<h3 id=\"1-4-广度优先搜索-BFS\"><a href=\"#1-4-广度优先搜索-BFS\" class=\"headerlink\" title=\"1.4. 广度优先搜索 BFS\"></a>1.4. 广度优先搜索 BFS</h3><p>基于 DFS，我们可以确定到某一结点的是否存在路径，很自然的地我们会考虑这是不是最短路径，如果不是有没有别的办法寻找到最短路径。这正是 BFS 要解决的问题，<strong>BFS 是很多图算法的基石，需要重点掌握</strong>。而 DFS 无法解决这个问题，这是由它们遍历图的顺序决定的。如上面提到的，在 DFS 中，我们使用一个下压栈（递归方法体现了出来），在这种 LIFO 的规则下的探索和走迷宫探索相邻的通道非常类似。在 BFS 中，我们希望按照距离起点的距离的顺序来遍历所有的顶点，使用 FIFO 队列代替 LIFO 栈即可：<br>重复以下步骤直到队列为空：</p>\n<ul>\n<li>取队列中的下一个顶点 v 并标记它；</li>\n<li>将与 v 相邻的所有未被标记过的顶点加入队列。</li>\n</ul>\n<p>同时，我们还可以使用一个数组保存遍历的路径，索引是顶点，数组的值为该顶点的已知路径上的最后一个顶点。</p>\n<h3 id=\"1-5-DFS-和-BFS-的总结\"><a href=\"#1-5-DFS-和-BFS-的总结\" class=\"headerlink\" title=\"1.5. DFS 和 BFS 的总结\"></a>1.5. DFS 和 BFS 的总结</h3><p>如同前面谈到的，DFS 和 BFS 的基本思路是一样的。在搜索中，我们先将起点存入数据结构中，然后重复以下步骤直到数据被清空：</p>\n<ul>\n<li>取其中的下一个顶点并标记它；</li>\n<li>将 v 的所有相邻而又未被标记的顶点加入数据结构。</li>\n</ul>\n<p>两个算法的不同之处仅仅在于从数据结构中获取下一个顶点的规则不同，BFS 是最早加入的顶点，DFS 是最晚加入的顶点。这种差异得到了处理图的两种完全不同的视角，无论如何，最早我们都可以遍历所有与起点连通的顶点和边。</p>\n<h3 id=\"1-6-更多问题\"><a href=\"#1-6-更多问题\" class=\"headerlink\" title=\"1.6. 更多问题\"></a>1.6. 更多问题</h3><p>有了 DFS 和 BFS 两种策略，我们可以处理更多问题：</p>\n<ul>\n<li>连通分量；</li>\n<li>检测环；</li>\n<li>双色问题。</li>\n</ul>\n<h2 id=\"2-有向图\"><a href=\"#2-有向图\" class=\"headerlink\" title=\"2. 有向图\"></a>2. 有向图</h2><p><strong>定义</strong>：有向图是由一组<em>顶点</em>和有方向的边的组成，每条有方向的边都连接着有序的一对顶点。</p>\n<img src=\"/2020/04/algorithm-map/directional_graph.png\" title=\"有向图\">\n<h3 id=\"2-1-有向图的表示\"><a href=\"#2-1-有向图的表示\" class=\"headerlink\" title=\"2.1. 有向图的表示\"></a>2.1. 有向图的表示</h3><p>这里先给出有向图的一些术语。</p>\n<ul>\n<li>顶点的出度：该顶点指向的边的总数；</li>\n<li>顶点的入度：指向该顶点的边的总数；</li>\n<li>有向边的头：它的第一个顶点；</li>\n<li>有向边的尾：它的第二个顶点；</li>\n<li>有向路径：由一些列顶点组成，每个顶点都存在一条有向边从它指向序列中下一个顶点；</li>\n<li>有向环：一条至少含有一条边且起点和终点相同的有向路径；</li>\n<li>简单有向环：一条（除了起点和终点必须相同之外）不含有重复的顶点和边的环；</li>\n<li>v 能够到达 w：v 到 w 存在有向路径（注意：这并不意味着从 w 可以达到 v）。</li>\n</ul>\n<p>有向图的表示和无向图类似，我们仍然可以使用邻接表数组来表示有向图，甚至更加简单，因为边是单向的，只需保存一个相邻结点。数组索引为某个顶点，索引下的邻接表为该顶点所指向的顶点构成的链表。</p>\n<h3 id=\"2-2-可达性问题\"><a href=\"#2-2-可达性问题\" class=\"headerlink\" title=\"2.2. 可达性问题\"></a>2.2. 可达性问题</h3><p>在无向图中我们处理过单点连通性问题，即判断其他顶点和给定的顶点是否连通，而在有向图中，也可以解决类似的问题，而且思路非常相似。</p>\n<ul>\n<li>单点可达性：给定一副有向图和起点 s，是否存在一条从 s 到达给定顶点 v 的有向图；</li>\n<li>多点可达性：给定一副图和顶点的集合，是否存在一条从集合中的任意顶点到达给定顶点 v 的路径。</li>\n</ul>\n<p>解决这个问题的算法是基于 DFS 的，稍作修改即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 访问当前顶点，标记为已访问；</span><br><span class=\"line\">2. 递归地访问它所谓未被标记过的顶点。</span><br></pre></td></tr></table></figure>\n<p>在此基础上，稍作修改我们就可以跟进一步地求出起点 s 和 终点 v 之间的路径或最短路径，算法和无向图中的完全一样。</p>\n<h3 id=\"2-3-环和有向无环图\"><a href=\"#2-3-环和有向无环图\" class=\"headerlink\" title=\"2.3. 环和有向无环图\"></a>2.3. 环和有向无环图</h3><p>对于有向图中环进行研究可以解决很多问题，如</p>\n<ul>\n<li><em>优先级限制下调度问题</em>：给定一组需要完成的任务，以及一组关于任务完成的先后次序的优先级限制。在满足限制条件的前提下应该如何安排并完成所有任务？</li>\n<li><em>拓扑排序</em>：给定一幅有向图，将所有的顶点排序，使得所有的有向边均从排在前面的元素指向排在后面的元素（或者说明无法做到这一点）。</li>\n</ul>\n<p>为什么说环和这些问题是相关的呢？举个例子，考虑一个调度问题：A 必须在 B 之前完成，B 必须在 C 之前完成，C 又必须在 A 之前完成。这显然是不可能实现的，这在有向图就构成了一个环。处理这些调度问题我们必须对图中的环进行检测。</p>\n<img src=\"/2020/04/algorithm-map/managment_and_loop.png\" title=\"调度问题与有向图中的环\">\n<p>有向无环图（DAG）就是一副不含有环的有向图。实现有向图中的环检测算法并不困难，我们可以基于 DFS 来解决这个问题。系统维护的递归调用栈表示的正是『当前』正在遍历的有向路径，一旦我们找到了一条有向边 v –&gt; w 且 w 已经在栈中，就找到了一个环，如果没有，那就说明这是无环图。如果更进一步，多加一个栈，我们就可以找出构成环的顶点。</p>\n<h4 id=\"DAG-检测算法\"><a href=\"#DAG-检测算法\" class=\"headerlink\" title=\"DAG 检测算法\"></a>DAG 检测算法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 访问当前顶点，标记为已访问，标记为在当前搜索的路径的栈中</span><br><span class=\"line\">2. 对当前顶点指向的顶点</span><br><span class=\"line\">    如果未被标记，将其来源标记当前顶点，为其跳转到 1</span><br><span class=\"line\">    如果在栈中，说明图中存在环</span><br><span class=\"line\">    记录环到另一个栈中</span><br><span class=\"line\">3. 当前顶点调用完毕，标记为不在当前搜索的路径的栈中</span><br></pre></td></tr></table></figure>\n<p>可以看到这个无向图中 DFS 路径搜索算法是类似的，这再次说明了 DFS 的重要性。</p>\n<h4 id=\"拓扑排序\"><a href=\"#拓扑排序\" class=\"headerlink\" title=\"拓扑排序\"></a>拓扑排序</h4><p>同样的，拓扑排序也是基于 DFS 的，只需稍作修改就可以实现拓扑排序。DFS 正好只会访问每个顶点一次，如果将递归调用函数 <code>dfs</code> 的参数顶点保存在一个数据结构中，遍历这个数据结构实际上就能访问图中的所有顶点，遍历的顺序取决于这个数据结构的性质以及是在递归调用之前还是之后进行保存。我们关心下面三种顺序：</p>\n<ul>\n<li>前序：在递归调用之前将顶点加入队列。</li>\n<li>后序：在递归调用之后将顶点加入队列。</li>\n<li>逆后序：在递归调用之后将顶点压入栈。</li>\n</ul>\n<p>可以证明，一幅有向无环图的拓扑顺序即为所有顶点的逆后续排列。</p>\n<p>我们可以看到，拓扑排序和调度问题离不开有向环的检测，而且这两个问题可以看作是一个问题。在调度时，必须保证有向图中没有环，因此，解决任务调度类应用通常需要以下3 步：</p>\n<ul>\n<li>指明任务和优先级条件；</li>\n<li>不断检测并去除有向图中的所有环，以确保存在可行的方案；</li>\n<li>使用拓扑排序解决调度问题。</li>\n</ul>\n<h3 id=\"2-4-强连通性\"><a href=\"#2-4-强连通性\" class=\"headerlink\" title=\"2.4. 强连通性\"></a>2.4. 强连通性</h3><p>类似无向图中的连通性，我们在有向图中定义了<strong>强连通性</strong>：在有向图 G 中，如果两个顶点 v 和 w 是互相可达的，则称它们是<strong>强连通的</strong>。联想到环的定义，我们很容易想到两个顶点是强连通的等价于它们在同一个有向环中。</p>\n<p>有向图中的强连通性也是一种顶点之间的等价关系，满足以下性质：</p>\n<ul>\n<li>自反性：任意顶点 v 和自己都是强连通的。</li>\n<li>对称性：如果 v 和 w 是强连通的，那么 w 和 v 也是强连通的。</li>\n<li>传递性：如果 v 和 w 是强连通的且 w 和 x 也是强连通的，那<br>么 v 和 x 也是强连通的。</li>\n</ul>\n<p>强连通性将所有的顶点分为两一些等价类，每个等价类都是由相互均为强连通的顶点的最大子集组成的，我们称这些子集为<strong>强连通分量</strong>。对于理解有向图的结构，强连通性是一种非常重要的抽象，它突出了相互关联的几组顶点，如可以帮助决定话题分类和理解食物链中的能量流动问题。</p>\n<p>对于强连通分量问题，我们可以使用 Kosaraju 算法来解决，本质上这个算法还是基于 DFS 的，</p>\n<ul>\n<li>首先对 G 进行反转，即改变所有边的指向和原来相反，得到图 H；</li>\n<li>然后对 H 进行逆后序排列；</li>\n<li>按照这个排列顺序对 G 中的顶点调用标准 DFS，每一次非标记的顶点遍历完表示做完了一个强连通分量的搜索。</li>\n</ul>\n<img src=\"/2020/04/algorithm-map/kosaraju_example.png\" title=\"Kosaraju 算法运行示例\">\n<p>举个例子，如上图所示。证明如下：</p>\n<img src=\"/2020/04/algorithm-map/kosaraju_provement.png\" title=\"Kosaraju 算法证明\">\n<h2 id=\"3-最小生成树\"><a href=\"#3-最小生成树\" class=\"headerlink\" title=\"3. 最小生成树\"></a>3. 最小生成树</h2><p><strong>加权图</strong>是为每条边关联一个<em>权值</em>或是<em>成本</em>的图模型。这种图能够自然地表示许多应用。在一幅电路图中，边表示导线，权值则可能表示导线的长度即成本，或是信号通过这条线路所需的时间。在这些情形中，最令人感兴趣的自然是将成本最小化。我们将学习加权无向图模型并用算法回答这个问题。</p>\n<p><strong>最小生成树</strong>：给定一副加权无向图，找到它的一棵最小生成树。</p>\n<p>在解决这个问题之前，我们需要对之前的数据结构进行一些改变。</p>\n<h3 id=\"3-1-Prim-算法\"><a href=\"#3-1-Prim-算法\" class=\"headerlink\" title=\"3.1. Prim 算法\"></a>3.1. Prim 算法</h3><p>这是一种得到加权无向图的有效算法，基本思想如下：</p>\n<ul>\n<li>将一个节点加入队列，将它的所有邻边加入队列</li>\n</ul>\n<h3 id=\"3-2-Kruskal-算法\"><a href=\"#3-2-Kruskal-算法\" class=\"headerlink\" title=\"3.2. Kruskal 算法\"></a>3.2. Kruskal 算法</h3><h2 id=\"4-最短路径\"><a href=\"#4-最短路径\" class=\"headerlink\" title=\"4. 最短路径\"></a>4. 最短路径</h2>","tags":[{"name":"notes","slug":"notes","permalink":"https://jonathan1214.github.io/tags/notes/"},{"name":"算法","slug":"算法","permalink":"https://jonathan1214.github.io/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"https://jonathan1214.github.io/tags/数据结构/"},{"name":"Java","slug":"Java","permalink":"https://jonathan1214.github.io/tags/Java/"}]},{"title":"NS2 的介绍（六）—— trace 分析示例","date":"2020-04-08T04:41:36.000Z","path":"2020/04/ns2-trace-analysis-example/","text":"本文将展示一个 trace 分析示例，从中可以知道如何从 NS2 中生成 trace，如何解释 trace，如何从 trace 中得到有用的信息。在 模拟示例 给出的代码 ns-simple.tcl 中的第 15、16 行，我们打开了一个 trace 文件，在 finish 步骤中，我们向 trace 文件中写入了 trace 信息。 12345#...#open trace fileset f [open out.tr w]$ns trace-all $f#... 执行代码ns-simple.tcl会生成一个 NAM trace 文件，该文件作为 NAM 的输入，同时还会生成一个名为 out.tr 的文件，该文件用于我们的模拟分析。下图展示了 trace 的格式和来自 out.tr 的 trace 数据示例。 每一个 trace 行依次为以下部分： 事件描述符：+，-，d，r 事件发生的模拟时间，单位：秒 发起事件的节点 接受的节点 packet 类型 packet 大小，单位 Byte 分隔符：—— flow id：使用者在 OTcl 脚本中定义的 flow id。在模拟中用不到，可用于后续分析 源地址 目的地址 网络层协议下 packet 序列号：UDP 协议不需要使用序列号号但也会携带，便于分析 packet id：每一个 packet 编号唯一 拿到模拟数据后，我们要做的就是筛选出需要的信息，并把它们转换成更容易理解的形式然后分析。下面是一简单的数据转换示例，对上面得到的 out.tr 文件，在终端中执行 cat out.tr | grep &quot; 2 3 cbr &quot; | grep ^r | awk &#39;BEGIN {oldtime=0;oldpacket=0;} {dif=$12-oldpacket;if(dif==0) dif=1; if(dif&gt;0) {printf(&quot;%d\\t%f\\n&quot;,$12,($2-oldtime)/dif); oldtime=$2;oldpacket=$12}}&#39; &gt; jitter.txt，即可在目录下得到一个输出文件 jitter.txt。该命令从 trace 中提取节点 3 从 2 中接收 packet 的事件，并计算接收当前 packet 距离接收上一个 packet 的 packet 时延（接收时间差/packetID差）。使用 gnuplot 可以画出如下图像，X 轴为 packet 序列号，Y 轴为模拟时间（单位：秒）。 这个例子中，仿真后的分析在 shell 终端中进行，但是这些处理也可以在输入的 OTcl 脚本中进行，我们将在下一节讨论。 参考：WPI","content":"<p>本文将展示一个 trace 分析示例，从中可以知道如何从 NS2 中生成 trace，如何解释 trace，如何从 trace 中得到有用的信息。在 <a href=\"/2020/04/ns2-simple-simulation-example/\" title=\"模拟示例\">模拟示例</a> 给出的代码 <a href=\"/2020/04/ns2-trace-analysis-example/ns-simple.tcl\" title=\"ns-simple.tcl\">ns-simple.tcl</a> 中的第 15、16 行，我们打开了一个 trace 文件，在 finish 步骤中，我们向 trace 文件中写入了 trace 信息。<a id=\"more\"></a></p>\n<figure class=\"highlight tcl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#...</span></span><br><span class=\"line\"><span class=\"comment\">#open trace file</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> f [<span class=\"keyword\">open</span> out.tr w]</span><br><span class=\"line\">$ns <span class=\"keyword\">trace</span>-all $f</span><br><span class=\"line\">#...</span><br></pre></td></tr></table></figure>\n<p>执行代码<a href=\"/2020/04/ns2-trace-analysis-example/ns-simple.tcl\" title=\"ns-simple.tcl\">ns-simple.tcl</a>会生成一个 NAM trace 文件，该文件作为 NAM 的输入，同时还会生成一个名为 out.tr 的文件，该文件用于我们的模拟分析。下图展示了 trace 的格式和来自 out.tr 的 trace 数据示例。</p>\n<img src=\"/2020/04/ns2-trace-analysis-example/trace_format_example.png\" title=\"trace 文件格式与示例\">\n<p>每一个 trace 行依次为以下部分：</p>\n<ul>\n<li>事件描述符：+，-，d，r</li>\n<li>事件发生的模拟时间，单位：秒</li>\n<li>发起事件的节点</li>\n<li>接受的节点</li>\n<li>packet 类型</li>\n<li>packet 大小，单位 Byte</li>\n<li>分隔符：——</li>\n<li>flow id：使用者在 OTcl 脚本中定义的 flow id。在模拟中用不到，可用于后续分析</li>\n<li>源地址</li>\n<li>目的地址</li>\n<li>网络层协议下 packet 序列号：UDP 协议不需要使用序列号号但也会携带，便于分析</li>\n<li>packet id：每一个 packet 编号唯一</li>\n</ul>\n<p>拿到模拟数据后，我们要做的就是筛选出需要的信息，并把它们转换成更容易理解的形式然后分析。下面是一简单的数据转换示例，对上面得到的 out.tr 文件，在终端中执行 <code>cat out.tr | grep &quot; 2 3 cbr &quot; | grep ^r | awk &#39;BEGIN {oldtime=0;oldpacket=0;} {dif=$12-oldpacket;if(dif==0) dif=1; if(dif&gt;0) {printf(&quot;%d\\t%f\\n&quot;,$12,($2-oldtime)/dif); oldtime=$2;oldpacket=$12}}&#39; &gt; jitter.txt</code>，即可在目录下得到一个输出文件 jitter.txt。该命令从 trace 中提取节点 3 从 2 中接收 packet 的事件，并计算接收当前 packet 距离接收上一个 packet 的 packet 时延（接收时间差/packetID差）。使用 gnuplot 可以画出如下图像，X 轴为 packet 序列号，Y 轴为模拟时间（单位：秒）。</p>\n<p>这个例子中，仿真后的分析在 shell 终端中进行，但是这些处理也可以在输入的 OTcl 脚本中进行，我们将在下一节讨论。</p>\n<hr>\n<p>参考：<a href=\"http://nile.wpi.edu.cn/NS/\" target=\"_blank\" rel=\"noopener\">WPI</a></p>\n","tags":[{"name":"网络","slug":"网络","permalink":"https://jonathan1214.github.io/tags/网络/"},{"name":"NS2","slug":"NS2","permalink":"https://jonathan1214.github.io/tags/NS2/"}]},{"title":"NS2 的介绍（五）—— 数据分组","date":"2020-04-07T08:06:51.000Z","path":"2020/04/ns2-packet/","text":"在前面两篇文章中我们分别介绍了 NS2 中非常重要的两个组成——事件调度器和网络组件，我们知道了 packet（数据分组）是如何在节点之间传递的，现在让我们来看看数据分组在 NS2 中是如何表示的。一个 NS2 数据分组由一个头部信息的栈和可选的数据空间组成，如下图所示。在简单仿真示例提到过，数据分组头格式在创建 Simulator 对象时被初始化，在 Simulator 对象中，一系列栈排列注册了的 header 头（有可能不可见）被定义，如 common 头（它通常被任何需要的对象使用）、IP 头、TCP 头、RTP 头（UDP 使用 RTP 头）和 trace 头，且每个 header 在栈中的偏移都会被记录下来。这意味着不管一个头有没有被使用，当一个 packet（数据分组）被代理分配时创建的栈中都会含有它，并且网络对象使用相应的 offset（偏移值）就可以获得数据分组的栈中的任意头。 通常，一个 packet（数据分组）只有一个特定的 head（头部）栈，尽管通过分配数据空间，packet（数据分组）可以携带实际的（来自 application）信息，很少有 application（应用）和 agent（代理）的实现会支持这种做法，这是因为在非实时的模拟中传递真实数据是没有意义的。但是如果你想实现一个可以跨过网络去和另一个 application 通信的 application 的话，你也许可以使用这个特性，不过需要在下层的代理实现中做一点改动，还可以为 application 创建一个新的 header，然后修改下层的代理向这个新建的 header 写入受到的数据。后面这种方法会在后面的一篇文章中讲到。 参考：WPI","content":"<p>在前面两篇文章中我们分别介绍了 NS2 中非常重要的两个组成——<a href=\"../ns2-event-scheduler\">事件调度器</a>和<a href=\"../ns2-network-components\">网络组件</a>，我们知道了 packet（数据分组）是如何在节点之间传递的，现在让我们来看看数据分组在 NS2 中是如何表示的。<br><a id=\"more\"></a><br>一个 NS2 数据分组由一个<strong>头部信息的栈</strong>和<strong>可选的数据空间</strong>组成，如下图所示。在<a href=\"../ns2-simple-simulation-example\">简单仿真示例</a>提到过，数据分组头格式在创建 Simulator 对象时被初始化，在 Simulator 对象中，一系列栈排列注册了的 header 头（有可能不可见）被定义，如 common 头（它通常被任何需要的对象使用）、IP 头、TCP 头、RTP 头（UDP 使用 RTP 头）和 trace 头，且每个 header 在栈中的偏移都会被记录下来。这意味着不管一个头有没有被使用，当一个 packet（数据分组）被代理分配时创建的栈中都会含有它，并且网络对象使用相应的 offset（偏移值）就可以获得数据分组的栈中的任意头。</p>\n<p><img src=\"/assets/img/2020/ns_packet_format.png\" alt=\"packet 格式\"><br>通常，一个 packet（数据分组）只有一个特定的 head（头部）栈，尽管通过分配数据空间，packet（数据分组）可以携带实际的（来自 application）信息，很少有 application（应用）和 agent（代理）的实现会支持这种做法，这是因为<strong>在非实时的模拟中传递真实数据是没有意义的</strong>。但是如果你想实现一个可以跨过网络去和另一个 application 通信的 application 的话，你也许可以使用这个特性，不过需要在下层的代理实现中做一点改动，还可以为 application 创建一个新的 header，然后修改下层的代理向这个新建的 header 写入受到的数据。后面这种方法会在后面的一篇文章中讲到。</p>\n<hr>\n<p>参考：<a href=\"http://nile.wpi.edu.cn/NS/\" target=\"_blank\" rel=\"noopener\">WPI</a></p>\n","tags":[{"name":"网络","slug":"网络","permalink":"https://jonathan1214.github.io/tags/网络/"},{"name":"NS2","slug":"NS2","permalink":"https://jonathan1214.github.io/tags/NS2/"}]},{"title":"NS2 的介绍（四）—— 网络组件","date":"2020-04-06T01:30:03.000Z","path":"2020/04/ns2-network-components/","text":"我们在前文讨论 NS2 中一个非常重要的组成——事件调度器，这篇文章将讨论 NS2 另一个关键的组成——网络组件，主要是复合网络组件。下图展示了 NS2 中部分 OTcl 类的部分体系结构，有助于我们理解基本的网络组件（network component），在这个链接中可以找到 NS2 类的完整的体系结构。 类的部分体系结构层级的根是 TclObject 类，它是所有 OTcl 库对象的父类，如 scheduler（调度器），network component（网络组件），（timer）计时器和其他，包括 NAM 相关的类。NsObject 类是 OTclObject 的直接子类，同时也是所有基本 network component（网络组件）对象的父类，这些 network component 构成复合网络对象如 node （节点）和 link （连接），用来处理 packet。基于可能的输出 data path （数据路径）的数量，基本 network component （网络组件）进一步分为两类，Connector（连接器）和 Classifier（分类器），只有一个输出 data path（数据路径）的网络对象归到 Connector（连接器）下，而有多条输出 data path（数据路径）的归到 Classifier （分类器）下。 节点和路由选择node（节点）是一个由节点入口对象和分类器构成的复合对象，如下图所示，NS2 中有两种 node （节点），unicast（单播）节点和 multicast （多播）节点。单播节点中有两个分类器，一个是负责单播路由选择的地址分类器，另一个是端口分类器。类似地，多播节点也有两个分类器，一个分类器负责区分多播 packet 和单播 packet，另一个多播分类器负责多播路由选择。 节点在 NS2 中，默认节点设置为单播，如要使用多播节点，需要在 OTcl 脚本中显式声明，创建 scheduler（调度器）对象后立即声明，而后所有的节点都会被创建为多播节点。确定节点类型后，使用者还需要手动选择一个路由选择协议，不可使用默认协议。 unicast： $ns rtproto &lt;type&gt; &lt;type&gt;：Static，Session，DV，cost，multi-path multicast： $ns multicast 放在 set $ns [new Scheduler] 后 $ns mrtproto &lt;type&gt; &lt;type&gt;：CtrMCast，DM，ST，BST 关于路由选择的更多信息，可以参考 NS2 手册。 连接link（连接）是 NS2 中另一个主要的复合对象，当使用者使用 Simulator 对象的 duplex-link 成员函数，就可以创建一个双向连接，该连接包括两条单向连接，分别连接的双方，如下图所示。 另一个要注意到是，节点的输出队列其实被实现为 simplex （单向）连接的一部分。从队列中 dequeue （出队）的 packet被传递给模拟连接延时的 Delay（延时）对象，而从队列中 drop （抛弃）的 packet 的被传递给一个 Null 代理然后被释放。最后，TTL 对象为每一个接受到的 packet 计算（time to live parameter）生命参数的时间，并更新 packet 的 TTL 字段。 连接 追踪在 NS2 中，网络活动在单向连接中被记录，如果 simulator （模拟器）被指引去追踪网络活动（使用 $ns trace-all &lt;file&gt; 或 $ns namtrace-all &lt;file&gt;），那么 link （连接）在创建后，会有如下图所示的 trace（追踪）对象插入其中。使用者也可以在给定的源节点和目的节点间自定义一个 type 类型的 trace 对象，使用 creat-trace {type &lt;file&gt; &lt;src&gt; &lt;dst&gt;} 命令即可。 当插入到 link 中的 trace 对象（如 EnqT，DeqT 和 RecvT）受到一个 packet 时，它会向特定的 trace 文件中写入信息，且不需要消耗模拟时间，然后把该 packet 传递给下一个网络对象。trace 的格式讲在后面讨论。 插入了 trace 对象的连接 队列监视器本质上，tracing （追踪）对象被设计成可以记录 packet 的到达所在位置的时间。尽管使用者可以从 trace 中获得足够多的信息，如果他们对特定输出队列中发生的事的细节感兴趣，他们可以通过一些设置来获取这些信息。比如，如果使用者对 RED 队列的行为感兴趣，想计算平均队列大小的 dynamics 和某一特定 RED 队列的实时队列大小，或者其他有关监视队列的需求，队列监视器就可以有所帮助。队列监视行为使用队列监视器对象和 snoop 队列对象实现，如下图所示。 当一个 packet 到达时，snoop 队列对象通知 queue monitor（队列监视器）该事件，由队列监视器监视队列。后续会给出一个 RED 队列监视的例子，详细情况可以参考那个例子。现在只需要注意到，snoop 队列对象除了图中所示的用法，它还可以与 tracing （追踪）对象并行使用。 插入了 trace 对象的连接 一个 packet 流动的例子到现在为止，我们分析了两个最重要的网络组件——节点和连接。下图展示了一个模拟网络建立和 packet 流动的内部情况。网络由两个节点 n0 和 n1 组成，网络地址分别 0 和 1。绑定在 n0 上的一个 TCP 代理使用端口 0 与 绑定在 n1 上的使用端口 0 的 TCP sink 对象通信。最后，一个 FTP 应用绑定到 TCP 代理上，请求发送一些数据。注意，下图没有显示出 FTP 在 TCP 上的具体行为，仅仅展示仿真网络和 packet 流动的详细内部情况。 插入了 trace 对象的连接 参考：WPI","content":"<p>我们在<a href=\"/2020/04/ns2-event-scheduler\">前文</a>讨论 NS2 中一个非常重要的组成——事件调度器，这篇文章将讨论 NS2 另一个关键的组成——网络组件，主要是复合网络组件。<br><a id=\"more\"></a><br>下图展示了 NS2 中部分 OTcl 类的部分体系结构，有助于我们理解基本的网络组件（network component），在<a href=\"http://www.sop.inria.fr/rodeo/personnel/Antonie.Clerget/ns\" target=\"_blank\" rel=\"noopener\">这个链接</a>中可以找到 NS2 类的完整的体系结构。</p>\n<p></p><p align=\"center\" class=\"img\"><br>    <img src=\"/assets/img/2020/partial_class_hierarchy.png\" alt=\"partial_class_hierarchy\" width=\"500\"><br>    <span align=\"center\" style=\"color:#999\">类的部分体系结构</span><br></p><br>层级的根是 TclObject 类，它是所有 OTcl 库对象的父类，如 scheduler（调度器），network component（网络组件），（timer）计时器和其他，包括 NAM 相关的类。NsObject 类是 OTclObject 的直接子类，同时也是所有基本 network component（网络组件）对象的父类，这些 network component 构成复合网络对象如 node （节点）和 link （连接），用来处理 packet。基于可能的输出 data path （数据路径）的数量，基本 network component （网络组件）进一步分为两类，Connector（连接器）和 Classifier（分类器），只有一个输出 data path（数据路径）的网络对象归到 Connector（连接器）下，而有多条输出 data path（数据路径）的归到 Classifier （分类器）下。<p></p>\n<h2 id=\"节点和路由选择\"><a href=\"#节点和路由选择\" class=\"headerlink\" title=\"节点和路由选择\"></a>节点和路由选择</h2><p>node（节点）是一个由节点入口对象和分类器构成的复合对象，如下图所示，NS2 中有两种 node （节点），unicast（单播）节点和 multicast （多播）节点。单播节点中有两个分类器，一个是负责单播路由选择的地址分类器，另一个是端口分类器。类似地，多播节点也有两个分类器，一个分类器负责区分多播 packet 和单播 packet，另一个多播分类器负责多播路由选择。</p>\n<p></p><p align=\"center\" class=\"img\"><br>    <img src=\"/assets/img/2020/node.png\" alt=\"node\" width=\"600\"><br>    <span align=\"center\" style=\"color:#999\">节点</span><br></p><br>在 NS2 中，默认节点设置为单播，如要使用多播节点，需要在 OTcl 脚本中显式声明，创建 scheduler（调度器）对象后立即声明，而后所有的节点都会被创建为多播节点。确定节点类型后，使用者还需要手动选择一个路由选择协议，不可使用默认协议。<p></p>\n<ul>\n<li>unicast：<ul>\n<li><code>$ns rtproto &lt;type&gt;</code></li>\n<li><code>&lt;type&gt;</code>：Static，Session，DV，cost，multi-path</li>\n</ul>\n</li>\n<li>multicast：<ul>\n<li><code>$ns multicast</code> 放在 <code>set $ns [new Scheduler]</code> 后</li>\n<li><code>$ns mrtproto &lt;type&gt;</code></li>\n<li><code>&lt;type&gt;</code>：CtrMCast，DM，ST，BST</li>\n</ul>\n</li>\n</ul>\n<p>关于路由选择的更多信息，可以参考 <a href=\"http://www.isi.edu/nsnam/ns/ns-documentation.html\" target=\"_blank\" rel=\"noopener\">NS2 手册</a>。</p>\n<h2 id=\"连接\"><a href=\"#连接\" class=\"headerlink\" title=\"连接\"></a>连接</h2><p>link（连接）是 NS2 中另一个主要的复合对象，当使用者使用 Simulator 对象的 <code>duplex-link</code> 成员函数，就可以创建一个双向连接，该连接包括两条单向连接，分别连接的双方，如下图所示。</p>\n<p>另一个要注意到是，节点的输出队列其实被实现为 simplex （单向）连接的一部分。从队列中 dequeue （出队）的 packet被传递给模拟连接延时的 Delay（延时）对象，而从队列中 drop （抛弃）的 packet 的被传递给一个 Null 代理然后被释放。最后，TTL 对象为每一个接受到的 packet 计算（time to live parameter）生命参数的时间，并更新 packet 的 TTL 字段。</p>\n<div align=\"center\" class=\"img\"><br>    <img src=\"/assets/img/2020/link.png\" alt=\"link\" width=\"400\"><br>    <span align=\"center\" style=\"color:#999\">连接</span><br></div>\n\n<h3 id=\"追踪\"><a href=\"#追踪\" class=\"headerlink\" title=\"追踪\"></a>追踪</h3><p>在 NS2 中，网络活动在单向连接中被记录，如果 simulator （模拟器）被指引去追踪网络活动（使用 <code>$ns trace-all &lt;file&gt;</code> 或 <code>$ns namtrace-all &lt;file&gt;</code>），那么 link （连接）在创建后，会有如下图所示的 trace（追踪）对象插入其中。使用者也可以在给定的源节点和目的节点间自定义一个 type 类型的 trace 对象，使用 <code>creat-trace {type &lt;file&gt; &lt;src&gt; &lt;dst&gt;}</code> 命令即可。</p>\n<p>当插入到 link 中的 trace 对象（如 EnqT，DeqT 和 RecvT）受到一个 packet 时，它会向特定的 trace 文件中写入信息，且不需要消耗模拟时间，然后把该 packet 传递给下一个网络对象。trace 的格式讲在后面讨论。</p>\n<div align=\"center\" class=\"img\"><br>    <img src=\"/assets/img/2020/link_with_trace.png\" alt=\"link_with_trace\" width=\"750\"><br>    <span align=\"center\" style=\"color:#999\">插入了 trace 对象的连接</span><br></div>\n\n<h3 id=\"队列监视器\"><a href=\"#队列监视器\" class=\"headerlink\" title=\"队列监视器\"></a>队列监视器</h3><p>本质上，tracing （追踪）对象被设计成可以记录 packet 的到达所在位置的时间。尽管使用者可以从 trace 中获得足够多的信息，如果他们对特定输出队列中发生的事的细节感兴趣，他们可以通过一些设置来获取这些信息。比如，如果使用者对 RED 队列的行为感兴趣，想计算平均队列大小的 dynamics 和某一特定 RED 队列的实时队列大小，或者其他有关监视队列的需求，队列监视器就可以有所帮助。队列监视行为使用队列监视器对象和 snoop 队列对象实现，如下图所示。</p>\n<p>当一个 packet 到达时，snoop 队列对象通知 queue monitor（队列监视器）该事件，由队列监视器监视队列。后续会给出一个 RED 队列监视的例子，详细情况可以参考那个例子。现在只需要注意到，snoop 队列对象除了图中所示的用法，它还可以与 tracing （追踪）对象并行使用。</p>\n<div align=\"center\" class=\"img\"><br>    <img src=\"/assets/img/2020/link_with_snoop_queue.png\" alt=\"link_with_snoop_queue\" width=\"750\"><br>    <span align=\"center\" style=\"color:#999\">插入了 trace 对象的连接</span><br></div>\n\n<h2 id=\"一个-packet-流动的例子\"><a href=\"#一个-packet-流动的例子\" class=\"headerlink\" title=\"一个 packet 流动的例子\"></a>一个 packet 流动的例子</h2><p>到现在为止，我们分析了两个最重要的网络组件——节点和连接。下图展示了一个模拟网络建立和 packet 流动的内部情况。<br>网络由两个节点 n0 和 n1 组成，网络地址分别 0 和 1。绑定在 n0 上的一个 TCP 代理使用端口 0 与 绑定在 n1 上的使用端口 0 的 TCP sink 对象通信。最后，一个 FTP 应用绑定到 TCP 代理上，请求发送一些数据。<br>注意，下图没有显示出 FTP 在 TCP 上的具体行为，仅仅展示仿真网络和 packet 流动的详细内部情况。</p>\n<div align=\"center\" class=\"img\"><br>    <img src=\"/assets/img/2020/packet_flow.png\" alt=\"packet_flow\" width=\"750\"><br>    <span align=\"center\" style=\"color:#999\">插入了 trace 对象的连接</span><br></div>\n\n<hr>\n<p>参考：<a href=\"http://nile.wpi.edu.cn/NS/\" target=\"_blank\" rel=\"noopener\">WPI</a></p>\n","tags":[{"name":"网络","slug":"网络","permalink":"https://jonathan1214.github.io/tags/网络/"},{"name":"NS2","slug":"NS2","permalink":"https://jonathan1214.github.io/tags/NS2/"}]},{"title":"NS2 的介绍（三）—— 事件调度器","date":"2020-04-04T00:32:25.000Z","path":"2020/04/ns2-event-scheduler/","text":"在上一篇文章中，我们从一个简单的例子出发，从零开始编写了一个 NS2 模拟用的 OTcl 脚本，我们需要在脚本中完成以下任务： 创建 Simulator 对象； 创建 node 对象并构建 node 间的连接 link； 创建代理对象和 traffic 源对象，连接 node 和代理，连接代理和 traffic 源； 创建模拟场景 scenario，即定义调度任务； 开始模拟。 按照以上这些步骤编写就可完成模拟脚本编写。这篇文章中要介绍的是第 4 个步骤创建模拟场景的详细信息，我们将讨论 NS2 中的离散事件调度器。如第一篇文章中谈到的，在 NS2 中，事件调度器主要是由一些网络组件来使用，组件们模拟 packet 的处理时需要调度程序作为延时器或计时器。如下图展示，每一个网络对象使用一个时间调度器，图中需要注意：（1）网络对象发出一个事件那么它就要在预定的时间点上处理这个事件；（2）网络对象间的数据路径和事件路径不相同；若深入到代码层面，包在网络对象中传递时，发送方使用 send(Packet* p){target_-&gt;recv(p); 语句发送，接收方使用 recv(Packet*, Handler* h = 0) 方法接收。 离散事件调度器NS2 实现了两种事件调度器，实时调度器和非实时调度器。非实时调度器有三种实现，分别为 List、Heap 和 Calendar，它们逻辑上是一样的，之所以有这么多实现，是由于向下兼容的原因。默认的非实时调度器是 Calender 方式实现的。实时调度器是为仿真 emulation 使用的，允许仿真器 simulator 和真实的网络交互。下面这个就是一个指定事件调度器的例子。 set ns [new Simulator] $ns use-scheduler Heap 事件调度器还可以调度模拟事件，比如启动一个 FTP 应用或者结束模拟。事件调度器对象本身有一些模拟调度成员函数，比如 at &lt;time&gt; &quot;&lt;string&gt;&quot;，它就可以在发起一个在特定的模拟时间 &lt;time> 发生的叫做 AtEvent 的事件。AtEvent 其实是 Event 类的子类，它扩展了额外的变量保存 at &lt;time&gt; &quot;&lt;string&gt;&quot; 中的 string，尽管有扩展，它在事件调度器中和一般的事件还是被相同对待的。模拟开始后，当模拟时间到达事件队列中的 AtEvent 应该被调度的时间时，该 AtEvent 就会被传递给一个 AtEvent Handler，AtEvent Handler 只被创建一次并处理所有的的 AtEvent，AtEvent 的 &lt;string> 确定的 OTcl 命令也会被执行。下面是一个模拟事件调度示例： set ns [new Simulator] $ns use-scheduler Heap $ns at 300.5 &quot;complete_sim&quot; proc complete_sim {} {...} 注意到在上面的例子中，at &lt;time&gt; &quot;&lt;string&gt;&quot; 是 Simulator 对象 ns 的成员函数，但是我们要记住，Simulator 对象仅仅只是起到一个用户接口的作用，事实上它会去调用网络对象或者调度器对象的成员函数，由它们真正地完成工作。下面是一个函数列表和简单说明，这些函数就是 Simulator 对象用来接口调度器成员函数的成员函数。 成员函数 说明 Simulator instproc now 返回调度器对现在时间的 notion Simulator isntproc at args 在特定的时间调度执行代码 Simulator instproc at-now args 立即调度执行代码 Simulator instproc after n args n 秒后调度执行代码 Simulator instproc run args 启动调度器 Simulator instproc halt 停止或赞同调度器 参考：WPI","content":"<p>在<a href=\"/2020/04/ns2-simple-simulation-example\">上一篇文章</a>中，我们从一个简单的例子出发，从零开始编写了一个 NS2 模拟用的 OTcl 脚本，我们需要在脚本中完成以下任务：</p>\n<ol>\n<li>创建 Simulator 对象；</li>\n<li>创建 node 对象并构建 node 间的连接 link；</li>\n<li>创建代理对象和 traffic 源对象，连接 node 和代理，连接代理和 traffic 源；</li>\n<li>创建模拟场景 scenario，即定义调度任务；</li>\n<li>开始模拟。</li>\n</ol>\n<p>按照以上这些步骤编写就可完成模拟脚本编写。这篇文章中要介绍的是第 4 个步骤创建模拟场景的详细信息，我们将讨论 NS2 中的离散事件调度器。<br><a id=\"more\"></a><br>如<a href=\"/2020/04/02/ns2-simulation-overview\">第一篇文章</a>中谈到的，在 NS2 中，事件调度器主要是由一些网络组件来使用，组件们模拟 packet 的处理时需要调度程序作为延时器或计时器。如下图展示，每一个网络对象使用一个时间调度器，图中需要注意：<br>（1）网络对象发出一个事件那么它就要在预定的时间点上处理这个事件；<br>（2）网络对象间的数据路径和事件路径不相同；<br>若深入到代码层面，包在网络对象中传递时，发送方使用 <code>send(Packet* p){target_-&gt;recv(p);</code> 语句发送，接收方使用 <code>recv(Packet*, Handler* h = 0)</code> 方法接收。</p>\n<p><div align=\"center\" class=\"img\"><br>    <img src=\"/assets/img/2020/discrete_event_scheduler.png\" alt=\"discrete_event_scheduler\" width=\"750\"><br>    <span align=\"center\" style=\"color:#999\">离散事件调度器</span><br></div><br>NS2 实现了两种事件调度器，实时调度器和非实时调度器。非实时调度器有三种实现，分别为 List、Heap 和 Calendar，它们逻辑上是一样的，之所以有这么多实现，是由于向下兼容的原因。默认的非实时调度器是 Calender 方式实现的。实时调度器是为仿真 emulation 使用的，允许仿真器 simulator 和真实的网络交互。下面这个就是一个指定事件调度器的例子。</p>\n<pre><code>set ns [new Simulator]\n$ns use-scheduler Heap\n</code></pre><p>事件调度器还可以调度模拟事件，比如启动一个 FTP 应用或者结束模拟。事件调度器对象本身有一些模拟调度成员函数，比如 <code>at &lt;time&gt; &quot;&lt;string&gt;&quot;</code>，它就可以在发起一个在特定的模拟时间 &lt;time> 发生的叫做 <code>AtEvent</code> 的事件。<code>AtEvent</code> 其实是 <code>Event</code> 类的子类，它扩展了额外的变量保存 <code>at &lt;time&gt; &quot;&lt;string&gt;&quot;</code> 中的 <code>string</code>，尽管有扩展，它在事件调度器中和一般的事件还是被相同对待的。模拟开始后，当模拟时间到达事件队列中的 AtEvent 应该被调度的时间时，该 <code>AtEvent</code> 就会被传递给一个 <code>AtEvent Handler</code>，<code>AtEvent Handler</code> 只被创建一次并处理所有的的 <code>AtEvent</code>，<code>AtEvent</code> 的 &lt;string> 确定的 OTcl 命令也会被执行。下面是一个模拟事件调度示例：</p>\n<pre><code>set ns [new Simulator]\n$ns use-scheduler Heap\n$ns at 300.5 &quot;complete_sim&quot;\n\nproc complete_sim {} {...}\n</code></pre><p>注意到在上面的例子中，<code>at &lt;time&gt; &quot;&lt;string&gt;&quot;</code> 是 Simulator 对象 ns 的成员函数，但是我们要记住，Simulator 对象仅仅只是起到一个用户接口的作用，事实上它会去调用网络对象或者调度器对象的成员函数，由它们真正地完成工作。下面是一个函数列表和简单说明，这些函数就是 Simulator 对象用来接口调度器成员函数的成员函数。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">成员函数</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Simulator instproc now</td>\n<td style=\"text-align:left\">返回调度器对现在时间的 notion</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Simulator isntproc at args</td>\n<td style=\"text-align:left\">在特定的时间调度执行代码</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Simulator instproc at-now args</td>\n<td style=\"text-align:left\">立即调度执行代码</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Simulator instproc after n args</td>\n<td style=\"text-align:left\">n 秒后调度执行代码</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Simulator instproc run args</td>\n<td style=\"text-align:left\">启动调度器</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Simulator instproc halt</td>\n<td style=\"text-align:left\">停止或赞同调度器</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p>参考：<a href=\"http://nile.wpi.edu.cn/NS/\" target=\"_blank\" rel=\"noopener\">WPI</a></p>\n","tags":[{"name":"网络","slug":"网络","permalink":"https://jonathan1214.github.io/tags/网络/"},{"name":"NS2","slug":"NS2","permalink":"https://jonathan1214.github.io/tags/NS2/"}]},{"title":"NS2 的介绍（二）—— 模拟示例","date":"2020-04-03T02:25:25.000Z","path":"2020/04/ns2-simple-simulation-example/","text":"我们在前一篇文章中简单介绍了 NS2，它是一个离散事件驱动的网络模拟器，从具体实现来看，它就是一个 OTcl 脚本解释器，由模拟事件调度程序、网络组件对象库和网络启动(plumbing)模块库组成。文中还介绍了这些部分是如何一起协同实现网络模拟的。有了关于 NS2 的基本概念，下面就来看一个具体的模拟示例，看看 OTcl 脚本如何编写，如何进行一个网络模拟吧。 OTcl 脚本编写前面提到，NS2 是一个 OTcl 解释器，在它上面进行模拟就需要编写 OTcl 脚本。在介绍 OTcl 编写之前，我们需要知道 Tcl 和 OTcl 的关系就像 C 和 C++ 的关系一样，在前者的基础上，后者增加了面向对象特性，下面就来看看 Tcl 和 OTcl 脚本如何编写吧。 Tcl 脚本一份 Tcl 脚本如下所示，需要关注的点如表所示，详细可以参考易百教程，对于基本的 NS2 脚本编写，了解这些就够了。 操作 关键字 格式 示例 定义 procedure proc proc &lt;procname&gt; {&lt;argumentlist&gt;} {&lt;contents&gt;} 第 2 行 定义变量 set set &lt;variablename&gt; &lt;variablevalue&gt; 第 3 行 表达式值替换 expr [expr &lt;expression&gt;] 第 5 行 变量值替换 $ $&lt;variablename&gt; 第 5 行 输出 puts puts &quot;&lt;contents&gt;&quot; 第 9 行 for 循环 for for {&lt;initial&gt;} {&lt;condition&gt;} {actioneveryloop} {&lt;mainLoopExpression&gt;} 第 7 行 if 条件选择语句 if if {&lt;condition&gt;} {&lt;expression&gt;} 第 8 行 ex-tcl.tclview raw12345678910111213141516# 定义一个 procedureproc test {} { set a 43 set b 27 set c [expr $a + $b] set d [expr [expr $a - $b] * $c] for {set k 0} {$k &lt; 10} {incr k} { if {$k &lt; 5} { puts \"k &lt; 5, pow = [expr pow($d, $k)]\" } else { puts \"k &gt;= 5, mod = [expr $d % $k]\" } }}# 调用 procedure testtest 将文件保存为 ex-tcl.tcl，然后在Shell中执行 ns ex-tcl.tcl，得到的的输出如下： 12345678910k &lt; 5, pow = 1.0k &lt; 5, pow = 1120.0k &lt; 5, pow = 1254400.0k &lt; 5, pow = 1404928000.0k &lt; 5, pow = 1573519360000.0k &gt;= 5, mod = 0k &gt;= 5, mod = 4k &gt;= 5, mod = 0k &gt;= 5, mod = 0k &gt;= 5, mod = 4 OTcl 脚本相比于 Tcl，OTcl 增加了面向对象功能，下面这个例子展示了 OTcl 中对象是如何被创建和使用的。作为一个 NS2 的使用者，我们可能不会需要编写自己的 OTcl 对象，但是了解它们还是很有帮助的，因为我们在 NS2 模拟中使用的所有的对象，无论它们是 C++ 编写后连接到 OTcl 还是是直接使用OTcl 编写的，它们本质上都是 OTcl 对象。 下面这个例子中创建了两个类 mom 和 kid，它们都有成员函数 greet，声明类之后，在第 17~19 行我们对类进行了实例化，并定义了实例的成员变量的值，然后在 23、24 行调用了两个实例的成员函数。从代码从我们很容易可以看出： 如何对类进行实例化？ 如何改变类实例的成员变量的值？ 如何调用类实例的成员函数？ 那么如何定义一个类和子类呢？定义一个类需要使用关键字 Class 创建一个类，使用关键字 instproc 定义类的成员函数。类的继承使用关键字 -superclass，在成员函数中，$self 的作用就好像 C++ 中的 this 指针一样，关键字 instvar 检查后面紧跟的变量名是否已在类或父类中被声明，如果已经被声明，那这个变量就是已声明变量的引用，反之，这就是一个新的变量声明。最后，创建一个类实例，需要使用关键字 new。 ex-otcl.tclview raw123456789101112131415161718192021222324# add a member function called \"greet\"Class mommom instproc greet {} { $self instvar age_ puts \"$age_ year old mom say: How are you doing\"}# child classClass kid -superclass momkid instproc greet {} { $self instvar age_ puts \"$age_ year old kid say: What's up, dude?'\"}# creat instanceset a [new mom]$a set age_ 45set b [new kid]$b set age_ 15# calling member function$a greet$b greet 文件保存为 ex-otcl.tcl，在 Bash 中执行 ns ex-otcl.tcl，得到如下的输出： 123445 year old mom say: How are you doing15 year old kid say: What&apos;s up, dude?&apos; 简单的 NS2 模拟示例现在我们已经知道了基本的 OTcl 脚本是如何编写的了，现在来看看如何编写一个执行 NS2 模拟的 OTcl 脚本吧。下面的 ns-simple.tcl OTcl 脚本中进行了简单的网络配置，执行如图所示的模拟方案。下载代码后，在 Bash 中执行 ns ns-simple.tcl 即可。 一个简单的网络拓扑和模拟方案示意图从图中可以看到，这个网络包括四个节点：n0，n1，n2和n3。n0 和 n2 间是双向连接，n1 和 n2 间的连接有 2Mpbs 的带宽，传输时延为 10ms。n2 和 n3 之间为双向连接，传输带宽为 1.7Mbps，传输时延为 20ms。每个节点都使用一个 DropTail 队列，队列最大长度为 10。n0 节点上绑定了一个 tcp 代理，该代理和绑定在 n3 上的『sink』代理间构建了一条连接 (connection)。默认情况下，tcp 代理可以生成的最大 packet 为 1KByte。tcp『sink』代理生成确认接受分组 P 的 ACK 并将 ACk 发送给分组的发送者（即发送分组 P 的 tcp 代理），然后释放接收到的分组 P。n1 节点上绑定了一个 udp 代理，该代理和绑定在 n3 上的『null』代理间建立了一条连接。『null』代理字释放接收到的 packet，不会向 packet 的发送方发送 ACK。ftp 和 cbr 是 traffic 生成器，分别绑定到 tcp 和 udp 代理上。cbr 被设定为可以生成以 1Mbps 的速率生成 1KByte 大小的 packet，它在 0.1s 时开始工作到 4.5s 时停止，而 ftp 在 1.0s 时开始工作到 4.0s 停止。 ns-simple.tclview raw12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788# create a simulator objectset ns [new Simulator]# set color for NAM$ns color 1 blue$ns color 2 red# creat four Nodesset n0 [$ns node]set n1 [$ns node]set n2 [$ns node]set n3 [$ns node]# open NAM file and trace fileset f [open out.tr w]$ns trace-all $fset nf [open out.nam w]$ns namtrace-all $nf# 设置节点间的连接$ns duplex-link $n0 $n2 2Mb 10ms DropTail$ns duplex-link $n1 $n2 2Mb 10ms DropTail$ns duplex-link $n2 $n3 1.7Mb 20ms DropTail# 设置 n2 n3 队列大小$ns queue-limit $n2 $n3 10# 设置 NAM 中节点的位置$ns duplex-link-op $n0 $n2 orient right-down$ns duplex-link-op $n1 $n2 orient right-up$ns duplex-link-op $n2 $n3 orient right# NAM 设置$ns duplex-link-op $n2 $n3 queuePos 0.5# 设置 TCP 连接set tcp [new Agent/TCP]$tcp set class_ 2$ns attach-agent $n0 $tcpset sink [new Agent/TCPSink]$ns attach-agent $n3 $sink$ns connect $tcp $sink# 在 TCP 连接上启动 FTPset ftp [new Application/FTP]$ftp attach-agent $tcp$ftp set type_ FTP# 设置 UDP 连接set udp [new Agent/UDP]$ns attach-agent $n1 $udpset null [new Agent/Null]$ns attach-agent $n3 $null$ns connect $udp $null$udp set fid_ 2# 在 UDP 连接上设置 CBRset cbr [new Application/Traffic/CBR]$cbr attach-agent $udp$cbr set type_ CBR$cbr set packet_size_ 1000$cbr set random_ false# 为CBR 和 FTP 代理调度事件$ns at 0.1 \"$cbr start\"$ns at 1.0 \"$ftp start\"$ns at 4.0 \"$ftp stop\"$ns at 4.5 \"$cbr stop\"# 释放tcp和sink代理 会自动释放$ns at 4.5 \"ns detach-agent $n0 $tcp ; $ns detach-agent $n3 $sink\"# 调用 finish 步骤$ns at 5.0 \"finish\"proc finish {} { global ns f nf $ns flush-trace close $f close $nf puts \"running nam...\" exec nam out.nam &amp; exit 0}puts \"CBR packet size = [$cbr set packet_size_]\"puts \"CBR interval = [$cbr set interval_]\"$ns run 从 Simulator 对象开始网络的基本设置下面是对上述脚本的解释，总体上来看，NS 脚本从创建一个 Simulator 对象实例开始。注意：代码中，&lt;&gt; 包围的内容在使用时要按照实际情况替代成正确的内容。 set ns [new Simulator]：生成一个 NS2 simulator 对象实例为 ns。这一行代码完成了一些工作： 初始化 packet 格式 创建一个调度器（默认为 calendar 调度器） 选择默认的地址格式 Simulator 的成员函数可以完成如下工作： 创建一些复合对象，如节点 node 和 连接 link 连接网络组件对象 设置网络组件对象的参数 创建代理间的连接，如 tcp 和 sink 间的连接 明确 NAM 展示的选项等等 大多数成员函数用于模拟设置（如 plumbing 函数）和调度，也有一些用于 NAM 展示的设置。Simulator 对象成员函数在文件 ns-2.35/tcl/lib/ns-lib.tcl 中实现。 $ns color &lt;fid&gt; &lt;color&gt;：为流 id 即 fid 确定的流中 packet 设置颜色。该 Simulator 对象的成员函数为 NAM 展示服务，对实际的模拟有影响。 $ns namtrace-all &lt;file-descrption&gt;：这个成员函数告诉模拟器（simulator）按照 NAM 的输入的格式记录模拟痕迹（trace）到文件中，同时也给出了 $ns flush-trace 命令要写入的文件。类似的，函数 trace-all 用来记录模拟痕迹（trace），但是是基本的格式。 proc finish {}：一个模拟结束够调用的函数，通过 $ns at 5.0 &quot;finish&quot; 调用。在函数中，定义了模拟后的后续操作，如保存文件。 set n0 [$ns node]：成员函数 node 创建一个节点 node0。NS2 中的节点是一个复合类，由地址和端口分类器组成。用户创建节点时，也可以分别创建一个地址和端口分类器对象，然后再把它们连接起来，但是这个 Simulator 成员函数让节点创建变得简单。文件 ns-2.35/tcl/lib/ns-lib.tcl 和 ns-2.35/tcl/lib/ns-node.tcl 中有关于创建节点的详细信息。 $ns duplex-link &lt;node1&gt; &lt;node2&gt; &lt;bandwidth&gt; &lt;delay&gt; &lt;queue-type&gt;：创建两条单向连接，指定带宽和时延，然后连接声明的两个节点。在 NS2 中，节点的输出队列实现为一个连接的一部分，因此用户在创建连接时要指明队列类型 queue-type。上面的代码中使用的 DropTail 队列，如果想使用其他队列，修改队列类型即可。连接的实现在下一篇文章会提到，类似节点，连接也是一个复合类型，用户可以创建出它的子对象然后把他们和节点连接起来。有关连接的源代码在文件 ns-2.35/tcl/lib/ns-lib.tcl 和 ns-2.35/tcl/lib/ns-link.tcl 中。在连接模块中，我们可以进行很多个性化的操作，详请参考 NS2 文档。 $ns queue-limit &lt;node1&gt; &lt;node2&gt; &lt;number&gt;：设置两条连接 node1 和 node2 单向连接的队列大小。 $ns duplex-link-op &lt;node1&gt; &lt;node2&gt; ...：NAM 展示的设置，即设置节点的位置。 设置代理和 traffic 源现在，基本的网络设置以及完成了，下一就是启动 traffic 代理，如 TCP 和 UDP，这两个代理的 traffic 源分别为 FTP 和 CBR，然后把代理绑定到对应的节点上，把 traffic 绑定到对应的代理上。 set &lt;tcpname&gt; [new Agent/TCP]：创建一个名为 tcpname 的代理。总的来说，用户都是以这种方式创建任何代理或 traffic 源。代理和 traffic 源其实是基本对象（非复合对象），它们是基于 C++ 实现的，然后连接到 OTcl 上，因此没有特殊的 Simulator 对象的成员函数来创建这些对象实例。用户应该知晓这些代理和 traffic 源对象的类名，如 Agent/TCP，Agent/TCPSink，Application/FTP 等等，详细可参看 NS2 的文档，在文件 ns-2.35/tcl/lib/ns-default.tcl 也可以找到相关信息，文件中包含了可使用的网络对象的默认参数值设置，因此，它可以很好的告诉我们哪种网络对象在 NS2 中可以使用，可设置的参数有哪些。 $ns attach-agent &lt;node&gt; &lt;agent&gt;：为节点绑定代理。事实上，这个attach-agent函数调用节点的成员函数attach来完成绑定工作，因此也可以使用如 $n0 attach $tcp0 将 节点 代理 tcp0 绑定到节点 n0 上。 $ns connect &lt;agent1&gt; &lt;agent2&gt;：创建了两个代理之后，下一步就是建立逻辑网络连接，通过这一行语句，代理间将对方的网络和端口地址设置为目的地址，从而建立网络连接。 编写模拟场景假设所有的网络设置已经完成了，接下来就该编写模拟场景 scenario。Simulator 对象有许多调度成员函数，下面这个是最经常被使用的： $ns at &lt;time&gt; &quot;&lt;string&gt;&quot;：让调度器在指定的 time 时执行 string 中的命令。如 $ns at 0.1 &quot;$cbr start&quot;，让调度器调用 CBR traffic 源对象的一个名为 start 的成员函数，start 会开始启动 CBR 发送数据。在 NS2 中，一个 traffic 源通常不会发生真实的数据，它会通知下层的代理『有一些数据要发生』，代理就会知道有多少数据要发生，然后由代理创建 packet 并发送出去。 开始模拟配置好网络，写好调度程序和指定模拟后的数据保存操作之后，最后开始模拟即可，脚本中的最后一句：$ns run 声明开始模拟。 参考：WPI","content":"<p>我们在前<a href=\"/2020/04/ns2-simulation-overview\">一篇文章</a>中简单介绍了 NS2，它是一个离散事件驱动的网络模拟器，从具体实现来看，它就是一个 OTcl 脚本解释器，由模拟事件调度程序、网络组件对象库和网络启动(plumbing)模块库组成。文中还介绍了这些部分是如何一起协同实现网络模拟的。有了关于 NS2 的基本概念，下面就来看一个具体的模拟示例，看看 OTcl 脚本如何编写，如何进行一个网络模拟吧。<br><a id=\"more\"></a></p>\n<h2 id=\"OTcl-脚本编写\"><a href=\"#OTcl-脚本编写\" class=\"headerlink\" title=\"OTcl 脚本编写\"></a>OTcl 脚本编写</h2><p>前面提到，NS2 是一个 OTcl 解释器，在它上面进行模拟就需要编写 OTcl 脚本。在介绍 OTcl 编写之前，我们需要知道 Tcl 和 OTcl 的关系就像 C 和 C++ 的关系一样，在前者的基础上，后者增加了面向对象特性，下面就来看看 Tcl 和 OTcl 脚本如何编写吧。</p>\n<h3 id=\"Tcl-脚本\"><a href=\"#Tcl-脚本\" class=\"headerlink\" title=\"Tcl 脚本\"></a>Tcl 脚本</h3><p>一份 Tcl 脚本如下所示，需要关注的点如表所示，详细可以参考<a href=\"https://yiibai.com/tcl\" target=\"_blank\" rel=\"noopener\">易百教程</a>，对于基本的 NS2 脚本编写，了解这些就够了。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">操作</th>\n<th style=\"text-align:left\">关键字</th>\n<th style=\"text-align:left\">格式</th>\n<th style=\"text-align:left\">示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">定义 procedure</td>\n<td style=\"text-align:left\"><code>proc</code></td>\n<td style=\"text-align:left\"><code>proc &lt;procname&gt; {&lt;argumentlist&gt;} {&lt;contents&gt;}</code></td>\n<td style=\"text-align:left\">第 2 行</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">定义变量</td>\n<td style=\"text-align:left\"><code>set</code></td>\n<td style=\"text-align:left\"><code>set &lt;variablename&gt; &lt;variablevalue&gt;</code></td>\n<td style=\"text-align:left\">第 3 行</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">表达式值替换</td>\n<td style=\"text-align:left\"><code>expr</code></td>\n<td style=\"text-align:left\"><code>[expr &lt;expression&gt;]</code></td>\n<td style=\"text-align:left\">第 5 行</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">变量值替换</td>\n<td style=\"text-align:left\"><code>$</code></td>\n<td style=\"text-align:left\"><code>$&lt;variablename&gt;</code></td>\n<td style=\"text-align:left\">第 5 行</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">输出</td>\n<td style=\"text-align:left\"><code>puts</code></td>\n<td style=\"text-align:left\"><code>puts &quot;&lt;contents&gt;&quot;</code></td>\n<td style=\"text-align:left\">第 9 行</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">for 循环</td>\n<td style=\"text-align:left\"><code>for</code></td>\n<td style=\"text-align:left\"><code>for {&lt;initial&gt;} {&lt;condition&gt;} {actioneveryloop} {&lt;mainLoopExpression&gt;}</code></td>\n<td style=\"text-align:left\">第 7 行</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">if 条件选择语句</td>\n<td style=\"text-align:left\"><code>if</code></td>\n<td style=\"text-align:left\"><code>if {&lt;condition&gt;} {&lt;expression&gt;}</code></td>\n<td style=\"text-align:left\">第 8 行</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight tcl\"><figcaption><span>ex-tcl.tcl</span><a href=\"/downloads/code/ex-tcl.tcl\">view raw</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 定义一个 procedure</span></span><br><span class=\"line\"><span class=\"keyword\">proc</span><span class=\"title\"> test</span> {} {</span><br><span class=\"line\">    <span class=\"keyword\">set</span> a <span class=\"number\">43</span></span><br><span class=\"line\">    <span class=\"keyword\">set</span> b <span class=\"number\">27</span></span><br><span class=\"line\">    <span class=\"keyword\">set</span> c [<span class=\"keyword\">expr</span> $a + $b]</span><br><span class=\"line\">    <span class=\"keyword\">set</span> d [<span class=\"keyword\">expr</span> [<span class=\"keyword\">expr</span> $a - $b] * $c]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> {<span class=\"keyword\">set</span> k <span class=\"number\">0</span>} {$k &lt; <span class=\"number\">10</span>} {<span class=\"keyword\">incr</span> k} {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> {$k &lt; <span class=\"number\">5</span>} {</span><br><span class=\"line\">            <span class=\"keyword\">puts</span> <span class=\"string\">\"k &lt; 5, pow = [expr pow($d, $k)]\"</span></span><br><span class=\"line\">        } else {</span><br><span class=\"line\">            <span class=\"keyword\">puts</span> <span class=\"string\">\"k &gt;= 5, mod = [expr $d % $k]\"</span></span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\"># 调用 procedure test</span></span><br><span class=\"line\">test</span><br></pre></td></tr></table></figure>\n<p>将文件保存为 <code>ex-tcl.tcl</code>，然后在Shell中执行 <code>ns ex-tcl.tcl</code>，得到的的输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">k &lt; 5, pow = 1.0</span><br><span class=\"line\">k &lt; 5, pow = 1120.0</span><br><span class=\"line\">k &lt; 5, pow = 1254400.0</span><br><span class=\"line\">k &lt; 5, pow = 1404928000.0</span><br><span class=\"line\">k &lt; 5, pow = 1573519360000.0</span><br><span class=\"line\">k &gt;= 5, mod = 0</span><br><span class=\"line\">k &gt;= 5, mod = 4</span><br><span class=\"line\">k &gt;= 5, mod = 0</span><br><span class=\"line\">k &gt;= 5, mod = 0</span><br><span class=\"line\">k &gt;= 5, mod = 4</span><br></pre></td></tr></table></figure>\n<h3 id=\"OTcl-脚本\"><a href=\"#OTcl-脚本\" class=\"headerlink\" title=\"OTcl 脚本\"></a>OTcl 脚本</h3><p>相比于 Tcl，OTcl 增加了面向对象功能，下面这个例子展示了 OTcl 中对象是如何被创建和使用的。作为一个 NS2 的使用者，我们可能不会需要编写自己的 OTcl 对象，但是了解它们还是很有帮助的，因为我们在 NS2 模拟中使用的所有的对象，无论它们是 C++ 编写后连接到 OTcl 还是是直接使用OTcl 编写的，它们本质上都是 OTcl 对象。</p>\n<p>下面这个例子中创建了两个类 <code>mom</code> 和 <code>kid</code>，它们都有成员函数 <code>greet</code>，声明类之后，在第 17~19 行我们对类进行了实例化，并定义了实例的成员变量的值，然后在 23、24 行调用了两个实例的成员函数。从代码从我们很容易可以看出：</p>\n<ul>\n<li>如何对类进行实例化？</li>\n<li>如何改变类实例的成员变量的值？</li>\n<li>如何调用类实例的成员函数？</li>\n</ul>\n<p>那么如何定义一个类和子类呢？定义一个类需要使用关键字 <code>Class</code> 创建一个类，使用关键字 <code>instproc</code> 定义类的成员函数。类的继承使用关键字 <code>-superclass</code>，在成员函数中，<code>$self</code> 的作用就好像 C++ 中的 <code>this</code> 指针一样，关键字 <code>instvar</code> 检查后面紧跟的变量名是否已在类或父类中被声明，如果已经被声明，那这个变量就是已声明变量的引用，反之，这就是一个新的变量声明。最后，创建一个类实例，需要使用关键字 <code>new</code>。</p>\n<figure class=\"highlight tcl\"><figcaption><span>ex-otcl.tcl</span><a href=\"/downloads/code/ex-otcl.tcl\">view raw</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># add a member function called \"greet\"</span></span><br><span class=\"line\">Class mom</span><br><span class=\"line\">mom instproc greet {} {</span><br><span class=\"line\">    $self instvar age_</span><br><span class=\"line\">    <span class=\"keyword\">puts</span> <span class=\"string\">\"$age_ year old mom say:</span></span><br><span class=\"line\"><span class=\"string\">        How are you doing\"</span></span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\"># child class</span></span><br><span class=\"line\">Class kid -superclass mom</span><br><span class=\"line\">kid instproc greet {} {</span><br><span class=\"line\">    $self instvar age_</span><br><span class=\"line\">    <span class=\"keyword\">puts</span> <span class=\"string\">\"$age_ year old kid say:</span></span><br><span class=\"line\"><span class=\"string\">        What's up, dude?'\"</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># creat instance</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> a [new mom]</span><br><span class=\"line\">$a <span class=\"keyword\">set</span> age_ <span class=\"number\">45</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> b [new kid]</span><br><span class=\"line\">$b <span class=\"keyword\">set</span> age_ <span class=\"number\">15</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># calling member function</span></span><br><span class=\"line\">$a greet</span><br><span class=\"line\">$b greet</span><br></pre></td></tr></table></figure>\n<p>文件保存为 <code>ex-otcl.tcl</code>，在 Bash 中执行 <code>ns ex-otcl.tcl</code>，得到如下的输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">45 year old mom say:</span><br><span class=\"line\">        How are you doing</span><br><span class=\"line\">15 year old kid say:</span><br><span class=\"line\">        What&apos;s up, dude?&apos;</span><br></pre></td></tr></table></figure>\n<h2 id=\"简单的-NS2-模拟示例\"><a href=\"#简单的-NS2-模拟示例\" class=\"headerlink\" title=\"简单的 NS2 模拟示例\"></a>简单的 NS2 模拟示例</h2><p>现在我们已经知道了基本的 OTcl 脚本是如何编写的了，现在来看看如何编写一个执行 NS2 模拟的 OTcl 脚本吧。<br>下面的 <code>ns-simple.tcl</code> OTcl 脚本中进行了简单的网络配置，执行如图所示的模拟方案。下载代码后，在 Bash 中执行 <code>ns ns-simple.tcl</code> 即可。</p>\n<p><div align=\"center\" class=\"img\"><br>    <img src=\"/assets/img/2020/simple_simulation_scenario.png\" alt=\"structure_of_ns2\" width=\"750\"><br>    <span align=\"center\" style=\"color:#999\">一个简单的网络拓扑和模拟方案示意图</span><br></div><br>从图中可以看到，这个网络包括四个节点：n0，n1，n2和n3。n0 和 n2 间是双向连接，n1 和 n2 间的连接有 2Mpbs 的带宽，传输时延为 10ms。n2 和 n3 之间为双向连接，传输带宽为 1.7Mbps，传输时延为 20ms。每个节点都使用一个 DropTail 队列，队列最大长度为 10。<br>n0 节点上绑定了一个 tcp 代理，该代理和绑定在 n3 上的『sink』代理间构建了一条连接 (connection)。默认情况下，tcp 代理可以生成的最大 packet 为 1KByte。tcp『sink』代理生成确认接受分组 P 的 ACK 并将 ACk 发送给分组的发送者（即发送分组 P 的 tcp 代理），然后释放接收到的分组 P。<br>n1 节点上绑定了一个 udp 代理，该代理和绑定在 n3 上的『null』代理间建立了一条连接。『null』代理字释放接收到的 packet，不会向 packet 的发送方发送 ACK。<br>ftp 和 cbr 是 traffic 生成器，分别绑定到 tcp 和 udp 代理上。cbr 被设定为可以生成以 1Mbps 的速率生成 1KByte 大小的 packet，它在 0.1s 时开始工作到 4.5s 时停止，而 ftp 在 1.0s 时开始工作到 4.0s 停止。</p>\n<figure class=\"highlight tcl\"><figcaption><span>ns-simple.tcl</span><a href=\"/downloads/code/ns-simple.tcl\">view raw</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># create a simulator object</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> ns [new Simulator]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># set color for NAM</span></span><br><span class=\"line\">$ns color <span class=\"number\">1</span> blue</span><br><span class=\"line\">$ns color <span class=\"number\">2</span> red</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># creat four Nodes</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> n0 [$ns node]</span><br><span class=\"line\"><span class=\"keyword\">set</span> n1 [$ns node]</span><br><span class=\"line\"><span class=\"keyword\">set</span> n2 [$ns node]</span><br><span class=\"line\"><span class=\"keyword\">set</span> n3 [$ns node]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># open NAM file and trace file</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> f [<span class=\"keyword\">open</span> out.tr w]</span><br><span class=\"line\">$ns <span class=\"keyword\">trace</span>-all $f</span><br><span class=\"line\">set nf [<span class=\"keyword\">open</span> out.nam w]</span><br><span class=\"line\">$ns namtrace-all $nf</span><br><span class=\"line\"></span><br><span class=\"line\"># 设置节点间的连接</span><br><span class=\"line\">$ns duplex-link $n0 $n2 <span class=\"number\">2</span>Mb <span class=\"number\">10</span>ms DropTail</span><br><span class=\"line\">$ns duplex-link $n1 $n2 <span class=\"number\">2</span>Mb <span class=\"number\">10</span>ms DropTail</span><br><span class=\"line\">$ns duplex-link $n2 $n3 <span class=\"number\">1.7</span>Mb <span class=\"number\">20</span>ms DropTail</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置 n2 n3 队列大小</span></span><br><span class=\"line\">$ns queue-limit $n2 $n3 <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置 NAM 中节点的位置</span></span><br><span class=\"line\">$ns duplex-link-op $n0 $n2 orient right-down</span><br><span class=\"line\">$ns duplex-link-op $n1 $n2 orient right-up</span><br><span class=\"line\">$ns duplex-link-op $n2 $n3 orient right</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># NAM 设置</span></span><br><span class=\"line\">$ns duplex-link-op $n2 $n3 queuePos <span class=\"number\">0.5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置 TCP 连接</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> tcp [new Agent/TCP]</span><br><span class=\"line\">$tcp <span class=\"keyword\">set</span> class_ <span class=\"number\">2</span></span><br><span class=\"line\">$ns attach-agent $n0 $tcp</span><br><span class=\"line\">set sink [new Agent/TCPSink]</span><br><span class=\"line\">$ns attach-agent $n3 $sink</span><br><span class=\"line\">$ns connect $tcp $sink</span><br><span class=\"line\"># 在 TCP 连接上启动 FTP</span><br><span class=\"line\"><span class=\"keyword\">set</span> ftp [new Application/FTP]</span><br><span class=\"line\">$ftp attach-agent $tcp</span><br><span class=\"line\">$ftp <span class=\"keyword\">set</span> type_ FTP</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置 UDP 连接</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> udp [new Agent/UDP]</span><br><span class=\"line\">$ns attach-agent $n1 $udp</span><br><span class=\"line\">set null [new Agent/Null]</span><br><span class=\"line\">$ns attach-agent $n3 $null</span><br><span class=\"line\">$ns connect $udp $null</span><br><span class=\"line\">$udp <span class=\"keyword\">set</span> fid_ <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"comment\"># 在 UDP 连接上设置 CBR</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> cbr [new Application/Traffic/CBR]</span><br><span class=\"line\">$cbr attach-agent $udp</span><br><span class=\"line\">$cbr <span class=\"keyword\">set</span> type_ CBR</span><br><span class=\"line\">$cbr <span class=\"keyword\">set</span> packet_size_ <span class=\"number\">1000</span></span><br><span class=\"line\">$cbr <span class=\"keyword\">set</span> random_ false</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 为CBR 和 FTP 代理调度事件</span></span><br><span class=\"line\">$ns at <span class=\"number\">0.1</span> <span class=\"string\">\"$cbr start\"</span></span><br><span class=\"line\">$ns at <span class=\"number\">1.0</span> <span class=\"string\">\"$ftp start\"</span></span><br><span class=\"line\">$ns at <span class=\"number\">4.0</span> <span class=\"string\">\"$ftp stop\"</span></span><br><span class=\"line\">$ns at <span class=\"number\">4.5</span> <span class=\"string\">\"$cbr stop\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 释放tcp和sink代理 会自动释放</span></span><br><span class=\"line\">$ns at <span class=\"number\">4.5</span> <span class=\"string\">\"ns detach-agent $n0 $tcp ; $ns detach-agent $n3 $sink\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 调用 finish 步骤</span></span><br><span class=\"line\">$ns at <span class=\"number\">5.0</span> <span class=\"string\">\"finish\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">proc</span><span class=\"title\"> finish</span> {} {</span><br><span class=\"line\">    <span class=\"keyword\">global</span> ns f nf</span><br><span class=\"line\">    $ns <span class=\"keyword\">flush</span>-<span class=\"keyword\">trace</span></span><br><span class=\"line\">    <span class=\"keyword\">close</span> $f</span><br><span class=\"line\">    <span class=\"keyword\">close</span> $nf</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">puts</span> <span class=\"string\">\"running nam...\"</span></span><br><span class=\"line\">    <span class=\"keyword\">exec</span> nam out.nam &amp;</span><br><span class=\"line\">    <span class=\"keyword\">exit</span> <span class=\"number\">0</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">puts</span> <span class=\"string\">\"CBR packet size = [$cbr set packet_size_]\"</span></span><br><span class=\"line\"><span class=\"keyword\">puts</span> <span class=\"string\">\"CBR interval = [$cbr set interval_]\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ns run</span><br></pre></td></tr></table></figure>\n<h3 id=\"从-Simulator-对象开始网络的基本设置\"><a href=\"#从-Simulator-对象开始网络的基本设置\" class=\"headerlink\" title=\"从 Simulator 对象开始网络的基本设置\"></a>从 Simulator 对象开始网络的基本设置</h3><p>下面是对上述脚本的解释，总体上来看，NS 脚本从创建一个 Simulator 对象实例开始。<br><strong>注意</strong>：代码中，<code>&lt;&gt;</code> 包围的内容在使用时要按照实际情况替代成正确的内容。</p>\n<ul>\n<li><code>set ns [new Simulator]</code>：生成一个 NS2 simulator 对象实例为 ns。这一行代码完成了一些工作：<ul>\n<li>初始化 packet 格式</li>\n<li>创建一个调度器（默认为 calendar 调度器）</li>\n<li>选择默认的地址格式</li>\n</ul>\n</li>\n</ul>\n<p>Simulator 的成员函数可以完成如下工作：</p>\n<ul>\n<li>创建一些复合对象，如节点 node 和 连接 link</li>\n<li>连接网络组件对象</li>\n<li>设置网络组件对象的参数</li>\n<li>创建代理间的连接，如 tcp 和 sink 间的连接</li>\n<li>明确 NAM 展示的选项等等</li>\n</ul>\n<p>大多数成员函数用于模拟设置（如 plumbing 函数）和调度，也有一些用于 NAM 展示的设置。Simulator 对象成员函数在文件 <code>ns-2.35/tcl/lib/ns-lib.tcl</code> 中实现。</p>\n<ul>\n<li><code>$ns color &lt;fid&gt; &lt;color&gt;</code>：为流 id 即 fid 确定的流中 packet 设置颜色。该 Simulator 对象的成员函数为 NAM 展示服务，对实际的模拟有影响。</li>\n<li><code>$ns namtrace-all &lt;file-descrption&gt;</code>：这个成员函数告诉模拟器（simulator）按照 NAM 的输入的格式记录模拟痕迹（trace）到文件中，同时也给出了 <code>$ns flush-trace</code> 命令要写入的文件。类似的，函数 <code>trace-all</code> 用来记录模拟痕迹（trace），但是是基本的格式。</li>\n<li><code>proc finish {}</code>：一个模拟结束够调用的函数，通过 <code>$ns at 5.0 &quot;finish&quot;</code> 调用。在函数中，定义了模拟后的后续操作，如保存文件。</li>\n<li><code>set n0 [$ns node]</code>：成员函数 <code>node</code> 创建一个节点 node0。NS2 中的节点是一个复合类，由地址和端口分类器组成。用户创建节点时，也可以分别创建一个地址和端口分类器对象，然后再把它们连接起来，但是这个 Simulator 成员函数让节点创建变得简单。文件 <code>ns-2.35/tcl/lib/ns-lib.tcl</code> 和 <code>ns-2.35/tcl/lib/ns-node.tcl</code> 中有关于创建节点的详细信息。</li>\n<li><code>$ns duplex-link &lt;node1&gt; &lt;node2&gt; &lt;bandwidth&gt; &lt;delay&gt; &lt;queue-type&gt;</code>：创建两条单向连接，指定带宽和时延，然后连接声明的两个节点。在 NS2 中，节点的输出队列实现为一个连接的一部分，因此用户在创建连接时要指明队列类型 queue-type。上面的代码中使用的 DropTail 队列，如果想使用其他队列，修改队列类型即可。连接的实现在下一篇文章会提到，类似节点，连接也是一个复合类型，用户可以创建出它的子对象然后把他们和节点连接起来。有关连接的源代码在文件 <code>ns-2.35/tcl/lib/ns-lib.tcl</code> 和 <code>ns-2.35/tcl/lib/ns-link.tcl</code> 中。在连接模块中，我们可以进行很多个性化的操作，详请参考 NS2 文档。</li>\n<li><code>$ns queue-limit &lt;node1&gt; &lt;node2&gt; &lt;number&gt;</code>：设置两条连接 node1 和 node2 单向连接的队列大小。</li>\n<li><code>$ns duplex-link-op &lt;node1&gt; &lt;node2&gt; ...</code>：NAM 展示的设置，即设置节点的位置。</li>\n</ul>\n<h3 id=\"设置代理和-traffic-源\"><a href=\"#设置代理和-traffic-源\" class=\"headerlink\" title=\"设置代理和 traffic 源\"></a>设置代理和 traffic 源</h3><p>现在，基本的网络设置以及完成了，下一就是启动 traffic 代理，如 TCP 和 UDP，这两个代理的 traffic 源分别为 FTP 和 CBR，然后把代理绑定到对应的节点上，把 traffic 绑定到对应的代理上。</p>\n<ul>\n<li><code>set &lt;tcpname&gt; [new Agent/TCP]</code>：创建一个名为 tcpname 的代理。总的来说，用户都是以这种方式创建任何代理或 traffic 源。代理和 traffic 源其实是基本对象（非复合对象），它们是基于 C++ 实现的，然后连接到 OTcl 上，因此没有特殊的 Simulator 对象的成员函数来创建这些对象实例。用户应该知晓这些代理和 traffic 源对象的类名，如 Agent/TCP，Agent/TCPSink，Application/FTP 等等，详细可参看 NS2 的文档，在文件 <code>ns-2.35/tcl/lib/ns-default.tcl</code> 也可以找到相关信息，文件中包含了可使用的网络对象的默认参数值设置，因此，它可以很好的告诉我们哪种网络对象在 NS2 中可以使用，可设置的参数有哪些。</li>\n<li><code>$ns attach-agent &lt;node&gt; &lt;agent&gt;</code>：为节点绑定代理。事实上，这个<code>attach-agent</code>函数调用节点的成员函数<code>attach</code>来完成绑定工作，因此也可以使用如 <code>$n0 attach $tcp0</code> 将 节点 代理 tcp0 绑定到节点 n0 上。</li>\n<li><code>$ns connect &lt;agent1&gt; &lt;agent2&gt;</code>：创建了两个代理之后，下一步就是建立逻辑网络连接，通过这一行语句，代理间将对方的网络和端口地址设置为目的地址，从而建立网络连接。</li>\n</ul>\n<h3 id=\"编写模拟场景\"><a href=\"#编写模拟场景\" class=\"headerlink\" title=\"编写模拟场景\"></a>编写模拟场景</h3><p>假设所有的网络设置已经完成了，接下来就该编写模拟场景 scenario。Simulator 对象有许多调度成员函数，下面这个是最经常被使用的：</p>\n<ul>\n<li><code>$ns at &lt;time&gt; &quot;&lt;string&gt;&quot;</code>：让调度器在指定的 time 时执行 string 中的命令。如 <code>$ns at 0.1 &quot;$cbr start&quot;</code>，让调度器调用 CBR traffic 源对象的一个名为 start 的成员函数，start 会开始启动 CBR 发送数据。在 NS2 中，一个 traffic 源通常不会发生真实的数据，它会通知下层的代理『有一些数据要发生』，代理就会知道有多少数据要发生，然后由代理创建 packet 并发送出去。</li>\n</ul>\n<h3 id=\"开始模拟\"><a href=\"#开始模拟\" class=\"headerlink\" title=\"开始模拟\"></a>开始模拟</h3><p>配置好网络，写好调度程序和指定模拟后的数据保存操作之后，最后开始模拟即可，脚本中的最后一句：<code>$ns run</code> 声明开始模拟。</p>\n<hr>\n<p>参考：<a href=\"http://nile.wpi.edu.cn/NS/\" target=\"_blank\" rel=\"noopener\">WPI</a></p>\n","tags":[{"name":"网络","slug":"网络","permalink":"https://jonathan1214.github.io/tags/网络/"},{"name":"NS2","slug":"NS2","permalink":"https://jonathan1214.github.io/tags/NS2/"}]},{"title":"NS2 的介绍（一）—— 概述","date":"2020-04-02T08:15:03.000Z","path":"2020/04/ns2-simulation-overview/","text":"最近在上一门叫『无线自组织网络与应用』的课程，介绍了很多以前没有接触过的概念，包括了一个叫 NS2 的仿真工具，在前面一篇文章中介绍的 AHOHA 协议也是在这门课程中有被详细讲述的。这篇文章基本上是这篇文章的翻译，介绍 NS2 这个仿真工具，给出这个它的概述。 NS2是什么NS2 是一个使用 C++ 和 OTcl 编写的面向对象的离散事件驱动的网络仿真器，在 UCBerkely 被开发出来。它主要用于局域网和广域网仿真。由于缺少适合新手入门的教程，NS2对于初学者来说不是很友好。 概述NS2 可以仿真各种各样的IP网络。它实现了一些网络协议如 TCP 和 UDP，文件传输协议如 FTP、Telnet、Web、CBR 和 VBR，路由队列管理机制如 DropTail、RED 和 CBQ，路由选择算法如 Dijkstra，等等。针对局域网仿真，NS2 还实现了组播和一些 MAC 层协议。这里要介绍的是 NS2 的基本结构，然后按照例子介绍细节。 用户角度的NS概览NS2 是 OTcl 脚本解释器，包括仿真事件调度程序、网络组件对象库和网络启动 (plumbing) 模块库。plumbing 模块通常实现为基本模拟对象成员函数。换句话说，使用 NS2，你需要使用 OTcl 语言写一个脚本，包括以下内容： 初始化一个事件调度程序 使用网络对象和 plumbing 函数建立网络拓扑结构 通过事件调度程序告知何时开始发送分组 network object 网络对象plumbing 函数通过为对象设定指向合适的对象的邻居指针，在网络对象中探索可能的数据通路，进而建立起整个网络。如此一来，使用者想要创建一个新的网络对象变得简单，只需写一个新的对象或者从对象库中创建一个复合对象，然后探索 (plumb) 通过这个新对象的数据通路即可。听起来比较复杂，但是 plumbing OTcl 模块让这一切变得非常简单，这也是 NS2 的强大之处。 event scheduler 事件调度程序除网络对象外，NS2 中另一个主要的组件就是事件调度程序。在 NS2 中，一个事件就是一个包 ID，这个 ID 是唯一的，涵盖了分配时间，以及用来处理该事件的指向下一个对象的指针。在 NS2 中，一个事件调度程序记录着模拟时间，并通过调用适当的网络组件启动在事件队列中调度好的应该在当前启动的所有事件，这些组件通常是发出事件并让事件与事件指出的包一起完成正确的指令。网络组件间进行通信，传递 packet，但是并不会消耗真实的仿真时间。所有需要消耗仿真时间来处理 packet 的网络组件通过使用事件调度程序完成，组件为待处理到packet发出一个事件然后等待组件自己启动事件，再进行进一步的行动处理 packet。 举个例子，一个网络转发组件S模拟一次转发的延时为 20us，它为一个需要转发的 packet P 向调度程序发出一个延时 20us 的事件 E，20us 后，调度程序 M 从事件队列中调度出这个事件 E 并把它立即发给转发组件 S ，然后由转发组件 S 将 packet P 交给适当的输出链接组件。 还有一种用法将事件调度程序当作计时器。比如，TCP 需要一个计时器记录一个 packet 的发送时间以备重发（发送一个具有相同 TCP 编号且不同 NS packet ID 的 packet）。计时器和延时器用类似的方式使用事件调度程序，不同之处在于计时器计算与 packet 相关的时间值，然后一段特定的时间过去后对该 packet 做合适的动作（如上面那个例子，计算 packet 的发送时间，如果超过预定时间重发该 packet），而不是模拟一个延时， C++ 与 NS2NS2 不仅可以用 OTcl 编写也可以用 C++ 编写。处于效率考量，NS2 将数据路径的实现和控制路径的实现分离开来，为了减少 packet 和事件的处理时间（注意，不是仿真时间），数据路径中的事件调度程序和基本网络组件对象用 C++ 编写然后编译，使用编译好的对象，OTcl 解释器通过一个 OTcl 连接为每一个 C++ 对象创建配对的 OTcl 对象，为成员函数创建配对的控制函数，为成员变量创建配对的配置变量，这样一来，对 C++ 对象的控制就传递给了 OTcl。向一个连接到 OTcl 的 C++ 对象中添加成员函数也是可能的，C++ 对象中不需要在一次模拟中被控制的或者不需要在内部被其他对象使用使用的，是不需要被连接到 OTcl 中。同样地，一个不在数据路径中的对象也可以使用 OTcl 实现。如图为一个对象在 C++ 和 OTcl 中的层次体系，可以看到，连接到 C++ 的 OTcl 对象和它连接的 C++ 对象具有相同的层次结构。 C++ 和 OTcl 的连接 NS2 的大体结构如图为 NS2 的整体结构，使用者站在图中的左下角，在 Tcl 中，使用 OTcl 库中的仿真对象设计并控制模拟。事件调度程序和绝大多数网络组件是通过 C++ 实现的，并且 OTcl 通过 OTcl 连接 (linkage) 可以使用到它们，而这个连接是通过 tclcl 实现的。这些东西共同构成了 NS2，它就是一个扩展了面向对象的 Tcl 解释器和网络模拟库。 NS2 的体系结构图 小结本文简单分析了 NS2 的大体结构和体系结构。现在来考虑下如何获得 NS2 的仿真结果，如第一张图所示，，当仿真结束时，NS2 按照输入的 Tcl（或 OTcl）脚本中的说明产生一个或者多个文本输出文件，其中包含了详细的仿真数据。这些数据可用于后续的仿真分析中，或者作为图形化仿真展示工具 NAM 的输入。 参考：WPI 大学的资源","content":"<p>最近在上一门叫『无线自组织网络与应用』的课程，介绍了很多以前没有接触过的概念，包括了一个叫 NS2 的仿真工具，在前面<a href=\"/2020/03/latex-notes-1-basic-concepts/\">一篇文章</a>中介绍的 AHOHA 协议也是在这门课程中有被详细讲述的。这篇文章基本上是<a href=\"http://nile.wpi.edu.cn/NS/\" target=\"_blank\" rel=\"noopener\">这篇文章</a>的翻译，介绍 NS2 这个仿真工具，给出这个它的概述。<br><a id=\"more\"></a></p>\n<h2 id=\"NS2是什么\"><a href=\"#NS2是什么\" class=\"headerlink\" title=\"NS2是什么\"></a>NS2是什么</h2><p>NS2 是一个使用 C++ 和 OTcl 编写的面向对象的离散事件驱动的网络仿真器，在 UCBerkely 被开发出来。它主要用于局域网和广域网仿真。由于缺少适合新手入门的教程，NS2对于初学者来说不是很友好。</p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>NS2 可以仿真各种各样的IP网络。它实现了一些网络协议如 TCP 和 UDP，文件传输协议如 FTP、Telnet、Web、CBR 和 VBR，路由队列管理机制如 DropTail、RED 和 CBQ，路由选择算法如 Dijkstra，等等。针对局域网仿真，NS2 还实现了组播和一些 MAC 层协议。这里要介绍的是 NS2 的基本结构，然后按照例子介绍细节。</p>\n<p><div align=\"center\" class=\"img\"><br>    <img src=\"/assets/img/2020/structure_of_ns2.png\" alt=\"structure_of_ns2\" width=\"750\"><br>    <span align=\"center\" style=\"color:#999\">用户角度的NS概览</span><br></div><br>NS2 是 OTcl 脚本解释器，包括仿真事件调度程序、网络组件对象库和网络启动 (plumbing) 模块库。plumbing 模块通常实现为基本模拟对象成员函数。换句话说，使用 NS2，你需要使用 OTcl 语言写一个脚本，包括以下内容：</p>\n<ul>\n<li>初始化一个事件调度程序</li>\n<li>使用网络对象和 plumbing 函数建立网络拓扑结构</li>\n<li>通过事件调度程序告知何时开始发送分组</li>\n</ul>\n<h3 id=\"network-object-网络对象\"><a href=\"#network-object-网络对象\" class=\"headerlink\" title=\"network object 网络对象\"></a>network object 网络对象</h3><p>plumbing 函数通过为<em>对象设定指向合适的对象的邻居指针</em>，在网络对象中探索可能的数据通路，进而建立起整个网络。如此一来，使用者想要创建一个新的网络对象变得简单，只需写一个新的对象或者从对象库中创建一个复合对象，然后探索 (plumb) 通过这个新对象的数据通路即可。<br>听起来比较复杂，但是 plumbing OTcl 模块让这一切变得非常简单，这也是 NS2 的强大之处。</p>\n<h3 id=\"event-scheduler-事件调度程序\"><a href=\"#event-scheduler-事件调度程序\" class=\"headerlink\" title=\"event scheduler 事件调度程序\"></a>event scheduler 事件调度程序</h3><p>除网络对象外，NS2 中另一个主要的组件就是事件调度程序。在 NS2 中，一个事件就是一个包 ID，这个 ID 是唯一的，涵盖了分配时间，以及用来处理该事件的指向下一个对象的指针。在 NS2 中，一个事件调度程序<strong>记录着模拟时间</strong>，并通过调用适当的网络组件启动在<strong>事件队列</strong>中调度好的应该在当前启动的所有事件，这些组件通常是发出事件并让事件与事件指出的包一起完成正确的指令。网络组件间进行通信，传递 packet，但是并不会消耗真实的仿真时间。所有需要消耗仿真时间来处理 packet 的网络组件通过使用事件调度程序完成，组件为待处理到packet发出一个事件然后等待组件自己启动事件，再进行进一步的行动处理 packet。</p>\n<p>举个例子，一个网络转发组件S模拟一次转发的延时为 20us，它为一个需要转发的 packet P 向调度程序发出一个延时 20us 的事件 E，20us 后，调度程序 M 从事件队列中调度出这个事件 E 并把它立即发给转发组件 S ，然后由转发组件 S 将 packet P 交给适当的输出链接组件。</p>\n<p>还有一种用法将事件调度程序当作计时器。比如，TCP 需要一个计时器记录一个 packet 的发送时间以备重发（发送一个具有相同 TCP 编号且不同 NS packet ID 的 packet）。计时器和延时器用类似的方式使用事件调度程序，不同之处在于计时器计算与 packet 相关的时间值，然后一段特定的时间过去后对该 packet 做合适的动作（如上面那个例子，计算 packet 的发送时间，如果超过预定时间重发该 packet），而不是模拟一个延时，</p>\n<h2 id=\"C-与-NS2\"><a href=\"#C-与-NS2\" class=\"headerlink\" title=\"C++ 与 NS2\"></a>C++ 与 NS2</h2><p>NS2 不仅可以用 OTcl 编写也可以用 C++ 编写。处于效率考量，NS2 将<strong>数据路径</strong>的实现和<strong>控制路径</strong>的实现分离开来，为了减少 packet 和事件的处理时间（注意，不是仿真时间），数据路径中的事件调度程序和基本网络组件对象用 C++ 编写然后编译，使用编译好的对象，OTcl 解释器通过一个 OTcl 连接为每一个 C++ 对象创建配对的 OTcl 对象，为成员函数创建配对的控制函数，为成员变量创建配对的配置变量，这样一来，对 C++ 对象的控制就传递给了 OTcl。向一个连接到 OTcl 的 C++ 对象中添加成员函数也是可能的，C++ 对象中不需要在一次模拟中被控制的或者不需要在内部被其他对象使用使用的，是不需要被连接到 OTcl 中。同样地，一个不在数据路径中的对象也可以使用 OTcl 实现。如图为一个对象在 C++ 和 OTcl 中的层次体系，可以看到，连接到 C++ 的 OTcl 对象和它连接的 C++ 对象具有相同的层次结构。</p>\n<p align=\"center\" class=\"img\"><br>    <img src=\"/assets/img/2020/cpp_vs_otcl.png\" alt=\"cpp_vs_otcl\" width=\"750\"><br>    <span align=\"center\" style=\"color:#999\">C++ 和 OTcl 的连接</span><br></p>\n\n<h2 id=\"NS2-的大体结构\"><a href=\"#NS2-的大体结构\" class=\"headerlink\" title=\"NS2 的大体结构\"></a>NS2 的大体结构</h2><p>如图为 NS2 的整体结构，使用者站在图中的左下角，在 Tcl 中，使用 OTcl 库中的仿真对象设计并控制模拟。事件调度程序和绝大多数网络组件是通过 C++ 实现的，并且 OTcl 通过 OTcl 连接 (linkage) 可以使用到它们，而这个连接是通过 tclcl 实现的。这些东西共同构成了 NS2，它就是一个扩展了面向对象的 Tcl 解释器和网络模拟库。</p>\n<p align=\"center\" class=\"img\"><br>    <img src=\"/assets/img/2020/architecture_view_of_ns.png\" alt=\"architecture_view_of_ns\" width=\"750\"><br>    <span align=\"center\" style=\"color:#999\">NS2  的体系结构图</span><br></p>\n\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>本文简单分析了 NS2 的大体结构和体系结构。现在来考虑下如何获得 NS2 的仿真结果，如第一张图所示，，当仿真结束时，NS2 按照输入的 Tcl（或 OTcl）脚本中的说明产生一个或者多个文本输出文件，其中包含了详细的仿真数据。这些数据可用于后续的仿真分析中，或者作为图形化仿真展示工具 NAM 的输入。</p>\n<hr>\n<p>参考：<a href=\"http://nile.wpi.edu.cn/NS/\" target=\"_blank\" rel=\"noopener\">WPI 大学的资源</a></p>\n","tags":[{"name":"网络","slug":"网络","permalink":"https://jonathan1214.github.io/tags/网络/"},{"name":"NS2","slug":"NS2","permalink":"https://jonathan1214.github.io/tags/NS2/"}]},{"title":"在疫情中度过三月","date":"2020-03-31T12:14:59.000Z","path":"2020/03/the-third-month/","text":"惊觉已经是三月的最后一天，在这过去的一个月里，如果说有什么一定一提的，那一定是已经持续了快三个月的的新冠肺炎疫情，国内的疫情逐渐被控制住了，国外却又爆发了更大规模的，看起来返校遥遥无期。一月份的时候我肯定无法想象3月31日自己还在家，突发的疫情打乱我原有的计划，我本该在学校的教室里坐着的，现在却在家，本以为会非常非常想回学校，现在倒也还好，我只是怀念学校的WiFi罢了。疫情蔓延全球，经济衰退，股价暴跌，美股数次熔断，不可否认这是一个动荡的三月。所谓『祸兮福之所倚』，被困在山村中的我却得以享受宁静，可以专心做自己想做的事，我重新开始捡起以前学了一点就知难而退的东西，比如 C++，Java，Linux 还有算法，除此之外，我还开始坚持看书、记单词和记录生活，为了督促自己，我还使用 atimelogger 记录自己每一分钟的花销。如果不是因为疫情，我也不会如此百无聊赖，也就不会开始做这些事情，从这个角度而言，对我而言这还是福。 整个三月份，我看完了『乌合之众』、『金字塔原理』、『随机漫步的傻瓜』、『你的第一本哲学书』和『简单逻辑学』，平均一周看了一本多一点的书，还算可以，但是没有对其中任何一本书作一些读后感之类的笔记，算是一个不完整，希望在后面的阅读补上。这一个月也是折腾不断，看了算法看Linux，中间还去折腾下NS2——一坨年久失修的 shit。现在总结一下，算法是没看多少的，刚开始找了不知到哪儿来的一本 Java 算法书，看了一周几乎看完了，然而脑子中似乎什么都没剩下，于是我又照着『算法4』看，这次看得比较慢，加上中途新学期开学了，有很多课要上，到现在也才前两章，综合起来，我现在对排序算法比较清楚了，选择插入希尔归并快排都算了解得清楚了，现在还在继续看下去，第三章是『查找』，会讲到BST等新的数据结构。至于 Linux，照着鸟哥的书慢慢看，有时间就看一章，不求全部记住，只是有个大概概念就行了，现在也看到了 Shell 部分，坚持看下去吧。学这些东西，并不是出于需要，我只是凭借着一时冲动开始看，什么时候我都热情消退了，我也就放弃了，转而投向新的东西。这说是我很长时间来的一种学习态度吧，对于学校规定的课程内容我总感觉不是很有意思，讲授的东西太过陈旧，我会凭借着冲动去随便投入到一些东西中去，既是对自己冲动的满足也是对那些陈旧无聊的知识的逃避。 这个三月我也不是一切顺利，有两次突然陷入了一种极度的焦虑之中，在那种状态下，我什么都不想做，不愿意去做我应该做的事情，只想一直盯着手机看，好在持续一两天之后这种感觉就会很快消失，一切重归正常，但我知道几周后这种感觉又会到来。暂时还没有什么好办法应对这种情况，我只能选择接受它，并在它到来时暂时放下手头的工作，就当是一时的放松，但我坚信会找到办法的。 身处动荡之中，怀抱希望，希望一切都好起来。","content":"<p>惊觉已经是三月的最后一天，在这过去的一个月里，如果说有什么一定一提的，那一定是已经持续了快三个月的的新冠肺炎疫情，国内的疫情逐渐被控制住了，国外却又爆发了更大规模的，看起来返校遥遥无期。一月份的时候我肯定无法想象3月31日自己还在家，突发的疫情打乱我原有的计划，我本该在学校的教室里坐着的，现在却在家，本以为会非常非常想回学校，现在倒也还好，我只是怀念学校的WiFi罢了。<br><a id=\"more\"></a><br>疫情蔓延全球，经济衰退，股价暴跌，美股数次熔断，不可否认这是一个动荡的三月。所谓『祸兮福之所倚』，被困在山村中的我却得以享受宁静，可以专心做自己想做的事，我重新开始捡起以前学了一点就知难而退的东西，比如 C++，Java，Linux 还有算法，除此之外，我还开始坚持看书、记单词和记录生活，为了督促自己，我还使用 atimelogger 记录自己每一分钟的花销。如果不是因为疫情，我也不会如此百无聊赖，也就不会开始做这些事情，从这个角度而言，对我而言这还是福。</p>\n<p>整个三月份，我看完了『乌合之众』、『金字塔原理』、『随机漫步的傻瓜』、『你的第一本哲学书』和『简单逻辑学』，平均一周看了一本多一点的书，还算可以，但是没有对其中任何一本书作一些读后感之类的笔记，算是一个不完整，希望在后面的阅读补上。这一个月也是折腾不断，看了算法看Linux，中间还去折腾下NS2——一坨年久失修的 shit。现在总结一下，算法是没看多少的，刚开始找了不知到哪儿来的一本 Java 算法书，看了一周几乎看完了，然而脑子中似乎什么都没剩下，于是我又照着『算法4』看，这次看得比较慢，加上中途新学期开学了，有很多课要上，到现在也才前两章，综合起来，我现在对排序算法比较清楚了，选择插入希尔归并快排都算了解得清楚了，现在还在继续看下去，第三章是『查找』，会讲到BST等新的数据结构。至于 Linux，照着鸟哥的书慢慢看，有时间就看一章，不求全部记住，只是有个大概概念就行了，现在也看到了 Shell 部分，坚持看下去吧。<br>学这些东西，并不是出于需要，我只是凭借着一时冲动开始看，什么时候我都热情消退了，我也就放弃了，转而投向新的东西。这说是我很长时间来的一种学习态度吧，对于学校规定的课程内容我总感觉不是很有意思，讲授的东西太过陈旧，我会凭借着冲动去随便投入到一些东西中去，既是对自己冲动的满足也是对那些陈旧无聊的知识的逃避。</p>\n<p>这个三月我也不是一切顺利，有两次突然陷入了一种极度的焦虑之中，在那种状态下，我什么都不想做，不愿意去做我应该做的事情，只想一直盯着手机看，好在持续一两天之后这种感觉就会很快消失，一切重归正常，但我知道几周后这种感觉又会到来。暂时还没有什么好办法应对这种情况，我只能选择接受它，并在它到来时暂时放下手头的工作，就当是一时的放松，但我坚信会找到办法的。</p>\n<hr>\n<p>身处动荡之中，怀抱希望，希望一切都好起来。</p>\n","tags":[{"name":"记录","slug":"记录","permalink":"https://jonathan1214.github.io/tags/记录/"},{"name":"monthly","slug":"monthly","permalink":"https://jonathan1214.github.io/tags/monthly/"}]},{"title":"LaTex笔记（一）——基本概念","date":"2020-03-27T04:13:12.000Z","path":"2020/03/latex-notes-1-basic-concepts/","text":"概述Tex是高德纳开发的排版文字和数学公式软件。TeX稳定，跨平台，支持多语言排版，其版本号非常有意思，无限趋近于pi，3.1415926…读作Tech，泰赫。 LaTex是一种格式，可以把LaTex理解成是对TeX的封装。LATeX使用TeX程序作为自己的排版引擎。设计目标是分离内容和格式。读作拉泰赫。 第一份代码1234\\documentclass&#123;article&#125;\\begin&#123;document&#125;``Hello world!'' from \\LaTeX\\end&#123;document&#125; 一份简短的程序，保存为helloworld.tex，然后在命令行下使用xelatex helloworld编译即可。 LaTeX命令和代码结构源代码为文本文件，包括了内容以及命令，可以控制样式，划分文档结构及排版公式。 命令和环境同几乎所有的编程语言一样，LaTeX命令对大小写敏感，命令以\\开头，有两种形式： \\ + 一串字母：如\\LaTex，且任意非字母符号为界限。暂且称其为字母形式。 \\ + 单个非字母符号：如\\$。称其为字符形式。 字母形式的命令忽略其后的所有连续空格，所有的空格都被认为用来标志命令的结束，如果需要空格，使用{}，如\\TeX{} user既可以把空格显示出来，类似于转义。 接受参数。包括可选参数和必选参数，可选参数用[]包裹，必选参数使用{}包裹。带*的命令可看为特殊的可选参数。 环境。可以使一些效果在局部生效，或是生成特殊的文档元素。用法： 123\\begin&#123;&lt;environment name&gt;&#125;[&lt;optional arguments&gt;]&#123;&lt;mandatory arguments&gt;&#125;...\\end&#123;&lt;environment name&gt;&#125; 分组。限制一些命令的作用范围。使用{}作为分组，分组中使用的命令限制在分组内。 源代码结构以\\documentclass{...}命令开头，花括号中指定了文档使用的文档类。有可选参数，可传递给指定文档类，最终作为文档类的参数。 然后在document环境中写文档正文。 123\\begin&#123;document&#125;...\\end&#123;document&#125; 在documentclass和\\begin中间的部分称为导言区。一般在其中使用\\usepackage调用宏包，对文档进行全局设置。 宏包和文档类文档类规定了LaTeX源代码说要生成的文档的性质。documentclass[&lt;options&gt;]{class-name}。 class-name即文档类名，包括LaTeX提供的article、book和report的标准文档类，还有派生出支持中文排版的ctexart，ctexbook，ctexrep，以及一些其他。 options为可选参数，指定文档类的选项，如字号、纸张大小和单双面等等。参数使用逗号分隔。documentclass[11pt,twosides,a4paper]{article}。 标准文档的选项包括：（略多，需要时查看即可）。 宏包用来扩展LaTeX的功能，如插入复杂表格和图片，增加颜色或超链接等等。语法类似使用文档类：usepackage[&lt;options&gt;]{package-names}。可以一次性使用多个宏包，逗号分隔即可。 命令行使用texdoc package-name查看包的使用方法。 LaTeX用到的文件编译使用文件： .sty：宏包文件。 .cls：文档类文件。 .bib：BiBTeX参考文献数据库文件。 .bst：BiBTeX用到的参考文献格式模板。 编译生成文件： .log：日志 .aux：LaTeX生成的主辅助文件，记录交叉引用、目录、参考文献的引用。 .toc：LaTeX生成目录记录文件 .lof：LaTeX生成图片记录 .lot：LaTeX生成表格记录 .bbl .blg .idx .ind .ilg .out 文件的组织方式可将源文件分隔成若干个文件，如将没章的内容单独写在一个文件中，然后使用\\include{&lt;filename&gt;}在源代码里引用即可。注意路径的书写。可以不带扩展名，默认为.tex。 使用\\include会另起一页，使用\\input{filename}避免这种情况。 导言区使用includeonly{&lt;filename1&gt;,&lt;filename2&gt;...}指定正文中可以引用的文件。 实用工具包：syntonly。然后在导言区使用\\syntaxonly，不生成PDF文档，加快编译速度。 注释：使用%。和MATLAB一样。 术语和概念引擎：XeTeX。格式：定义了一组命令的代码集，LaTeX。编译命令：实际调用的、结合引擎和格式的命令，xelatex。 链接：lshort","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>Tex是高德纳开发的排版文字和数学公式软件。TeX稳定，跨平台，支持多语言排版，其版本号非常有意思，无限趋近于pi，3.1415926…读作Tech，泰赫。</p>\n<p>LaTex是一种格式，可以把LaTex理解成是对TeX的封装。LATeX使用TeX程序作为自己的排版引擎。设计目标是分离内容和格式。读作拉泰赫。<br><a id=\"more\"></a></p>\n<h2 id=\"第一份代码\"><a href=\"#第一份代码\" class=\"headerlink\" title=\"第一份代码\"></a>第一份代码</h2><figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">\\<span class=\"name\">documentclass</span><span class=\"string\">&#123;article&#125;</span></span></span><br><span class=\"line\"><span class=\"tag\">\\<span class=\"name\">begin</span><span class=\"string\">&#123;document&#125;</span></span></span><br><span class=\"line\">``Hello world!'' from <span class=\"tag\">\\<span class=\"name\">LaTeX</span></span></span><br><span class=\"line\"><span class=\"tag\">\\<span class=\"name\">end</span><span class=\"string\">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>\n<p>一份简短的程序，保存为<code>helloworld.tex</code>，然后在命令行下使用<code>xelatex helloworld</code>编译即可。</p>\n<h2 id=\"LaTeX命令和代码结构\"><a href=\"#LaTeX命令和代码结构\" class=\"headerlink\" title=\"LaTeX命令和代码结构\"></a>LaTeX命令和代码结构</h2><p>源代码为文本文件，包括了内容以及命令，可以控制样式，划分文档结构及排版公式。</p>\n<h3 id=\"命令和环境\"><a href=\"#命令和环境\" class=\"headerlink\" title=\"命令和环境\"></a>命令和环境</h3><p>同几乎所有的编程语言一样，LaTeX命令对<strong>大小写敏感</strong>，命令以<code>\\</code>开头，有两种形式：</p>\n<ul>\n<li>\\ + 一串字母：如<code>\\LaTex</code>，且任意非字母符号为界限。暂且称其为字母形式。</li>\n<li>\\ + 单个非字母符号：如<code>\\$</code>。称其为字符形式。</li>\n</ul>\n<p>字母形式的命令忽略其后的所有连续空格，所有的空格都被认为用来标志命令的结束，如果需要空格，使用<code>{}</code>，如<code>\\TeX{} user</code>既可以把空格显示出来，类似于<strong>转义</strong>。</p>\n<p>接受参数。包括可选参数和必选参数，可选参数用<code>[]</code>包裹，必选参数使用<code>{}</code>包裹。带<code>*</code>的命令可看为<em>特殊的可选参数</em>。</p>\n<p>环境。可以使一些效果在局部生效，或是生成特殊的文档元素。用法：</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">\\<span class=\"name\">begin</span><span class=\"string\">&#123;&lt;environment name&gt;&#125;</span><span class=\"string\">[&lt;optional arguments&gt;]</span><span class=\"string\">&#123;&lt;mandatory arguments&gt;&#125;</span></span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"tag\">\\<span class=\"name\">end</span><span class=\"string\">&#123;&lt;environment name&gt;&#125;</span></span></span><br></pre></td></tr></table></figure>\n<p>分组。限制一些命令的作用范围。使用<code>{}</code>作为分组，分组中使用的命令限制在分组内。</p>\n<h3 id=\"源代码结构\"><a href=\"#源代码结构\" class=\"headerlink\" title=\"源代码结构\"></a>源代码结构</h3><p>以<code>\\documentclass{...}</code>命令开头，花括号中指定了文档使用的文档类。有可选参数，可传递给指定文档类，最终作为文档类的参数。</p>\n<p>然后在document环境中写文档正文。</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">\\<span class=\"name\">begin</span><span class=\"string\">&#123;document&#125;</span></span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"tag\">\\<span class=\"name\">end</span><span class=\"string\">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>\n<p>在<code>documentclass</code>和<code>\\begin</code>中间的部分称为导言区。一般在其中使用<code>\\usepackage</code>调用宏包，对文档进行全局设置。</p>\n<h2 id=\"宏包和文档类\"><a href=\"#宏包和文档类\" class=\"headerlink\" title=\"宏包和文档类\"></a>宏包和文档类</h2><h3 id=\"文档类\"><a href=\"#文档类\" class=\"headerlink\" title=\"文档类\"></a>文档类</h3><p>规定了LaTeX源代码说要生成的文档的性质。<code>documentclass[&lt;options&gt;]{class-name}</code>。</p>\n<p><code>class-name</code>即文档类名，包括LaTeX提供的article、book和report的<strong>标准文档类</strong>，还有派生出支持中文排版的ctexart，ctexbook，ctexrep，以及一些其他。</p>\n<p><code>options</code>为可选参数，指定文档类的选项，如字号、纸张大小和单双面等等。参数使用逗号分隔。<code>documentclass[11pt,twosides,a4paper]{article}</code>。</p>\n<p>标准文档的选项包括：（略多，需要时查看即可）。</p>\n<h3 id=\"宏包\"><a href=\"#宏包\" class=\"headerlink\" title=\"宏包\"></a>宏包</h3><p>用来扩展LaTeX的功能，如插入复杂表格和图片，增加颜色或超链接等等。语法类似使用文档类：<code>usepackage[&lt;options&gt;]{package-names}</code>。可以一次性使用多个宏包，逗号分隔即可。</p>\n<p>命令行使用<code>texdoc package-name</code>查看包的使用方法。</p>\n<h2 id=\"LaTeX用到的文件\"><a href=\"#LaTeX用到的文件\" class=\"headerlink\" title=\"LaTeX用到的文件\"></a>LaTeX用到的文件</h2><p>编译使用文件：</p>\n<ul>\n<li>.sty：宏包文件。</li>\n<li>.cls：文档类文件。</li>\n<li>.bib：BiBTeX参考文献数据库文件。</li>\n<li>.bst：BiBTeX用到的参考文献格式模板。</li>\n</ul>\n<p>编译生成文件：</p>\n<ul>\n<li>.log：日志</li>\n<li>.aux：LaTeX生成的主辅助文件，记录交叉引用、目录、参考文献的引用。</li>\n<li>.toc：LaTeX生成目录记录文件</li>\n<li>.lof：LaTeX生成图片记录</li>\n<li>.lot：LaTeX生成表格记录</li>\n<li>.bbl</li>\n<li>.blg</li>\n<li>.idx</li>\n<li>.ind</li>\n<li>.ilg</li>\n<li>.out</li>\n</ul>\n<h2 id=\"文件的组织方式\"><a href=\"#文件的组织方式\" class=\"headerlink\" title=\"文件的组织方式\"></a>文件的组织方式</h2><p>可将源文件分隔成若干个文件，如将没章的内容单独写在一个文件中，然后使用<code>\\include{&lt;filename&gt;}</code>在源代码里引用即可。注意路径的书写。可以不带扩展名，默认为.tex。</p>\n<p>使用<code>\\include</code>会另起一页，使用<code>\\input{filename}</code>避免这种情况。</p>\n<p>导言区使用<code>includeonly{&lt;filename1&gt;,&lt;filename2&gt;...}</code>指定正文中可以引用的文件。</p>\n<p>实用工具包：syntonly。然后在导言区使用<code>\\syntaxonly</code>，不生成PDF文档，加快编译速度。</p>\n<p>注释：使用<code>%</code>。和MATLAB一样。</p>\n<h2 id=\"术语和概念\"><a href=\"#术语和概念\" class=\"headerlink\" title=\"术语和概念\"></a>术语和概念</h2><p>引擎：XeTeX。<br>格式：定义了一组命令的代码集，LaTeX。<br>编译命令：实际调用的、结合引擎和格式的命令，xelatex。</p>\n<hr>\n<p>链接：<a href=\"https://mirrors.tuna.tsinghua.edu.cn/CTAN/info/lshort/chinese\" target=\"_blank\" rel=\"noopener\">lshort</a></p>\n","tags":[{"name":"LaTeX","slug":"LaTeX","permalink":"https://jonathan1214.github.io/tags/LaTeX/"}]},{"title":"胡言乱语","date":"2020-03-22T13:39:06.000Z","path":"2020/03/second-week/","text":"没想到有和上周一样，在周一写下上周的日常。不过这次我有话说，不是因为贪玩游戏，实在是因为周六晚上的突发事件打乱了周日的计划，不得已在半夜在农村道路上走上7里路，第二天已经没有精力去写这玩意儿了。翻看上周每天写下的只言片语，我发现若是只给我自己看，那还是有点东西可写的。 无法抵挡的快乐放纵在放纵当时带来的快乐无与伦比，让我无法阻挡，虽然我已经很少体验到放纵的快乐，但我深知它的吸引力是多么强大。放纵对我而言是个什么样的标准呢？一天打上三把游戏已经是放纵了，大概就是这样，那么我可以说周四我放纵了一次。我处于一种完全沉浸式投入的状态，不在乎自己眼睛的疲劳，全心投入，决心赢下当前的比赛，但我还想赢得更多，于是不断地玩下去。最终局数来到了4，花去了2h，我停了下来，没有继续玩下去。因为心心念念着学习知识，我停了下来，放弃了快乐。但是我知道，下一次我还是会沉浸其中，因为它能让我短暂地逃离现实，这是无法抵挡的快乐。 一个平庸的人几乎每天都要上课，老师讲得那些我从来没有听过的知识，但没有多大程度引起我的兴趣，对我而言学习它只是身为学生的一种职责。我被动地接受他们传递过来的东西，OSI参考模型、TCP/IP参考模型、ALOHA随机接入协议还有光纤的若干性质，我几乎没有记下什么东西，但是我尝试去发现其中的规则，那是一种很美的东西，我尝试像一个『一无所知』的人，面对这些问题我能给出什么样的解决方案，大部分时候我什么也发现不了，对于这些问题我也一筹莫展，更别提解决方案，我不过是个平庸的人。 教育使我成为什么样的人？通常我不会想这样的问题，因为只不过是活着而以，不需要赋予人生意义，成为一个什么样的人也许真的无关紧要。周六看了郑强教授的一个视频，让我想考虑下这个问题，但我知道我想不明白的，我只能回顾自己的人生，并尝试从一些事件归纳出自己被教育成一个什么样的人，具体内容慢慢写吧。 我是随机漫步的傻瓜我是个随机漫步的的傻瓜，但是我并没有受到眷顾，所以我还是个彻底的傻瓜。","content":"<p>没想到有和上周一样，在周一写下上周的日常。不过这次我有话说，不是因为贪玩游戏，实在是因为周六晚上的突发事件打乱了周日的计划，不得已在半夜在农村道路上走上7里路，第二天已经没有精力去写这玩意儿了。翻看上周每天写下的只言片语，我发现若是只给我自己看，那还是有点东西可写的。<br><a id=\"more\"></a></p>\n<h2 id=\"无法抵挡的快乐\"><a href=\"#无法抵挡的快乐\" class=\"headerlink\" title=\"无法抵挡的快乐\"></a>无法抵挡的快乐</h2><p>放纵在放纵当时带来的快乐无与伦比，让我无法阻挡，虽然我已经很少体验到放纵的快乐，但我深知它的吸引力是多么强大。放纵对我而言是个什么样的标准呢？一天打上三把游戏已经是放纵了，大概就是这样，那么我可以说周四我放纵了一次。我处于一种完全沉浸式投入的状态，不在乎自己眼睛的疲劳，全心投入，决心赢下当前的比赛，但我还想赢得更多，于是不断地玩下去。最终局数来到了4，花去了2h<br>，我停了下来，没有继续玩下去。因为心心念念着学习知识，我停了下来，放弃了快乐。但是我知道，下一次我还是会沉浸其中，因为它能让我短暂地逃离现实，这是无法抵挡的快乐。</p>\n<h2 id=\"一个平庸的人\"><a href=\"#一个平庸的人\" class=\"headerlink\" title=\"一个平庸的人\"></a>一个平庸的人</h2><p>几乎每天都要上课，老师讲得那些我从来没有听过的知识，但没有多大程度引起我的兴趣，对我而言学习它只是身为学生的一种职责。我被动地接受他们传递过来的东西，OSI参考模型、TCP/IP参考模型、ALOHA随机接入协议还有光纤的若干性质，我几乎没有记下什么东西，但是我尝试去发现其中的规则，那是一种很美的东西，我尝试像一个『一无所知』的人，面对这些问题我能给出什么样的解决方案，大部分时候我什么也发现不了，对于这些问题我也一筹莫展，更别提解决方案，我不过是个平庸的人。</p>\n<h2 id=\"教育使我成为什么样的人？\"><a href=\"#教育使我成为什么样的人？\" class=\"headerlink\" title=\"教育使我成为什么样的人？\"></a>教育使我成为什么样的人？</h2><p>通常我不会想这样的问题，因为只不过是活着而以，不需要赋予人生意义，成为一个什么样的人也许真的无关紧要。周六看了郑强教授的一个视频，让我想考虑下这个问题，但我知道我想不明白的，我只能回顾自己的人生，并尝试从一些事件归纳出自己被教育成一个什么样的人，具体内容慢慢写吧。</p>\n<h2 id=\"我是随机漫步的傻瓜\"><a href=\"#我是随机漫步的傻瓜\" class=\"headerlink\" title=\"我是随机漫步的傻瓜\"></a>我是随机漫步的傻瓜</h2><p>我是个随机漫步的的傻瓜，但是我并没有受到眷顾，所以我还是个彻底的傻瓜。</p>\n","tags":[{"name":"记录","slug":"记录","permalink":"https://jonathan1214.github.io/tags/记录/"},{"name":"weekly","slug":"weekly","permalink":"https://jonathan1214.github.io/tags/weekly/"}]},{"title":"信道共享技术简述与ALOHA的仿真","date":"2020-03-21T08:04:28.000Z","path":"2020/03/channel-sharing-and-aloha-imulation/","text":"MAC（Media Access Control）协议，即介质访问控制协议。MAC层需要实现数据帧的封装卸装、帧寻址和识别、帧的接受和发送、链路的管理和帧的差错控制等。屏蔽了不同物理链路的种类差异性。其核心是对有限物理资源的高效利用。在Ad Hoc网络中，由于其无中心和使用无线信道等特点，新带来的问题有：选择什么样的信道共享方式，如何处理终端暴露问题，如何隐藏终端，以及如何处理节点移动带来的影响。因而对MAC协议的要求更高。本文将探讨简单的信道共享技术，并对动态接入协议ALOHA进行分析和MATLAB仿真。 信道共享技术分类信道共享技术又称为多点接入技术，原理是通过一个专用信道将所有的用户连接起来。按照多个用户与一个主机连接的访问方法来划分，信道共享技术可以分为通过集中器或复用器相连和直接相连，前者即信道复用，后者又可分为受控接入和随机接入。 信道复用 受控接入 随机接入 信道复用这是一种应用的比较成熟的技术，集中器或复用器按顺序不断扫描各个端口，或采用中断技术来接受用户信息或转发。如FDM，TDM，CDM，WDM和STDM。考虑一个实际例子：两个用户A和B，都需要需要发送信息；如果采用FDM方式，则分别为A和B分配一条不同频率的信道，允许二者一起发送而不产生冲突；如果采用TDM方式，则A和B的数据帧交给集中器，集中器把二者的帧放在不同的时隙发送然后发送，也可以避免冲突。这可以通过集中器扫描，也可以通过用户发送请求产生中断来执行。其实这就是一种静态的信道分配，按频率、时间或码字对信道进行划分。显然，这会造成资源的浪费。 受控接入受控接入方式的网络拓扑是环型结构，分为集中式控制和分散式控制。集中式控制使用轮询方法，主机按顺序逐个询问各站是否有数据需要发送。分散式控制即使用令牌，在环路中有一个特殊的帧——『令牌』，沿着环路传递，只有获得了令牌的站才有权发送信息。 随机接入随机接入方式的网络拓扑是总线型结构，所有的站点可随时发送数据，争用信道，容易产生冲突，经典的协议有ALOHA，CSMA和CSMA/CD。 信道的静态和动态分配信道的静态分配即将信道资源N等分，这个资源包括时隙（slot）、频谱（frequency）和码字（code），适用于用户数量少、数据量大的情况。这种信道的分配方式在某系情况下是不合理，它不能满足用户对资源占用的不同需求，效率低，不合适多站点，不适于突发性数据。 信道的动态分配使用多路访问协议，动态分配信道资源提高信道利用率。可以这么理解：不对信道资源进行划分，用户产生了需求就进行处理，处理时占用全部的信道资源。这么做不可避免的会产生信道争用和冲突问题，可以牺牲一点自由，使用受控接入方式可以隐藏争用问题和解决冲突问题。或者可以直面信道争用和冲突，使用随机接入方式，其中一个重要的协议就是ALOHA。 从一个更高的角度上来看，信道复用技术是一种信道的静态分配技术，受控接入和随机接入是一种信道的动态分配技术。 ALOHA前面讲到，ALOHA协议是一种信道的动态分配协议，它实现了信道共享方式中的一种随机接入技术。在这种动态分配的方式下，信道有三种状态，传输，空闲和竞争，所有的站点都通过同一信道发送或接受帧，某一特定时刻只允许一个站点使用信道。 以一个数据帧A的发送为例，考虑其如何才能成功发送。发送时机有两种选择，连续时间或时间片，前者允许在任意时刻发送，后者将时间用时钟分离为片段，帧只允许在每一个片段开始瞬间发生。若是以连续时间发送，帧发送时，若信道是空闲状态，则成功开始发送帧，此时信道为传输状态，假设在帧发送时间内又有数据帧B的发送请求产生，则信道进入竞争状态，产生了冲突，帧A发送失败，帧B也发送失败，都需要重传，二者分别随机等待一段时间，然后进行发送，直到发送成功。 纯ALOHA帧传输示意图我们把以连续时间发送的称为纯ALOHA（pure ALOHA），按时间片发送到称为时隙ALOHA（slotted ALOHA），下面对它们的信道利用率进行分析。 pure ALOHA 信道利用率分析首先考虑pure ALOHA中一帧发送成功的条件，假设帧长固定，发送所需时间为T，则不难推知发送成功的条件为该帧发送前后各有一段T时间内没有其他帧发送，如下图所示。 纯ALOHA的帧发送成功条件 对其信道利用率分析我们先要确定一些条件： 假设：帧长固定，无限用户，按泊松分布产生新的数据帧。 网络负载为G，表示在T内总共发送的平均帧数，包括发送成功的帧和因碰撞未发送成功的帧。 吞吐率为S，表示在帧的发送时间T内成功发送的平均帧数。 简单分析可知，0&lt;=S&lt;=1，S=0表示在信道上无成功发送的数据；S=1表示数据帧一个接一个发送，这是不可能的。G只有在不发送碰撞时才和S相等，且可以远大于1。 我们研究信道利用率，就是要考虑在什么的样的网络负载下，能够取得最大的吞吐率，并且要知道这个最大的吞吐率。 对这个问题进行理论分析并不困难，稳定情况下，S=G*P[发送成功]，求出一个数据帧发送成功概率P即可，由前面的分析可知，当前帧要想发送成功，以为着当前时刻的前后T时间内，共2T时间内，没有其他数据帧的发送请求产生，按照数据帧的产生数或者说数据帧请求产生数在T时间内服从参数为G的泊松分布，不难得出P[发送成功]=((2G)^0/0!)*e^(-2G)，则吞吐率S=G*P[发送成功]=G*e^(-2G)，求极值可知，当G=0.5时，S取最大值0.184，非常小。 对这个过程进行MATLAB仿真并不难，具体思路如下：产生一系列值的G，对每一个帧，产生若干个服从参数为G的泊松分布随机数，若连续的前后两个随机数和为0，则表示发送成功，统计发送成功的数占所有随机数的比即为该负载G下发送成功的概率，在和G相乘求得此时的吞吐率S，对每一个G都这么求即可得出一系列的(G,S)，再使用plot作出图像，如下所示： 纯ALOHA的信道吞吐率与网络负载的关系 slotted ALOHA 信道利用率分析时隙ALOHA协议下，将信道时间划分为离散的时间隙，隙长为一个帧所需的发送时间，每个站点只能在时隙开始时才允许发。 分析信道利用率时，条件和纯ALOHA相同。重点也是在考虑发送成功的概率，在时隙ALOHA协议下，当前帧发送成功的条件为：当前发送时隙前的一个时隙T内没有新的数据帧发送请求产生。事实上，由于只允许在时隙开始时发送请求，站点发送的数据帧都是积攒下来的。可以求出P[发送成功]=(G^0/0!)*e^(-G)，S=G*e^(-G)，当G=1时，S取最大值0.368，是纯ALOHA的2倍，但还是不够高。仿真思路同纯ALOHA，最后作出的S-G图像如下所示： 时隙ALOHA的信道吞吐率与网络负载的关系 附MATLAB仿真代码：aloha_.mview raw12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455clear all;clc;% ALOHA 仿真% 网络负载G% 成功发送条件，请求为0T = 100000; % 仿真时间 1000个帧长load_scale = 0.1;G = 0:load_scale:5; % 网络负载requests = zeros(T+1, size(G,2)); % 请求次数pure_ALOHA_sucess = zeros(1,size(G,2)); % pure ALOHA成功次数slotted_ALOHA_sucess = zeros(1,size(G,2)); % slotted ALOHA% 产生请求for g = 1:size(G,2) requests(:,g) = random('Poisson',G(g),T+1,1);end% pure ALOHAfor g = 1:size(G,2) for index = 1:T if requests(index,g) + requests(index+1,g) == 0 pure_ALOHA_sucess(g) = pure_ALOHA_sucess(g) + 1; end if requests(index,g) == 0 slotted_ALOHA_sucess(g) = slotted_ALOHA_sucess(g) + 1; end endend%% calculate% pure ALOHAprobl_pure_ALOHA = pure_ALOHA_sucess / T; % 成功概率S_pure_ALOHA = G.*probl_pure_ALOHA; % 吞吐率% slotted ALOHAprobl_slotted_ALOHA = slotted_ALOHA_sucess / T;S_slotted_ALOHA = G.*probl_slotted_ALOHA;%% plot% purefigure(1)yyaxis leftplot(G,probl_pure_ALOHA)ylabel('Probablity of Sucess')yyaxis rightplot(G,S_pure_ALOHA)title('Average Throughput of Pure ALOHA')xlabel('G')ylabel('Average Throughput')grid on% slottedfigure(2)yyaxis leftplot(G,probl_slotted_ALOHA)ylabel('Probablity of Sucess')yyaxis rightplot(G,S_slotted_ALOHA)title('Average Throughput of Slotted ALOHA')xlabel('G')ylabel('Average Throughput')grid on","content":"<p>MAC（Media Access Control）协议，即介质访问控制协议。MAC层需要实现数据帧的封装卸装、帧寻址和识别、帧的接受和发送、链路的管理和帧的差错控制等。屏蔽了不同物理链路的种类差异性。其核心是<strong>对有限物理资源的高效利用</strong>。在Ad Hoc网络中，由于其无中心和使用无线信道等特点，新带来的问题有：选择什么样的信道共享方式，如何处理终端暴露问题，如何隐藏终端，以及如何处理节点移动带来的影响。因而对MAC协议的要求更高。本文将探讨简单的信道共享技术，并对动态接入协议<code>ALOHA</code>进行分析和<br>MATLAB仿真。<br><a id=\"more\"></a></p>\n<h2 id=\"信道共享技术分类\"><a href=\"#信道共享技术分类\" class=\"headerlink\" title=\"信道共享技术分类\"></a>信道共享技术分类</h2><p>信道共享技术又称为多点接入技术，原理是通过一个专用信道将所有的用户连接起来。按照多个用户与一个主机连接的访问方法来划分，信道共享技术可以分为通过集中器或复用器相连和直接相连，前者即信道复用，后者又可分为受控接入和随机接入。</p>\n<ul>\n<li><a href=\"#信道复用\">信道复用</a></li>\n<li><a href=\"#受控接入\">受控接入</a></li>\n<li><a href=\"#随机接入\">随机接入</a></li>\n</ul>\n<h3 id=\"信道复用\"><a href=\"#信道复用\" class=\"headerlink\" title=\"信道复用\"></a>信道复用</h3><p>这是一种应用的比较成熟的技术，集中器或复用器按顺序不断扫描各个端口，或采用中断技术来接受用户信息或转发。如<code>FDM</code>，<code>TDM</code>，<code>CDM</code>，<code>WDM</code>和<code>STDM</code>。<br>考虑一个实际例子：两个用户A和B，都需要需要发送信息；如果采用FDM方式，则分别为A和B分配一条不同频率的信道，允许二者一起发送而不产生冲突；如果采用TDM方式，则A和B的数据帧交给集中器，集中器把二者的帧放在不同的时隙发送然后发送，也可以避免冲突。这可以通过集中器扫描，也可以通过用户发送请求产生中断来执行。<br>其实这就是一种静态的信道分配，按频率、时间或码字对信道进行划分。显然，这会造成资源的浪费。</p>\n<h3 id=\"受控接入\"><a href=\"#受控接入\" class=\"headerlink\" title=\"受控接入\"></a>受控接入</h3><p>受控接入方式的网络拓扑是环型结构，分为集中式控制和分散式控制。集中式控制使用轮询方法，主机按顺序逐个询问各站是否有数据需要发送。分散式控制即使用令牌，在环路中有一个特殊的帧——『令牌』，沿着环路传递，只有获得了令牌的站才有权发送信息。</p>\n<h3 id=\"随机接入\"><a href=\"#随机接入\" class=\"headerlink\" title=\"随机接入\"></a>随机接入</h3><p>随机接入方式的网络拓扑是总线型结构，所有的站点可随时发送数据，争用信道，容易产生冲突，经典的协议有ALOHA，CSMA和CSMA/CD。</p>\n<h3 id=\"信道的静态和动态分配\"><a href=\"#信道的静态和动态分配\" class=\"headerlink\" title=\"信道的静态和动态分配\"></a>信道的静态和动态分配</h3><p>信道的静态分配即将信道资源N等分，这个资源包括时隙（slot）、频谱（frequency）和码字（code），适用于用户数量少、数据量大的情况。这种信道的分配方式在某系情况下是不合理，它不能满足用户对资源占用的不同需求，效率低，不合适多站点，不适于突发性数据。</p>\n<p>信道的动态分配使用多路访问协议，动态分配信道资源提高信道利用率。可以这么理解：不对信道资源进行划分，用户产生了需求就进行处理，处理时占用全部的信道资源。这么做不可避免的会产生信道争用和冲突问题，可以牺牲一点自由，使用受控接入方式可以隐藏争用问题和解决冲突问题。或者可以直面信道争用和冲突，使用随机接入方式，其中一个重要的协议就是ALOHA。</p>\n<p>从一个更高的角度上来看，信道复用技术是一种信道的静态分配技术，受控接入和随机接入是一种信道的动态分配技术。</p>\n<h2 id=\"ALOHA\"><a href=\"#ALOHA\" class=\"headerlink\" title=\"ALOHA\"></a>ALOHA</h2><p>前面讲到，ALOHA协议是一种信道的动态分配协议，它实现了信道共享方式中的一种随机接入技术。在这种动态分配的方式下，信道有三种状态，<code>传输</code>，<code>空闲</code>和<code>竞争</code>，所有的站点都通过同一信道发送或接受帧，某一特定时刻只允许一个站点使用信道。</p>\n<p>以一个数据帧A的发送为例，考虑其如何才能成功发送。发送时机有两种选择，连续时间或时间片，前者允许在任意时刻发送，后者将时间用时钟分离为片段，帧只允许在每一个片段开始瞬间发生。若是以连续时间发送，帧发送时，若信道是空闲状态，则成功开始发送帧，此时信道为传输状态，假设在帧发送时间内又有数据帧B的发送请求产生，则信道进入竞争状态，产生了<em>冲突</em>，帧A发送失败，帧B也发送失败，都需要重传，二者分别随机等待一段时间，然后进行发送，直到发送成功。</p>\n<p><div align=\"center\" class=\"img\"><br>    <img src=\"/assets/img/2020/aloha_principle_illustration.png\" alt=\"aloha_principle_illustration\" width=\"750\"><br>    <span align=\"center\" style=\"color:#999\">纯ALOHA帧传输示意图</span><br></div><br>我们把以连续时间发送的称为纯ALOHA（pure ALOHA），按时间片发送到称为时隙ALOHA（slotted ALOHA），下面对它们的信道利用率进行分析。</p>\n<h3 id=\"pure-ALOHA-信道利用率分析\"><a href=\"#pure-ALOHA-信道利用率分析\" class=\"headerlink\" title=\"pure ALOHA 信道利用率分析\"></a>pure ALOHA 信道利用率分析</h3><p>首先考虑<code>pure ALOHA</code>中一帧发送成功的条件，假设帧长固定，发送所需时间为T，则不难推知发送成功的条件为<strong>该帧发送前后各有一段T时间内没有其他帧发送</strong>，如下图所示。</p>\n<p align=\"center\" class=\"img\"><br><img src=\"/assets/img/2020/aloha_success.png\" alt=\"pure_aloha_success\" width=\"750\"><br>    <span align=\"center\" style=\"color:#999\">纯ALOHA的帧发送成功条件</span><br></p>\n\n<p>对其信道利用率分析我们先要确定一些条件：</p>\n<ul>\n<li>假设：帧长固定，无限用户，按泊松分布产生新的数据帧。</li>\n<li>网络负载为G，表示在T内总共发送的平均帧数，包括发送成功的帧和因碰撞未发送成功的帧。</li>\n<li>吞吐率为S，表示在帧的发送时间T内成功发送的平均帧数。</li>\n</ul>\n<p>简单分析可知，0&lt;=S&lt;=1，S=0表示在信道上无成功发送的数据；S=1表示数据帧一个接一个发送，这是不可能的。G只有在不发送碰撞时才和S相等，且可以远大于1。</p>\n<p>我们研究信道利用率，就是要考虑在什么的样的网络负载下，能够取得最大的吞吐率，并且要知道这个最大的吞吐率。</p>\n<p>对这个问题进行理论分析并不困难，稳定情况下，<code>S=G*P[发送成功]</code>，求出一个数据帧发送成功概率P即可，由前面的分析可知，当前帧要想发送成功，以为着当前时刻的前后T时间内，共2T时间内，没有其他数据帧的发送请求产生，按照数据帧的产生数或者说数据帧请求产生数在T时间内服从参数为G的泊松分布，不难得出<code>P[发送成功]=((2G)^0/0!)*e^(-2G)</code>，则吞吐率<code>S=G*P[发送成功]=G*e^(-2G)</code>，求极值可知，当G=0.5时，S取最大值0.184，非常小。</p>\n<p>对这个过程进行MATLAB仿真并不难，具体思路如下：产生一系列值的G，对每一个帧，产生若干个服从参数为G的泊松分布随机数，若连续的前后两个随机数和为0，则表示发送成功，统计发送成功的数占所有随机数的比即为该负载G下发送成功的概率，在和G相乘求得此时的吞吐率S，对每一个G都这么求即可得出一系列的(G,S)，再使用plot作出图像，如下所示：</p>\n<p align=\"center\" class=\"img\"><br><img src=\"/assets/img/2020/pure_aloha.jpg\" alt=\"pure_aloha\" width=\"750\"><br>    <span align=\"center\" style=\"color:#999\">纯ALOHA的信道吞吐率与网络负载的关系</span><br></p>\n\n<h3 id=\"slotted-ALOHA-信道利用率分析\"><a href=\"#slotted-ALOHA-信道利用率分析\" class=\"headerlink\" title=\"slotted ALOHA 信道利用率分析\"></a>slotted ALOHA 信道利用率分析</h3><p>时隙ALOHA协议下，将信道时间划分为离散的时间隙，隙长为一个帧所需的发送时间，每个站点只能在时隙开始时才允许发。</p>\n<p>分析信道利用率时，条件和纯ALOHA相同。重点也是在考虑发送成功的概率，在时隙ALOHA协议下，当前帧发送成功的条件为：当前发送时隙前的一个时隙T内没有新的数据帧发送请求产生。事实上，由于只允许在时隙开始时发送请求，站点发送的数据帧都是积攒下来的。可以求出<code>P[发送成功]=(G^0/0!)*e^(-G)</code>，<code>S=G*e^(-G)</code>，当G=1时，S取最大值0.368，是纯ALOHA的2倍，但还是不够高。<br>仿真思路同纯ALOHA，最后作出的S-G图像如下所示：</p>\n<p align=\"center\" class=\"img\"><br>    <img src=\"/assets/img/2020/slotted_aloha.jpg\" alt=\"slotted_aloha\" width=\"750\"><br>    <span align=\"center\" style=\"color:#999\">时隙ALOHA的信道吞吐率与网络负载的关系</span><br></p>\n\n<p>附MATLAB仿真代码：<br><figure class=\"highlight matlab\"><figcaption><span>aloha_.m</span><a href=\"/downloads/code/aloha_.m\">view raw</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clear all;clc;</span><br><span class=\"line\"><span class=\"comment\">% ALOHA 仿真</span></span><br><span class=\"line\"><span class=\"comment\">% 网络负载G</span></span><br><span class=\"line\"><span class=\"comment\">% 成功发送条件，请求为0</span></span><br><span class=\"line\">T = <span class=\"number\">100000</span>;   <span class=\"comment\">% 仿真时间 1000个帧长</span></span><br><span class=\"line\">load_scale = <span class=\"number\">0.1</span>;</span><br><span class=\"line\">G = <span class=\"number\">0</span>:load_scale:<span class=\"number\">5</span>; <span class=\"comment\">% 网络负载</span></span><br><span class=\"line\">requests = <span class=\"built_in\">zeros</span>(T+<span class=\"number\">1</span>, <span class=\"built_in\">size</span>(G,<span class=\"number\">2</span>)); <span class=\"comment\">% 请求次数</span></span><br><span class=\"line\">pure_ALOHA_sucess = <span class=\"built_in\">zeros</span>(<span class=\"number\">1</span>,<span class=\"built_in\">size</span>(G,<span class=\"number\">2</span>)); <span class=\"comment\">% pure ALOHA成功次数</span></span><br><span class=\"line\">slotted_ALOHA_sucess = <span class=\"built_in\">zeros</span>(<span class=\"number\">1</span>,<span class=\"built_in\">size</span>(G,<span class=\"number\">2</span>)); <span class=\"comment\">% slotted ALOHA</span></span><br><span class=\"line\"><span class=\"comment\">% 产生请求</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> g = <span class=\"number\">1</span>:<span class=\"built_in\">size</span>(G,<span class=\"number\">2</span>)</span><br><span class=\"line\">    requests(:,g) = random(<span class=\"string\">'Poisson'</span>,G(g),T+<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"comment\">% pure ALOHA</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> g = <span class=\"number\">1</span>:<span class=\"built_in\">size</span>(G,<span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> index = <span class=\"number\">1</span>:T</span><br><span class=\"line\">       <span class=\"keyword\">if</span> requests(index,g) + requests(index+<span class=\"number\">1</span>,g) == <span class=\"number\">0</span></span><br><span class=\"line\">           pure_ALOHA_sucess(g) = pure_ALOHA_sucess(g) + <span class=\"number\">1</span>;</span><br><span class=\"line\">       <span class=\"keyword\">end</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> requests(index,g) == <span class=\"number\">0</span></span><br><span class=\"line\">           slotted_ALOHA_sucess(g) = slotted_ALOHA_sucess(g) + <span class=\"number\">1</span>;</span><br><span class=\"line\">       <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"comment\">%% calculate</span></span><br><span class=\"line\"><span class=\"comment\">% pure ALOHA</span></span><br><span class=\"line\">probl_pure_ALOHA = pure_ALOHA_sucess / T; <span class=\"comment\">% 成功概率</span></span><br><span class=\"line\">S_pure_ALOHA = G.*probl_pure_ALOHA;       <span class=\"comment\">% 吞吐率</span></span><br><span class=\"line\"><span class=\"comment\">% slotted ALOHA</span></span><br><span class=\"line\">probl_slotted_ALOHA = slotted_ALOHA_sucess / T;</span><br><span class=\"line\">S_slotted_ALOHA = G.*probl_slotted_ALOHA;</span><br><span class=\"line\"><span class=\"comment\">%% plot</span></span><br><span class=\"line\"><span class=\"comment\">% pure</span></span><br><span class=\"line\">figure(<span class=\"number\">1</span>)</span><br><span class=\"line\">yyaxis left</span><br><span class=\"line\">plot(G,probl_pure_ALOHA)</span><br><span class=\"line\">ylabel(<span class=\"string\">'Probablity of Sucess'</span>)</span><br><span class=\"line\">yyaxis right</span><br><span class=\"line\">plot(G,S_pure_ALOHA)</span><br><span class=\"line\">title(<span class=\"string\">'Average Throughput of Pure ALOHA'</span>)</span><br><span class=\"line\">xlabel(<span class=\"string\">'G'</span>)</span><br><span class=\"line\">ylabel(<span class=\"string\">'Average Throughput'</span>)</span><br><span class=\"line\">grid on</span><br><span class=\"line\"><span class=\"comment\">% slotted</span></span><br><span class=\"line\">figure(<span class=\"number\">2</span>)</span><br><span class=\"line\">yyaxis left</span><br><span class=\"line\">plot(G,probl_slotted_ALOHA)</span><br><span class=\"line\">ylabel(<span class=\"string\">'Probablity of Sucess'</span>)</span><br><span class=\"line\">yyaxis right</span><br><span class=\"line\">plot(G,S_slotted_ALOHA)</span><br><span class=\"line\">title(<span class=\"string\">'Average Throughput of Slotted ALOHA'</span>)</span><br><span class=\"line\">xlabel(<span class=\"string\">'G'</span>)</span><br><span class=\"line\">ylabel(<span class=\"string\">'Average Throughput'</span>)</span><br><span class=\"line\">grid on</span><br></pre></td></tr></table></figure></p>\n","tags":[{"name":"网络","slug":"网络","permalink":"https://jonathan1214.github.io/tags/网络/"},{"name":"Ad-Hoc","slug":"Ad-Hoc","permalink":"https://jonathan1214.github.io/tags/Ad-Hoc/"},{"name":"MAC协议","slug":"MAC协议","permalink":"https://jonathan1214.github.io/tags/MAC协议/"},{"name":"MATLAB","slug":"MATLAB","permalink":"https://jonathan1214.github.io/tags/MATLAB/"}]},{"title":"新学期的第一周","date":"2020-03-15T12:15:57.000Z","path":"2020/03/first-week-record-of-new-term/","text":"震惊的Joey 不知不觉间大三已经过完一半，想起在过去的两年半中好像没有值得纪念的事，有点无可奈何，但要说没有发生那么一件在当时让我很有感触的事，当然也不可能，只是我以为自己的记忆会帮我保存那些真正重要的感觉，因此没有记录，但是这样的事怎么会有那么多呢？亲人故去、终有所成之类的记忆深刻的事不常发生，更多的是生活中有感触的小事，它们发生很触动我，但它们又是那么不起眼，不久后我就会忘记。过去的都过去了，不过现在我不想就让现在的它们被遗忘，我要尽可能地记录。 新学期的第一周也就这么过去了，或者说新学期的第三周就这么过去了，因为疫情耽搁在家没法返校，导致前两周的电工实习没法线下上也没法在线上操作，因此前两周没课，所以这一周才算是我的新学期第一周，没有开始上课怎么能叫新学期呢？不管怎么算，这一周的的确确就这么过去了。 新学期的前三门课过去的一周里，我上了三门课：《计算机通信网络》、《无线自组织网络与应用》和《光通信网络》。每科两节课，一共是六节课。三位老师都很有意思，有说自己从教一纪不知点名为何物的，有网课平台整三四个的，课下还提醒你『你啥时候进的直播啥时候出去我这都有记录，那些进来签个到就走了的同学自己注意点』，也有正常上课群里发『1』签到的。抛开这些不说，老师们课上得挺好。 atimelogger 记录每一分钟周一晚上突然翻到这个自己两年前就下载过的APP————atimelogger，这是一个记录自己每一分钟用在何处的APP，我决定不再试一把，尝试记录自己每一分钟用在何处。从周二开始，这一周每一天我都几乎记录下了自己的每一分钟，这种感觉很奇妙，当你做什么的时候，你会意识到有一个时钟在走，你会不由自主地集中注意力，想要它走慢一点或者抓紧利用这有限的时间。后面我想，不管它在不在，我的生命时钟都在不停地走，不知道在某一天就会停下来，因为它是如此的不可感知，我很少注意到它，但是这个APP帮助我意识到了，它具象了我的生命时钟，让我感受到我的时间在不断消耗，我必须抓紧每一分钟。atimelogger上的记录显示：我每天都花了30~40分钟玩2K19；每天晚上我都会看一集『老友记』，用时22分钟；每天都会记单词，用时20~30分钟；每天我都至少在『微信读书』APP上看了1h书；每天我都至少在床上睡了8个小时；每天我都至少在学习成长上花了6h。我开始喜欢上这种记录的感觉。 重启 Blog周四晚上折腾了一晚，重启Blog，后面几天也在不断完善，终于到了现在这个样子。换了站点的头像，给站点添加了访问人数统计，为每一篇博文添加阅读数统计，在此感谢不蒜子大佬的脚本。周六晚上还添加了相册，到周日晚上，终于可以正常使用了。关于重启博客我是这样想的，上个月我就重启了『记录计划』，只是在手机上写，既然都要记录，为什么不放到网上呢？这样还方便查看，而且我会更有动力去写，Blog是一个比较好的选择。 话不多说，以上就是这一周，关于上的这些课的具体内容我会在后面的文章中详细记录。这些网络类的课很有意思，它们有一种规则的美感，我想如果能自己亲手制定某些规则并加以实现肯定让人兴奋。生活总是有很多的不确定，但我确定关于『记录』这件事我会坚持下去。","content":"<p></p><p align=\"center\" class=\"img\"><br>    <img src=\"/assets/img/2020/astonished_joey.jpg\" alt=\"astonished_joey\" width=\"750\"><br>    <span align=\"center\" style=\"color:#999\">震惊的Joey</span></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><p></p></h2><p>不知不觉间大三已经过完一半，想起在过去的两年半中好像没有值得纪念的事，有点无可奈何，但要说没有发生那么一件在当时让我很有感触的事，当然也不可能，只是我以为自己的记忆会帮我保存那些真正重要的感觉，因此没有记录，但是这样的事怎么会有那么多呢？亲人故去、终有所成之类的记忆深刻的事不常发生，更多的是生活中有感触的小事，它们发生很触动我，但它们又是那么不起眼，不久后我就会忘记。过去的都过去了，不过现在我不想就让现在的它们被遗忘，我要尽可能地记录。<br><a id=\"more\"></a></p>\n<p>新学期的第一周也就这么过去了，或者说新学期的第三周就这么过去了，因为疫情耽搁在家没法返校，导致前两周的电工实习没法线下上也没法在线上操作，因此前两周没课，所以这一周才算是我的新学期第一周，没有开始上课怎么能叫新学期呢？不管怎么算，这一周的的确确就这么过去了。</p>\n<h2 id=\"新学期的前三门课\"><a href=\"#新学期的前三门课\" class=\"headerlink\" title=\"新学期的前三门课\"></a>新学期的前三门课</h2><p>过去的一周里，我上了三门课：《计算机通信网络》、《无线自组织网络与应用》和《光通信网络》。每科两节课，一共是六节课。三位老师都很有意思，有说自己从教一纪不知点名为何物的，有网课平台整三四个的，课下还提醒你『你啥时候进的直播啥时候出去我这都有记录，那些进来签个到就走了的同学自己注意点』，也有正常上课群里发『1』签到的。抛开这些不说，老师们课上得挺好。</p>\n<h2 id=\"atimelogger-记录每一分钟\"><a href=\"#atimelogger-记录每一分钟\" class=\"headerlink\" title=\"atimelogger 记录每一分钟\"></a>atimelogger 记录每一分钟</h2><p>周一晚上突然翻到这个自己两年前就下载过的APP————atimelogger，这是一个记录自己每一分钟用在何处的APP，我决定不再试一把，尝试记录自己每一分钟用在何处。从周二开始，这一周每一天我都几乎记录下了自己的每一分钟，这种感觉很奇妙，当你做什么的时候，你会意识到有一个时钟在走，你会不由自主地集中注意力，想要它走慢一点或者抓紧利用这有限的时间。后面我想，不管它在不在，我的生命时钟都在不停地走，不知道在某一天就会停下来，因为它是如此的不可感知，我很少注意到它，但是这个APP帮助我意识到了，它具象了我的生命时钟，让我感受到我的时间在不断消耗，我必须抓紧每一分钟。<br>atimelogger上的记录显示：我每天都花了30~40分钟玩2K19；每天晚上我都会看一集『老友记』，用时22分钟；每天都会记单词，用时20~30分钟；每天我都至少在『微信读书』APP上看了1h书；每天我都至少在床上睡了8个小时；每天我都至少在学习成长上花了6h。我开始喜欢上这种记录的感觉。</p>\n<h2 id=\"重启-Blog\"><a href=\"#重启-Blog\" class=\"headerlink\" title=\"重启 Blog\"></a>重启 Blog</h2><p>周四晚上折腾了一晚，重启Blog，后面几天也在不断完善，终于到了现在这个样子。换了站点的头像，给站点添加了访问人数统计，为每一篇博文添加阅读数统计，在此感谢不蒜子大佬的脚本。周六晚上还添加了<code>相册</code>，到周日晚上，终于可以正常使用了。关于重启博客我是这样想的，上个月我就重启了『记录计划』，只是在手机上写，既然都要记录，为什么不放到网上呢？这样还方便查看，而且我会更有动力去写，Blog是一个比较好的选择。</p>\n<hr>\n<p>话不多说，以上就是这一周，关于上的这些课的具体内容我会在后面的文章中详细记录。这些网络类的课很有意思，它们有一种规则的美感，我想如果能自己亲手制定某些规则并加以实现肯定让人兴奋。生活总是有很多的不确定，但我确定关于『记录』这件事我会坚持下去。</p>\n","tags":[{"name":"记录","slug":"记录","permalink":"https://jonathan1214.github.io/tags/记录/"},{"name":"weekly","slug":"weekly","permalink":"https://jonathan1214.github.io/tags/weekly/"}]},{"title":"union-find算法的原理及实现","date":"2020-03-13T07:26:53.000Z","path":"2020/03/union-find/","text":"在计算机网络中，对于任意两个节点，可以在其间构建一条连接建立通信，这样做没有问题，但是在整个网络中都这么做会导致需要建立的连接非常多，容易计算得到N个节点的网络需要的连接数N(N-1)/2，这增加了网络的负担，实现起来也不容易，有什么办法改进呢？六度空间理论大家都知道，说的是最多通过六个人，我们可以和世界上任何人建立联系，那么如何知道两个人之间是否可以建立联系呢？这两个问题其实都属于连通性问题，可以使用union-find算法解决，步骤如下： 1. 数据准备p和q表示两个抽象的节点，可以用整数表示，如果『p，q 是相连的』，则意味着： 自反性：p和p是相连的。 对称性：如果p和q相连，则q和p也是相连的。 传递性：如果p和q相连，q和r相连，则p和r也相连。 我们可以用一个数组表示所有的节点，数组的每个位置表示一个节点，每个位置的值表示这个节点所在分量的标识符，初始化的时候每个节点的标识符都是其本身，如下所示： 12345void UF(int N) &#123; a = new int[N]; // 初始化节点数组 for (int i = 0; i &lt; N; i++) a[i] = i;&#125; 2. 实现quick-find在union-find算法中，有两个目标需要实现：判断两个节点是否连通和连接两个节点的。一种简单的思路是这样的，规定同属一个连通分量的标识符相同，比如：节点0，1和2是连通的，我们选择1为标识符，那么a[0]=a[1]=a[2]=1。这样做判断两个节点是否连通就可以在常数时间完成，基于此规则我们可以实现quick-find算法，但是这样做union的成本就会上升，每次union，需要遍历所有的节点，并对合适节点的标识符进行改变，这是个平方级别的算法，如下所示。 123456789101112boolean isConnected(int p, int q) &#123; return find(p)==find(q);&#125;int find(int p) &#123; return a[p]; &#125;void union(int p, int q) &#123; int pp = find(p); // p 节点的标识符 int qq = find(q); // q 节点的标识符 if (pp == qq) return; // 将 pp 标识符全部改成 qq for (int i = 0; i &lt; a.length; i++) if (a[i] == pp) a[i] = qq;&#125; quick-unionquick-find算法中，union的成本是平方级别的，其原因在于每次union需要遍历全部的节点，可以进行一些调整，得到改进，这就是quick-union算法。具体实现：在同一类别的中的节点，我们不再让所有节点保存相同的标识符，而是在节点中保持其父节点，类似一棵树，不过是向上走的，子节点指向父节点，根节点保存的是他自己，这样一来，进行union操作时，至于遍历找到根节点，然后让其中一个根节点指向另一个根节点即可，进行find操作时，只需遍历找到根节点即指向自身的节点。 12345678910int find(int p) &#123; while (a[p] != p) p = a[p]; return p;&#125;void union(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); // pRoot 节点指向 Qroot a[pRoot] = qRoot;&#125; 加权 quick-union这样做没什么问题，但是在最坏情况下，节点是依次相连的，串成一串，这会导致算法的性能下降，我们对其稍加改进，每次union时，都把节点数小的那一组连接到节点数大的那一组，这就是加权的quick-union算法。实现这个算法我们需要一个数组保存每个节点下节点的数目，对根节点而言，这个数就是它所在组的大小。 123456789101112131415161718192021UF(int N) &#123; a = new int[N]; // 初始化节点数组 sz = new int[N]; // 保存节点数目 for (int i = 0; i &lt; N; i++) a[i] = i; for (int i = 0; i &lt; N; i++) sz[i] = 1;&#125;// find 算法没有改变void union(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) return; if (sz[pRoot] &gt; sz[qRoot]) &#123; // p 所在组较大 a[qRoot] = pRoot; // 将q连接到q上 sz[pRoot] += sz[qRoot]; // 更新 pRoot 下的节点数 &#125; else &#123; // q 所在组较大 a[pRoot] = qRoot; sz[qRoot] += sz[pRoot]; &#125;&#125; 路径压缩还有一种路径压缩算法可以改进quick-union，即每次查找时，都把途径的节点指向根节点，这样均摊下来的find成本比较小，可以证明，路径压缩的加权quick-union算法是实现union-find最快的算法。 12345678910int find(int p) &#123; int x = p, t; while (a[p] != p) p = a[p]; // 找到根节点 while (x != p) &#123; // 直到到达根节点 t = a[x]; // 保存当前节点的父节点 a[x] = p; // 当前节点直接连接到根节点 x = t; // 移动到当前节点的父节点 &#125;&#125;// union 算法不变 回到开头的那两个问题，有了union-find算法，我们来尝试解决它们。对于网络中节点是否需要构建新的连接，抽象出网络的节点构建起UF后，执行isConnected()即可判断是否需要建立新的连接，对于两个人是否可以建立连接的问题，我们用同样的方法也可以解决，但要是想通过最少的中间人就认识一个人，该怎么做呢，这又是另外一个问题了。","content":"<p>在计算机网络中，对于任意两个节点，可以在其间构建一条连接建立通信，这样做没有问题，但是在整个网络中都这么做会导致需要建立的连接非常多，容易计算得到<code>N</code>个节点的网络需要的连接数<code>N(N-1)/2</code>，这增加了网络的负担，实现起来也不容易，有什么办法改进呢？六度空间理论大家都知道，说的是最多通过六个人，我们可以和世界上任何人建立联系，那么如何知道两个人之间是否可以建立联系呢？这两个问题其实都属于连通性问题，可以使用<code>union-find</code>算法解决，步骤如下：</p>\n<h2 id=\"1-数据准备\"><a href=\"#1-数据准备\" class=\"headerlink\" title=\"1. 数据准备\"></a>1. 数据准备</h2><p><code>p</code>和<code>q</code>表示两个抽象的节点，可以用整数表示，如果『p，q 是相连的』，则意味着：</p>\n<ul>\n<li>自反性：<code>p</code>和<code>p</code>是相连的。</li>\n<li>对称性：如果<code>p</code>和<code>q</code>相连，则<code>q</code>和<code>p</code>也是相连的。</li>\n<li>传递性：如果<code>p</code>和<code>q</code>相连，<code>q</code>和<code>r</code>相连，则<code>p</code>和<code>r</code>也相连。</li>\n</ul>\n<p>我们可以用一个数组表示所有的节点，数组的每个位置表示一个节点，每个位置的值表示这个节点所在分量的标识符，初始化的时候每个节点的标识符都是其本身，如下所示：<br><a id=\"more\"></a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">UF</span><span class=\"params\">(<span class=\"keyword\">int</span> N)</span> </span>&#123;</span><br><span class=\"line\">    a = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[N]; <span class=\"comment\">// 初始化节点数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++)</span><br><span class=\"line\">        a[i] = i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-实现\"><a href=\"#2-实现\" class=\"headerlink\" title=\"2. 实现\"></a>2. 实现</h2><h3 id=\"quick-find\"><a href=\"#quick-find\" class=\"headerlink\" title=\"quick-find\"></a>quick-find</h3><p>在<code>union-find</code>算法中，有两个目标需要实现：判断两个节点是否连通和连接两个节点的。一种简单的思路是这样的，规定同属一个连通分量的标识符相同，比如：节点<code>0</code>，<code>1</code>和<code>2</code>是连通的，我们选择<code>1</code>为标识符，那么<code>a[0]=a[1]=a[2]=1</code>。这样做判断两个节点是否连通就可以在常数时间完成，基于此规则我们可以实现<code>quick-find</code>算法，但是这样做<code>union</code>的成本就会上升，每次<code>union</code>，需要遍历所有的节点，并对合适节点的标识符进行改变，这是个平方级别的算法，如下所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isConnected</span><span class=\"params\">(<span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> q)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> find(p)==find(q);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> p)</span> </span>&#123; <span class=\"keyword\">return</span> a[p]; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">union</span><span class=\"params\">(<span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> q)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pp = find(p);   <span class=\"comment\">// p 节点的标识符</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> qq = find(q);   <span class=\"comment\">// q 节点的标识符</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pp == qq) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 将 pp 标识符全部改成 qq</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; a.length; i++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a[i] == pp) a[i] = qq;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"quick-union\"><a href=\"#quick-union\" class=\"headerlink\" title=\"quick-union\"></a>quick-union</h3><p>quick-find算法中，union的成本是平方级别的，其原因在于每次union需要遍历全部的节点，可以进行一些调整，得到改进，这就是quick-union算法。具体实现：在同一类别的中的节点，我们不再让所有节点保存相同的标识符，而是在节点中保持其父节点，类似一棵树，不过是向上走的，子节点指向父节点，根节点保存的是他自己，这样一来，进行union操作时，至于遍历找到根节点，然后让其中一个根节点指向另一个根节点即可，进行find操作时，只需遍历找到根节点即指向自身的节点。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> p)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (a[p] != p) p = a[p];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">union</span><span class=\"params\">(<span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> q)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pRoot = find(p);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> qRoot = find(q);</span><br><span class=\"line\">    <span class=\"comment\">// pRoot 节点指向 Qroot</span></span><br><span class=\"line\">    a[pRoot] = qRoot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"加权-quick-union\"><a href=\"#加权-quick-union\" class=\"headerlink\" title=\"加权 quick-union\"></a>加权 quick-union</h3><p>这样做没什么问题，但是在最坏情况下，节点是依次相连的，串成一串，这会导致算法的性能下降，我们对其稍加改进，每次union时，都把节点数小的那一组连接到节点数大的那一组，这就是加权的quick-union算法。实现这个算法我们需要一个数组保存每个节点下节点的数目，对根节点而言，这个数就是它所在组的大小。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UF(<span class=\"keyword\">int</span> N) &#123;</span><br><span class=\"line\">    a = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[N];     <span class=\"comment\">// 初始化节点数组</span></span><br><span class=\"line\">    sz = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[N];    <span class=\"comment\">// 保存节点数目</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++)</span><br><span class=\"line\">        a[i] = i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++)</span><br><span class=\"line\">        sz[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// find 算法没有改变</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">union</span><span class=\"params\">(<span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> q)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pRoot = find(p);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> qRoot = find(q);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pRoot == qRoot) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sz[pRoot] &gt; sz[qRoot]) &#123; <span class=\"comment\">// p 所在组较大</span></span><br><span class=\"line\">        a[qRoot] = pRoot; <span class=\"comment\">// 将q连接到q上</span></span><br><span class=\"line\">        sz[pRoot] += sz[qRoot]; <span class=\"comment\">// 更新 pRoot 下的节点数</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;    <span class=\"comment\">// q 所在组较大</span></span><br><span class=\"line\">        a[pRoot] = qRoot;</span><br><span class=\"line\">        sz[qRoot] += sz[pRoot];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"路径压缩\"><a href=\"#路径压缩\" class=\"headerlink\" title=\"路径压缩\"></a>路径压缩</h3><p>还有一种路径压缩算法可以改进quick-union，即每次查找时，都把途径的节点指向根节点，这样均摊下来的find成本比较小，可以证明，路径压缩的加权quick-union算法是实现union-find最快的算法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> p)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x = p, t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (a[p] != p) p = a[p]; <span class=\"comment\">// 找到根节点</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (x != p) &#123; <span class=\"comment\">// 直到到达根节点</span></span><br><span class=\"line\">        t = a[x];   <span class=\"comment\">// 保存当前节点的父节点</span></span><br><span class=\"line\">        a[x] = p;   <span class=\"comment\">// 当前节点直接连接到根节点</span></span><br><span class=\"line\">        x = t;      <span class=\"comment\">// 移动到当前节点的父节点</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// union 算法不变</span></span><br></pre></td></tr></table></figure>\n<hr>\n<p>回到开头的那两个问题，有了union-find算法，我们来尝试解决它们。对于网络中节点是否需要构建新的连接，抽象出网络的节点构建起<code>UF</code>后，执行<code>isConnected()</code>即可判断是否需要建立新的连接，对于两个人是否可以建立连接的问题，我们用同样的方法也可以解决，但要是想通过最少的中间人就认识一个人，该怎么做呢，这又是另外一个问题了。</p>\n","tags":[{"name":"算法","slug":"算法","permalink":"https://jonathan1214.github.io/tags/算法/"},{"name":"Java","slug":"Java","permalink":"https://jonathan1214.github.io/tags/Java/"},{"name":"union-find","slug":"union-find","permalink":"https://jonathan1214.github.io/tags/union-find/"}]},{"title":"算法的分析方法","date":"2020-03-10T13:30:43.000Z","path":"2020/03/a-way-to-algorithm-analysis/","text":"也看了几天『算法』了，总是觉得不得要领，在此做一点笔记想必会有所帮助，能够完整地写下来或者清楚地讲述给别人并使之理解才算掌握了知识，这个观点来自费曼，我深以为然。 算法及其重要性算法 被用来描述一种有限的、确定的、有效的并适合计算机程序来实现的解决问题的方法，它是计算机科学的基础，是这个领域研究的核心。『算法』在前言中就如此讲到： 算法和数据结构的学习的学习是所有计算机教学计划的基础。 我想算法的重要性已不言而喻，这也是我在此努力学习的原因，当然我不是计算机系的学生，但我深信一定程度上了解算法和其分析方法对我的专业学习和理解也很有帮助。 使用数据抽象开发可重用的算法虽然我关心的是算法背后的逻辑，但是真正实现起来还是落在代码上，为了保证其可重用性，使用数据抽象，让我们更关注算法的内核，而不是具体的数据。按照下面的步骤解决问题： 定义 API 根据特定的应用场景开发用例代码 描述一种数据结构，并在 API 说对应的抽象数据类型的实现中根据它定义类的实例变量 描述算法 分析算法的性能特点 算法分析诸如『我的算法会运行多久？』和『为什么我的程序耗尽了所有的内存』这样的基础问题，我们使用 科学方法 可以给出实际性的回答，如下所示，同时使用 数学分析 为算法建立模型，还可以使用 实验数据 验证模型。 细致的观察真实世界的特点 根据观察的结果提出假设模型 预测未来事件 继续观测并核实预测的准确性 如此反复直到确认预测和观察一致 进行实际分析之前，首先要确定 输入模型 和 问题的规模，其实就是说 输入数据量的大小 和 数据的特点 对运行时间的影响，显然运行时间会随着规模的增大而变长。 关于数学分析，依据 Knuth 的观点，程序运行的总时间主要与 执行每条语句的耗时 和 执行每条语句的频率有关。对于前者，这由机器决定，我们不关心，而后者由程序和输入决定，这正是我们要分析的。对于语句频率的分析我们会采用近似的方法，这由会得到 增长的数量级 这一概念，当输入规模很大时，这被验证是可行的，而我们正是关注算法处理大规模输入的性能。 增长的数量级概念的应用使我们能够 将程序和它实现的算法隔离开，算法和输入模型决定了增长的数量级。 使用 成本模型 评估算法的性质，该模型定义了算法中的基本操作，如数组的访问次数和元素的交换次数等等。在选定的数学模型下，我们或许可以用精确的数学语言说明算法的性质，这正是我们进行数学分析的目的。 以上我们可以得出分析程序运行时间数学模型的步骤如下： 确定输入模型下，定义问题的规模 识别内循环 根据内循环的操作确定成本模型 对于规定的输入，判断这些操作的执行频率","content":"<p>也看了几天『算法』了，总是觉得不得要领，在此做一点笔记想必会有所帮助，能够完整地写下来或者清楚地讲述给别人并使之理解才算掌握了知识，这个观点来自费曼，我深以为然。<br><!-- 这里应该添加一个目录 --><br><a id=\"more\"></a></p>\n<h2 id=\"算法及其重要性\"><a href=\"#算法及其重要性\" class=\"headerlink\" title=\"算法及其重要性\"></a>算法及其重要性</h2><p><strong>算法</strong> 被用来描述一种有限的、确定的、有效的并适合计算机程序来实现的解决问题的方法，它是计算机科学的基础，是这个领域研究的核心。『算法』在前言中就如此讲到：</p>\n<blockquote>\n<p>算法和数据结构的学习的学习是所有计算机教学计划的基础。</p>\n</blockquote>\n<p>我想算法的重要性已不言而喻，这也是我在此努力学习的原因，当然我不是计算机系的学生，但我深信一定程度上了解算法和其分析方法对我的专业学习和理解也很有帮助。</p>\n<h2 id=\"使用数据抽象开发可重用的算法\"><a href=\"#使用数据抽象开发可重用的算法\" class=\"headerlink\" title=\"使用数据抽象开发可重用的算法\"></a>使用数据抽象开发可重用的算法</h2><p>虽然我关心的是算法背后的逻辑，但是真正实现起来还是落在代码上，为了保证其可重用性，使用数据抽象，让我们更关注算法的内核，而不是具体的数据。按照下面的步骤解决问题：</p>\n<ul>\n<li>定义 API</li>\n<li>根据特定的应用场景开发用例代码</li>\n<li>描述一种数据结构，并在 API 说对应的抽象数据类型的实现中根据它定义类的实例变量</li>\n<li>描述算法</li>\n<li>分析算法的性能特点</li>\n</ul>\n<h2 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h2><p>诸如『我的算法会运行多久？』和『为什么我的程序耗尽了所有的内存』这样的基础问题，我们使用 <em>科学方法</em> 可以给出实际性的回答，如下所示，同时使用 <em>数学分析</em> 为算法建立模型，还可以使用 <em>实验数据</em> 验证模型。</p>\n<ul>\n<li>细致的观察真实世界的特点</li>\n<li>根据观察的结果提出假设模型</li>\n<li>预测未来事件</li>\n<li>继续观测并核实预测的准确性</li>\n<li>如此反复直到确认预测和观察一致</li>\n</ul>\n<p>进行实际分析之前，首先要确定 <strong>输入模型</strong> 和 <strong>问题的规模</strong>，其实就是说 <strong>输入数据量的大小</strong> 和 <strong>数据的特点</strong> 对运行时间的影响，显然运行时间会随着规模的增大而变长。</p>\n<p>关于数学分析，依据 Knuth 的观点，程序运行的总时间主要与 <strong>执行每条语句的耗时</strong> 和 <strong>执行每条语句的频率有关</strong>。对于前者，这由机器决定，我们不关心，而后者由程序和输入决定，这正是我们要分析的。对于语句频率的分析我们会采用近似的方法，这由会得到 <strong>增长的数量级</strong> 这一概念，当输入规模很大时，这被验证是可行的，而我们正是关注算法处理大规模输入的性能。</p>\n<p>增长的数量级概念的应用使我们能够 <strong>将程序和它实现的算法隔离开</strong>，算法和输入模型决定了增长的数量级。</p>\n<p>使用 <strong>成本模型</strong> 评估算法的性质，该模型定义了算法中的基本操作，如数组的访问次数和元素的交换次数等等。在选定的数学模型下，我们或许可以用精确的数学语言说明算法的性质，这正是我们进行数学分析的目的。</p>\n<p>以上我们可以得出分析程序运行时间数学模型的步骤如下：</p>\n<ul>\n<li>确定输入模型下，定义问题的规模</li>\n<li>识别内循环</li>\n<li>根据内循环的操作确定成本模型</li>\n<li>对于规定的输入，判断这些操作的执行频率</li>\n</ul>\n","tags":[{"name":"算法","slug":"算法","permalink":"https://jonathan1214.github.io/tags/算法/"},{"name":"Java","slug":"Java","permalink":"https://jonathan1214.github.io/tags/Java/"}]},{"title":"记录高频硬件课程设计","date":"2019-12-29T01:23:10.000Z","path":"2019/12/record-of-high-frequency-course-design/","text":"本文绝大部分内容是在19年12月29日写的，我记得很清楚，那天是周日上午，我没有为即将到来的通原考试而复习，而是选择去写点东西记录几天前刚刚结束的高频课设，这是一次很难忘的经历，有痛苦也有快乐，有想过放弃但还是坚持了下来，感谢自己和队友们。现在是2020年3月15日，本该在学校度过周日的我，和所有的大学生一样，因为肺炎疫情只能在家里学习，我没什么学习状态，有些无聊，因此整理博客，把这篇去年的记录整理整理，发到GitHubBlog上，留作纪念，发表日期还是使用去年写这篇文章的日子。 最终验收12月24号，高频硬件课设验收，在队友的强烈要求下，我们选择了一个比较宽松的老师给我们验收，因为我们功率达不到，但还想 『恰完烂分』，这能对他的保研有所帮助。最后的结果很好，我们拿到了5分（满分5分），『烂分恰完』。 最终验收时电路连接和波形 开始12月17号周二下午考完『随机过程』，终于有时间休息了，躺了一个小时，吃个饭，室友已经去搞硬件了，虽然已经是晚上9点多了，但我还想去，带上东西，去李老师办公室焊。折腾了两个小时，焊好了一个西勒振荡器，但没有测试工具，只能第二天测试焊接是否正确，测试工具缺乏和焊接出错这两个问题在整个课设过程中一直困扰着我们。 第一天晚上焊好的西勒振荡器 一起干第二天是周三，没有课，我和赵公子决定去实验室接着焊板子，顺便测试下昨晚上焊的振荡器。两个小时后，我们焊好了发射机和接收机的振荡器，经过测试，他的能用，而我的那块振荡器产生了寄生调幅。检查了电路没有任何问题，折腾到下午，最后发现是射极偏置电阻过大导致的，微调射极电阻，即可解决这个问题。 下午和晚上我们都在实验室呆着，一直做到晚上11点。因为我已经很久没焊接东西，有点手生，他更是没啥经验，我们效率比较低，只焊好了一个乘法电路、一个中频放大器和一个包络检波器。后面测试时发现，我焊接的那个乘法电路不能实现信号相乘。那时我还不知道，接下来3天我都会把时间花在乘法电路上，如果早知道调试它会这么折腾，第一天晚上就应该当机立断重新焊一个的。 心生退意接下来的几天我感到痛苦不堪，我焊接乘法电路始终不好使，不知为什么我就是不愿重新焊一块，执着地想把它修好，但这一切都是徒劳的。看着周围的同学一个个都做出来乘法电路了，我开始怀疑自己：如果做不出来是不是证明我不行，我怎么能不行呢？要不放弃吧，这样就不存在证明了，我告诉自己这些bonus对我来说并不那么重要，我保研与否与这课设5分没什么关系。沃老板执着地说焊板子的烟搞得他很难受，实验室里面人太多了，空气太差，乌烟瘴气，他想回寝室做，这样的参与状态让我心有不快，偏偏他才是一定要拿这 5 分保研的人，为什么我要受这些精神折磨，我当时的确不想再做下去了。 周六早上，纠结了许久，我去教化补充了些元器件，决定去实验室再焊一个乘法器，还说服沃老板也焊一个接收机的乘法电路。我不知道是什么力量支撑着我继续做下去，这件事对我来说不是那么必要，最诱人的bonus并不是我一定需要的，如果不做课设，我可以去复习通原，我可以享受轻松的一周。事后我仔细想了想，大概是因为我自己的性格决定的，我不是那种遇到问题就放弃的人，借口谁都有一些，但是作为我，一旦开始做了，就要做到最后，没有中途放弃的，之前的软件仿真就是如此，没有理由硬件不坚持下去，到这个时候，其实做这个课设已经变成了和自己较劲了，我不想就这么输了。 周六下午去做了通信原理实验，晚上终于焊好我的第二块乘法电路，测试再次失败，沃老板也焊好接收机混频电路，经过测试也失败。这时候我心态已经到了最低点了，我真的不想再来了，前面说的那么多不服输如何如何，可是看着别人一个个做好，我的却始终不行，旁边还有人明着嘲讽我，这使我明白『挫败感』是何含义。晚上10点，我和沃老板回寝室了，赵公子在周五下午有事回家了，但他做的已经足够多了。我突然决定不再去了。 坚持才是胜利周日上午我还是去实验室了，我想就是什么都做不出来，也得一直在实验室坐着，我就要和它刚到底。好在一切坚持都没有白费，我的乘法电路测试成功了，事实证明我的电路设计没有问题，焊接的也没有问题，昨晚测试失败只是因为电路连线没有接好，胜利让我欣喜若狂，我真想大声怒吼：我终于完成了。另一边也有好消息传来，沃老板焊的和赵公子焊的乘法电路都是好使的，还有什么比此刻更快乐呢？ 赵公子的乘法器AM波形 沃老板的混频器波形 周日下午发生了一些不愉快的事情，因为下午找不到他人（其实他在午睡），我对沃老板的不满更加强烈了，而那时我已经十分疲惫，愤怒之下，下午3点左右我直接回寝室，拒绝回他消息，然后睡了一觉。期间他来找我，我『哈哈』糊弄过去，不想再干。6点多起来看一眼手机，想了想，还是再去试试，把级联和功率要求做完吧，都已经到这个份上了，干脆就把它做到完。 乘胜追击我不想就此打住，野心开始膨胀了，『恰5分』 是调侃，此时更像是口号。发射机 AM 调制输出接上我焊调试乘法器抽空焊好的小信号放大器，效果非常好！放大了80倍，但我心里清楚，因为没有接负载，最后功率肯定达不到；接收机，混频后中频放大再检波，效果很差，但也算检波出来了，在要求不那么严苛的时候，可以拿到分；发射机接收机级联成功，和仿真保持一致。 如此算来，我们已经可以拿到 4.5 分，但是我们不想收手，我们继续调放大器，要把功率的 5 分也拿到手。很不幸，我们没有成功，三极管射极电阻过小，导致射极电流过大，二极管被烧坏了，放大器也就怀了，这又是我们唯一的放大器，级联也没办法做了，这下只有 4 分了，后悔，懊恼。 第二天周一，已经是12月23号了，我都没想到自己会在这上面花上近一周时间。白天上了一天课，晚上我们接着调试了一下，还是那个问题，AM 波后的小信号放大器不好使，级联就不行，功率也没有。赵公子也回来了，我们让他重新焊了一个，失败了，因为我临时对之前测试成功的电路做了修改，为了减小电流避免三极管烧毁的事再发生，但是我没想到这么一改，电流太小，放大倍数达不到要求，而且我应该自己亲手焊的。可以说今天又是一无所获。但我不会就此打住，我不愿放弃。 周二上午上完微波课，我立马去教化买了元件，再焊一个小信号放大器，再试一次，不到最后，谁也不知道结果，我不想放弃。一番折腾，焊好，测试，成功。 下午验收前一刻，上周三买的陶瓷滤波器终于从深圳邮到了学校，我赶紧去取回来，接到电路中，完美!『烂分恰完』。 后记做完这次课设，心里有太多感慨，很多次我都想放弃了，但是总有一股力量把我拉了回来，这其中有对朋友承诺的坚守也有自己那股不服输的劲，验收成功那一刻我有点想哭，是啊，这整个过程只有我自己这么看重吧，最后还在自我感动，但如果没有这自我感动，我不知道自己能否坚持下来。当然，课设整个过程也暴露了我的一些问题：我需要有更强大的精神力量，激励自己前进，也要学会如何带领团队前进。","content":"<p>本文绝大部分内容是在19年12月29日写的，我记得很清楚，那天是周日上午，我没有为即将到来的通原考试而复习，而是选择去写点东西记录几天前刚刚结束的高频课设，这是一次很难忘的经历，有痛苦也有快乐，有想过放弃但还是坚持了下来，感谢自己和队友们。现在是2020年3月15日，本该在学校度过周日的我，和所有的大学生一样，因为肺炎疫情只能在家里学习，我没什么学习状态，有些无聊，因此整理博客，把这篇去年的记录整理整理，发到GitHubBlog上，留作纪念，发表日期还是使用去年写这篇文章的日子。<br><a id=\"more\"></a></p>\n<h2 id=\"最终验收\"><a href=\"#最终验收\" class=\"headerlink\" title=\"最终验收\"></a>最终验收</h2><p>12月24号，高频硬件课设验收，在队友的强烈要求下，我们选择了一个比较宽松的老师给我们验收，因为我们功率达不到，但还想 <strong>『恰完烂分』</strong>，这能对他的保研有所帮助。最后的结果很好，我们拿到了5分（满分5分），<strong>『烂分恰完』</strong>。</p>\n<div align=\"center\" class=\"img\"><br>    <img src=\"/assets/img/2019/final.jpg\" alt=\"验收\" height=\"400\"><br>    <p align=\"center\" style=\"color:#999\">最终验收时电路连接和波形</p><br></div>\n\n<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><p>12月17号周二下午考完『随机过程』，终于有时间休息了，躺了一个小时，吃个饭，室友已经去搞硬件了，虽然已经是晚上9点多了，但我还想去，带上东西，去李老师办公室焊。折腾了两个小时，焊好了一个西勒振荡器，但没有测试工具，只能第二天测试焊接是否正确，测试工具缺乏和焊接出错这两个问题在整个课设过程中一直困扰着我们。</p>\n<div align=\"center\" class=\"img\"><br>    <img src=\"/assets/img/2019/siler_oscillator.jpg\" alt=\"西勒振荡器\" height=\"400\"><br>    <p align=\"center\" style=\"color:#999\">第一天晚上焊好的西勒振荡器</p><br></div>\n\n<h2 id=\"一起干\"><a href=\"#一起干\" class=\"headerlink\" title=\"一起干\"></a>一起干</h2><p>第二天是周三，没有课，我和赵公子决定去实验室接着焊板子，顺便测试下昨晚上焊的振荡器。两个小时后，我们焊好了发射机和接收机的振荡器，经过测试，他的能用，而我的那块振荡器产生了寄生调幅。检查了电路没有任何问题，折腾到下午，最后发现是射极偏置电阻过大导致的，微调射极电阻，即可解决这个问题。</p>\n<p>下午和晚上我们都在实验室呆着，一直做到晚上11点。因为我已经很久没焊接东西，有点手生，他更是没啥经验，我们效率比较低，只焊好了一个乘法电路、一个中频放大器和一个包络检波器。后面测试时发现，我焊接的那个乘法电路不能实现信号相乘。那时我还不知道，接下来3天我都会把时间花在乘法电路上，如果早知道调试它会这么折腾，第一天晚上就应该当机立断重新焊一个的。</p>\n<h2 id=\"心生退意\"><a href=\"#心生退意\" class=\"headerlink\" title=\"心生退意\"></a>心生退意</h2><p>接下来的几天我感到痛苦不堪，我焊接乘法电路始终不好使，不知为什么我就是不愿重新焊一块，执着地想把它修好，但这一切都是徒劳的。看着周围的同学一个个都做出来乘法电路了，我开始怀疑自己：如果做不出来是不是证明我不行，我怎么能不行呢？要不放弃吧，这样就不存在证明了，我告诉自己这些bonus对我来说并不那么重要，我保研与否与这课设5分没什么关系。沃老板执着地说焊板子的烟搞得他很难受，实验室里面人太多了，空气太差，乌烟瘴气，他想回寝室做，这样的参与状态让我心有不快，偏偏他才是一定要拿这 5 分保研的人，为什么我要受这些精神折磨，我当时的确不想再做下去了。</p>\n<p>周六早上，纠结了许久，我去教化补充了些元器件，决定去实验室再焊一个乘法器，还说服沃老板也焊一个接收机的乘法电路。我不知道是什么力量支撑着我继续做下去，这件事对我来说不是那么必要，最诱人的bonus并不是我一定需要的，如果不做课设，我可以去复习通原，我可以享受轻松的一周。事后我仔细想了想，大概是因为我自己的性格决定的，我不是那种遇到问题就放弃的人，借口谁都有一些，但是作为我，一旦开始做了，就要做到最后，没有中途放弃的，之前的软件仿真就是如此，没有理由硬件不坚持下去，到这个时候，其实做这个课设已经变成了和自己较劲了，我不想就这么输了。</p>\n<p>周六下午去做了通信原理实验，晚上终于焊好我的第二块乘法电路，测试再次失败，沃老板也焊好接收机混频电路，经过测试也失败。这时候我心态已经到了最低点了，我真的不想再来了，前面说的那么多不服输如何如何，可是看着别人一个个做好，我的却始终不行，旁边还有人明着嘲讽我，这使我明白『挫败感』是何含义。晚上10点，我和沃老板回寝室了，赵公子在周五下午有事回家了，但他做的已经足够多了。我突然决定不再去了。</p>\n<h2 id=\"坚持才是胜利\"><a href=\"#坚持才是胜利\" class=\"headerlink\" title=\"坚持才是胜利\"></a>坚持才是胜利</h2><p>周日上午我还是去实验室了，我想就是什么都做不出来，也得一直在实验室坐着，我就要和它刚到底。好在一切坚持都没有白费，我的乘法电路测试成功了，事实证明我的电路设计没有问题，焊接的也没有问题，昨晚测试失败只是因为电路连线没有接好，胜利让我欣喜若狂，我真想大声怒吼：我终于完成了。另一边也有好消息传来，沃老板焊的和赵公子焊的乘法电路都是好使的，还有什么比此刻更快乐呢？</p>\n<div align=\"center\"><br>    <img src=\"/assets/img/2019/amplitude_modulation.jpg\" alt=\"AM调幅\" height=\"400\"><br>    <p align=\"center\" style=\"color:#999\">赵公子的乘法器AM波形</p><br>    <img src=\"/assets/img/2019/mixing.jpg\" alt=\"混频\" height=\"400\"><br>    <p align=\"center\" style=\"color:#999\">沃老板的混频器波形</p><br></div>\n\n<p>周日下午发生了一些不愉快的事情，因为下午找不到他人（其实他在午睡），我对沃老板的不满更加强烈了，而那时我已经十分疲惫，愤怒之下，下午3点左右我直接回寝室，拒绝回他消息，然后睡了一觉。期间他来找我，我『哈哈』糊弄过去，不想再干。6点多起来看一眼手机，想了想，还是再去试试，把级联和功率要求做完吧，都已经到这个份上了，干脆就把它做到完。</p>\n<h2 id=\"乘胜追击\"><a href=\"#乘胜追击\" class=\"headerlink\" title=\"乘胜追击\"></a>乘胜追击</h2><p>我不想就此打住，野心开始膨胀了，<strong>『恰5分』</strong> 是调侃，此时更像是口号。发射机 AM 调制输出接上我焊调试乘法器抽空焊好的小信号放大器，效果非常好！放大了80倍，但我心里清楚，因为没有接负载，最后功率肯定达不到；接收机，混频后中频放大再检波，效果很差，但也算检波出来了，在要求不那么严苛的时候，可以拿到分；发射机接收机级联成功，和仿真保持一致。</p>\n<p>如此算来，我们已经可以拿到 4.5 分，但是我们不想收手，我们继续调放大器，要把功率的 5 分也拿到手。很不幸，我们没有成功，三极管射极电阻过小，导致射极电流过大，二极管被烧坏了，放大器也就怀了，这又是我们唯一的放大器，级联也没办法做了，这下只有 4 分了，后悔，懊恼。</p>\n<p>第二天周一，已经是12月23号了，我都没想到自己会在这上面花上近一周时间。白天上了一天课，晚上我们接着调试了一下，还是那个问题，AM 波后的小信号放大器不好使，级联就不行，功率也没有。赵公子也回来了，我们让他重新焊了一个，失败了，因为我临时对之前测试成功的电路做了修改，为了减小电流避免三极管烧毁的事再发生，但是我没想到这么一改，电流太小，放大倍数达不到要求，而且我应该自己亲手焊的。可以说今天又是一无所获。但我不会就此打住，我不愿放弃。</p>\n<p>周二上午上完微波课，我立马去教化买了元件，再焊一个小信号放大器，再试一次，不到最后，谁也不知道结果，我不想放弃。一番折腾，焊好，测试，成功。</p>\n<p>下午验收前一刻，上周三买的陶瓷滤波器终于从深圳邮到了学校，我赶紧去取回来，接到电路中，完美!<strong>『烂分恰完』</strong>。</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>做完这次课设，心里有太多感慨，很多次我都想放弃了，但是总有一股力量把我拉了回来，这其中有对朋友承诺的坚守也有自己那股不服输的劲，验收成功那一刻我有点想哭，是啊，这整个过程只有我自己这么看重吧，最后还在自我感动，但如果没有这自我感动，我不知道自己能否坚持下来。当然，课设整个过程也暴露了我的一些问题：我需要有更强大的精神力量，激励自己前进，也要学会如何带领团队前进。</p>\n","tags":[{"name":"记录","slug":"记录","permalink":"https://jonathan1214.github.io/tags/记录/"}]},{"title":"Believe_in_yourself","date":"2018-06-18T14:30:53.000Z","path":"2018/06/Believe-in-yourself/","text":"最近有点烦躁，事情一件接着一件地扑面而来，丝毫不给我喘气的机会，为了排遣苦闷，我嘴上的脏话多了不少，不过好在这一切都将过去了，过去了之后我一定要好好开始，现在，我只有祈祷最后能有一个好的结果。这是一个疯狂的六月！英语课程考试(6.7)，英语口语测试(6.14)，六级考试(6.16)，科创答辩(6.20)，数学建模考试(6.21)，近代史考试(6.26)，英语期末考试(6.29)……这还远没有结束，七月是工大的小学期时间！八月才放暑假！九月开学！坏消息是大物和微积分的考试放到小学期了，当然，这也可以算是好消息，至少六月份可以喘口气了，真正毫无疑问的好消息自然就是我们会搬进新公寓！","content":"<p>最近有点烦躁，事情一件接着一件地扑面而来，丝毫不给我喘气的机会，为了排遣苦闷，我嘴上的脏话多了不少，不过好在这一切都将过去了，过去了之后我一定要好好开始，现在，我只有祈祷最后能有一个好的结果。<br><a id=\"more\"></a><br>这是一个疯狂的六月！<br>英语课程考试(6.7)，英语口语测试(6.14)，六级考试(6.16)，科创答辩(6.20)，数学建模考试(6.21)，近代史考试(6.26)，英语期末考试(6.29)……这还远没有结束，七月是工大的小学期时间！八月才放暑假！九月开学！坏消息是大物和微积分的考试放到小学期了，当然，这也可以算是好消息，至少六月份可以喘口气了，真正毫无疑问的好消息自然就是我们会搬进新公寓！</p>\n","tags":[{"name":"记录","slug":"记录","permalink":"https://jonathan1214.github.io/tags/记录/"}]},{"title":"数据结构复习","date":"2018-05-14T12:25:46.000Z","path":"2018/05/review-data-structure/","text":"先抄一段Dave在他的书《The Pragmatic Programmer》中的话： You’re a Pragmatic Programmer. You aren’t wedded to any particular technology, but you have a broad enough background in the science, and your experience with practical projects allow you to choose good solution in particular situations. Theory and practice combine to make you strong. You adjust your approach to suit the current circumstance and environment. And you do this continuously as the work progresses. Pragmatic Programmers get the job done, and do it well. Ok，现在开始吧！ C语言程序设计开始 先上第一段代码： 1234567#include &lt;stdio.h&gt;int main(void)&#123; printf(\"Hello world\\n\"); printf(\"This is a C program\"); return 0;&#125; 这是一个简单的C程序，我从这里开始，解释什么的是不需要的。 第二段代码：1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;int main (void)&#123; //这个程序根据你输入的两个整数和输入的一个四则运算符进行运算 int a, b; unsigned int Bool = 0; char ch; printf(\"请输入两个整数：\"); scanf(\"%d\", &amp;a); scanf(\"%d\", &amp;a); printf(\"\\n请输入一个四则运算符：\"); Bool = scanf(\"%c\", &amp;ch); switch (ch) &#123; case '+': printf(\"\\n%d + %d = %d\", a, b, a+b); break; case '-': printf(\"\\n%d - %d = %d\", a, b, a-b); break:; case '*': printf(\"\\n%d * %d = %d\", a, b, a*b); break; case '/': printf(\"\\n%d / %d = %f\", a, b, float(a)/b); break; default: printf(\"输入的不是四则运算符！！！\"); break; &#125; return 0;&#125; OK，上面的代码写出来了！没有什么问题！记几个需要注意的地方： 1. `scanf()`的是有返回值，读到了几个正确的输入就返回几，例如在上面的代码的中，如果输入了一个字符，`Bool`的值就变成`1`，在这里作用不大，不过就是为了复习嘛，无所谓的啦。 2. 注意`switch() case`语句的用法：`switch()`括号内的变量类型一定要是__整型或者字符型__。 第三段代码：1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main (void)&#123; //定义一个二维数组并初始化 int a[2][3] = &#123; &#123;1, 2, 3&#125;, &#123;4, 5, 6&#125; &#125;; //几个指针的声明 int *pt; int (*pa)[3]; //注意：[]的优先级高于* int *pax[3]; //注意与上一个进行对比，这是不一样的 int ar1[2][3]; int ar2[3][2]; int **p2; //以下均是有效的赋值 pt = &amp;a[0][0]; pa = &amp;a[0]; //在这里pt和pa的值相同 pa = &amp;a[1]; p2 = &amp;pt;&#125; 从上面就可以看出来，指针这个东西还是很烦人的，不过也不难，多看几遍就行了，还有要注意指针和数组的关系。指针比数组更本质！ 第四段代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344//找二维数组的鞍点，行最小且列最大的即为鞍点#include &lt;stdio.h&gt;int main (void)&#123; int a[20][20]; int Row, Col; int i, j; printf(\"请输入数组的行数和列数：\"); scanf(\"%d%d\", Row, Col); printf(\"\\n请输入%d个整数：\\n\\t\", Row*Col); for (i = 0; i &lt; Row; i++) for (j = 0; j &lt; Col; j++) scanf(\"%d\", &amp;a[i][j]); for (i = 0; i &lt; Row; i++) &#123; int temp = a[i][0]; int k = 0; int f = 1; for (j = 1; j &lt; Col; j++) &#123; if (temp &gt; a[i][j]) &#123; temp = a[i][j]; k = j; &#125; &#125; for (j = 0; j &lt; Row; j++) &#123; if (j == i) continue; else &#123; if (a[j][k] &gt; a[i][k]) f = 0; &#125; &#125; if (f) printf(\"\\n%d\", &amp;a[i][k]); else printf(\"\\n无鞍点\"); &#125; return 0;&#125; 我也不管什么优化了，丑就丑吧，几个循环套起来又怕什么，比比谁写的更丑，没有运行时间和内存使用限制，写起来就是爽！ 第五段代码：12345678910111213141516171819#include &lt;stdio.h&gt;int main (void)&#123; printf(\"这是一个计算函数值的程序：\\n\"); int x, y; printf(\"请输入整数x的值：\"); scanf(\"%d\", &amp;x); if (x &lt; 0) y = 5*x; else &#123; if (x &lt; 8) y = 2*x - 1; else y = x + 4; &#125; printf(\"\\ny = %d\", y); return 0;&#125; 这段代码没什么意思，纯粹是送的。 第六段代码：1234567891011121314151617181920#include &lt;stdio.h&gt;void Pri_as_ord(int *p, int *q)&#123; int temp; if (*p &gt; *q) &#123; temp = *p; *p = *q; *q = temp; &#125;&#125;int main (void)&#123; int a, b; printf(\"请输入两个整数：\"); scanf(\"%d%d\", &amp;a, &amp;b); Pri_as_ord(&amp;a, &amp;b); printf(\"按由小到大的顺序输出：%d %d\", a, b); return 0;&#125; 还是没什么意思，接着写！ 第七段代码：12345678910111213141516171819202122232425262728293031323334353637383940/*录入三个学生的学号和各自两门课的成绩*/#include &lt;stdio.h&gt;struct Student&#123; int num; float score1; float score2;&#125;;void Best(struct Student student[], int n)&#123; int i, m, aver[n]; for (i = 0; i &lt; n; i++) aver[i] = (student[i].score1 + student[i].score2)/2; if (aver[0] &gt; aver[1]) &#123; if (aver[0] &gt; aver[2]) m = 0; else m = 2; &#125; else &#123; if (aver[1] &gt; aver[2]) m = 1; else m = 2; &#125; printf(\"平均成绩最高的学生的学号是：%d\", student[m].num);&#125;int main (void)&#123; int i = 1; struct Student student[3]; for (; i &lt; 4; i++) printf(\"请输入第%d个学生的学号和两门课的成绩:%d %f %f\", i, student[i-1].num, student[i-1].score1, student[i-1].score2); Best(student, 3); return 0;&#125; 哇！写得想吐了！超级累！不管继续！ 第八段代码123456789101112131415161718192021222324252627282930313233343536/*这只是一个函数，用来实现删除单链表中码值相同的节点，只保留一个假设节点是这样的：struct node&#123; int data; struct node *next; &#125;;*/void Del(struct node *head)&#123; struct node *p, *q, *s; p = head-&gt;next; if (p == NULL) printf(\"Empty List\"); else &#123; while (p-&gt;next != NULL) &#123; q = p-&gt;next; do &#123; while ((q-&gt;data != p-&gt;data) &amp;&amp; (q-&gt;next != NULL)) &#123; s = q; q = q-&gt;next; &#125; if (q-&gt;data == x) &#123; s-&gt;next = q-&gt;next; free (q); &#125; p = s-&gt;next; &#125; while (p != NULL); p = p-&gt;next; &#125; &#125;&#125; 上面的代码有点烦，不过好在思路还算清晰，没有遇到问题，就是时间花得太长了，单链表还是不够熟练，接着来！ 第九段代码：12345678910111213141516171819202122232425//一个队列入排操作struct queue&#123; int item[max]; int front; int rear;&#125;;//初始化时rear=-1，front为0~max-1的任意值//front指向队列第一个元素的前一个位置，rear指向队尾元素所在位置//front=rear时队列满，rear=-1时队列空struct queue q;void Inqueue(struct queue q, int x)&#123; if (q.front == q.rear) printf(\"队满\"); else &#123; if (q.rear = -1) q.rear = q.front; if (q.rear = max-1) q.rear = 0; q.rear += 1; q.item[q.rear] = x; &#125;&#125; 简单的顺序存储的队列，实现入排操作不难，弄懂原理就好。","content":"<p>先抄一段Dave在他的书《The Pragmatic Programmer》中的话：</p>\n<blockquote>\n<p>You’re a Pragmatic Programmer. You aren’t wedded to any particular technology, but you have a broad enough background in the science, and your experience with practical projects allow you to choose good solution in particular situations. Theory and practice combine to make you strong. You adjust your approach to suit the current circumstance and environment. And you do this continuously as the work progresses. Pragmatic Programmers get the job done, and do it well.</p>\n</blockquote>\n<p>Ok，现在开始吧！</p>\n<a id=\"more\"></a>\n<h1 id=\"C语言程序设计\"><a href=\"#C语言程序设计\" class=\"headerlink\" title=\"C语言程序设计\"></a>C语言程序设计</h1><h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><ol>\n<li>先上第一段代码：</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Hello world\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"This is a C program\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是一个简单的C程序，我从这里开始，解释什么的是不需要的。</p>\n<ol start=\"2\">\n<li>第二段代码：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//这个程序根据你输入的两个整数和输入的一个四则运算符进行运算</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a, b;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> Bool = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> ch;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"请输入两个整数：\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;a);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;a);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n请输入一个四则运算符：\"</span>);</span><br><span class=\"line\">    Bool = <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%c\"</span>, &amp;ch);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (ch)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'+'</span>: <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n%d + %d = %d\"</span>, a, b, a+b);</span><br><span class=\"line\">                  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'-'</span>: <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n%d - %d = %d\"</span>, a, b, a-b);</span><br><span class=\"line\">                  <span class=\"keyword\">break</span>:;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'*'</span>: <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n%d * %d = %d\"</span>, a, b, a*b);</span><br><span class=\"line\">                  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'/'</span>: <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n%d / %d = %f\"</span>, a, b, <span class=\"keyword\">float</span>(a)/b);</span><br><span class=\"line\">                  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:  <span class=\"built_in\">printf</span>(<span class=\"string\">\"输入的不是四则运算符！！！\"</span>);</span><br><span class=\"line\">                  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>OK，上面的代码写出来了！没有什么问题！记几个需要注意的地方：</p>\n<pre><code>1. `scanf()`的是有返回值，读到了几个正确的输入就返回几，例如在上面的代码的中，如果输入了一个字符，`Bool`的值就变成`1`，在这里作用不大，不过就是为了复习嘛，无所谓的啦。\n2. 注意`switch() case`语句的用法：`switch()`括号内的变量类型一定要是__整型或者字符型__。\n</code></pre><ol start=\"3\">\n<li>第三段代码：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//定义一个二维数组并初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a[<span class=\"number\">2</span>][<span class=\"number\">3</span>] = &#123;</span><br><span class=\"line\">        &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>&#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//几个指针的声明</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> *pt;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*pa)[<span class=\"number\">3</span>];  <span class=\"comment\">//注意：[]的优先级高于*</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> *pax[<span class=\"number\">3</span>];   <span class=\"comment\">//注意与上一个进行对比，这是不一样的</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ar1[<span class=\"number\">2</span>][<span class=\"number\">3</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ar2[<span class=\"number\">3</span>][<span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> **p2;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//以下均是有效的赋值</span></span><br><span class=\"line\">    pt = &amp;a[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">    pa = &amp;a[<span class=\"number\">0</span>];   <span class=\"comment\">//在这里pt和pa的值相同</span></span><br><span class=\"line\">    pa = &amp;a[<span class=\"number\">1</span>];</span><br><span class=\"line\">    p2 = &amp;pt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>从上面就可以看出来，指针这个东西还是很烦人的，不过也不难，多看几遍就行了，还有要注意指针和数组的关系。指针比数组更本质！</p>\n<ol start=\"4\">\n<li>第四段代码：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//找二维数组的鞍点，行最小且列最大的即为鞍点</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a[<span class=\"number\">20</span>][<span class=\"number\">20</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> Row, Col;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, j;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"请输入数组的行数和列数：\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, Row, Col);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n请输入%d个整数：\\n\\t\"</span>, Row*Col);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; Row; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; Col; j++)</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;a[i][j]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; Row; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = a[i][<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> f = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">1</span>; j &lt; Col; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (temp &gt; a[i][j])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                temp = a[i][j];</span><br><span class=\"line\">                k = j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; Row; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j == i)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (a[j][k] &gt; a[i][k])</span><br><span class=\"line\">                    f = <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f)</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n%d\"</span>, &amp;a[i][k]);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n无鞍点\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>我也不管什么优化了，丑就丑吧，几个循环套起来又怕什么，比比谁写的更丑，没有运行时间和内存使用限制，写起来就是爽！</p>\n<ol start=\"5\">\n<li>第五段代码：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"这是一个计算函数值的程序：\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"请输入整数x的值：\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;x);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        y = <span class=\"number\">5</span>*x;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">8</span>)</span><br><span class=\"line\">            y = <span class=\"number\">2</span>*x - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            y = x + <span class=\"number\">4</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\ny = %d\"</span>, y);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这段代码没什么意思，纯粹是送的。</p>\n<ol start=\"6\">\n<li>第六段代码：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Pri_as_ord</span><span class=\"params\">(<span class=\"keyword\">int</span> *p, <span class=\"keyword\">int</span> *q)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (*p &gt; *q)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        temp = *p;</span><br><span class=\"line\">        *p = *q;</span><br><span class=\"line\">        *q = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a, b;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"请输入两个整数：\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;a, &amp;b);</span><br><span class=\"line\">    Pri_as_ord(&amp;a, &amp;b);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"按由小到大的顺序输出：%d %d\"</span>, a, b);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>还是没什么意思，接着写！</p>\n<ol start=\"7\">\n<li>第七段代码：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*录入三个学生的学号和各自两门课的成绩</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> num;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> score1;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> score2;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Best</span><span class=\"params\">(struct Student student[], <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, m, aver[n];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">        aver[i] = (student[i].score1 + student[i].score2)/<span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (aver[<span class=\"number\">0</span>] &gt; aver[<span class=\"number\">1</span>])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (aver[<span class=\"number\">0</span>] &gt; aver[<span class=\"number\">2</span>])</span><br><span class=\"line\">            m = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            m = <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (aver[<span class=\"number\">1</span>] &gt; aver[<span class=\"number\">2</span>])</span><br><span class=\"line\">            m = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            m = <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"平均成绩最高的学生的学号是：%d\"</span>, student[m].num);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span> <span class=\"title\">student</span>[3];</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; i &lt; <span class=\"number\">4</span>; i++)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"请输入第%d个学生的学号和两门课的成绩:%d %f %f\"</span>,</span><br><span class=\"line\">                i, student[i<span class=\"number\">-1</span>].num, student[i<span class=\"number\">-1</span>].score1, student[i<span class=\"number\">-1</span>].score2);</span><br><span class=\"line\">    Best(student, <span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>哇！写得想吐了！超级累！不管继续！</p>\n<ol start=\"8\">\n<li>第八段代码<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*这只是一个函数，用来实现删除单链表中码值相同的节点，只保留一个</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">假设节点是这样的：struct node&#123;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\tint data;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\tstruct node *next;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t&#125;;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Del</span><span class=\"params\">(struct node *head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> *<span class=\"title\">p</span>, *<span class=\"title\">q</span>, *<span class=\"title\">s</span>;</span></span><br><span class=\"line\">    p = head-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Empty List\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p-&gt;next != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            q = p-&gt;next;</span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> ((q-&gt;data != p-&gt;data) &amp;&amp; (q-&gt;next != <span class=\"literal\">NULL</span>))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    s = q;</span><br><span class=\"line\">                    q = q-&gt;next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (q-&gt;data == x)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    s-&gt;next = q-&gt;next;</span><br><span class=\"line\">                    <span class=\"built_in\">free</span> (q);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                p = s-&gt;next;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> (p != <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">            p = p-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>上面的代码有点烦，不过好在思路还算清晰，没有遇到问题，就是时间花得太长了，单链表还是不够熟练，接着来！</p>\n<ol start=\"9\">\n<li>第九段代码：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//一个队列入排操作</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">queue</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> item[max];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> front;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> rear;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化时rear=-1，front为0~max-1的任意值</span></span><br><span class=\"line\"><span class=\"comment\">//front指向队列第一个元素的前一个位置，rear指向队尾元素所在位置</span></span><br><span class=\"line\"><span class=\"comment\">//front=rear时队列满，rear=-1时队列空</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">queue</span> <span class=\"title\">q</span>;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Inqueue</span><span class=\"params\">(struct <span class=\"built_in\">queue</span> q, <span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (q.front == q.rear)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"队满\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (q.rear = <span class=\"number\">-1</span>)</span><br><span class=\"line\">            q.rear = q.front;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (q.rear = max<span class=\"number\">-1</span>)</span><br><span class=\"line\">            q.rear = <span class=\"number\">0</span>;</span><br><span class=\"line\">        q.rear += <span class=\"number\">1</span>;</span><br><span class=\"line\">        q.item[q.rear] = x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>简单的顺序存储的队列，实现入排操作不难，弄懂原理就好。</p>\n","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://jonathan1214.github.io/tags/数据结构/"},{"name":"C/C++","slug":"C-C","permalink":"https://jonathan1214.github.io/tags/C-C/"}]},{"title":"一点思考","date":"2018-04-16T14:17:54.000Z","path":"2018/04/A_little_thinking/","text":"时间总是不等人的，转眼大一快过完了，看着现在的窘境，回首过去，难免有一点伤感，如果那些时候换些选择，现在肯定不一样，不过转念一想，每准一切都是最好的安排，在那些时候做的那些选择成就了今天的我，好坏都这样吧，我得直视前方，正所谓，往者不可谏，来者犹可追。","content":"<p>时间总是不等人的，转眼大一快过完了，看着现在的窘境，回首过去，难免有一点伤感，如果那些时候换些选择，现在肯定不一样，不过转念一想，每准一切都是最好的安排，在那些时候做的那些选择成就了今天的我，好坏都这样吧，我得直视前方，正所谓，往者不可谏，来者犹可追。</p>\n","tags":[{"name":"思考","slug":"思考","permalink":"https://jonathan1214.github.io/tags/思考/"}]},{"title":"记录科创中期答辩","date":"2018-04-13T12:10:29.000Z","path":"2018/04/My_first_lose/","text":"今天下午的科创中期答辩我们组当掉了，说实话我们什么都没做，单纯的想敷衍过去，很不幸，老师没有让我们通过，4月29号要再来一次，希望可以通过吧。关于这次答辩，我还是有些东西想记下来的： 我们都有自己擅长的事，当然也有自己的绝不擅长甚至不愿触碰的事儿，很不幸，上台发言就是我不愿触碰的事儿，我害怕自己讲不清楚，害怕自己口齿不清，害怕失败，这或许是这次失败的一个重要原因吧。我们应该考虑下次答辩换一个人的，换一个会说的人，再有就是大二科创一定要好好选队友，海鹏非常可以，有拼劲儿，天行表达非常好，到时候再说，我只是一个中规中矩的驱动人物罢了，现在需要多学一点知识，也好让人家接受你成为队友。 我算是认识到了，要想做好一件事情，一个好的态度是非常是非常重要的。对应到这次科创，这态度体现在，如下几个方面，我们有没有好好做这个项目或者说有没有做，有没有认真准备PPT，有没有认真准备报告。总结起来就是既要好好做也要好好说，anyway，这一次已经过去了，我们要把剩下的路走完。 合理安排自己的时间，不要再浪费了，有许多美好值得去追求，有很多有意义的事儿可以去做，不要再浪费时间做一些没有意义的如玩手机的事儿了。 最后，不要再赶ddl，一定要提前做好。","content":"<p>今天下午的科创中期答辩我们组当掉了，说实话我们什么都没做，单纯的想敷衍过去，很不幸，老师没有让我们通过，4月29号要再来一次，希望可以通过吧。<br><a id=\"more\"></a><br>关于这次答辩，我还是有些东西想记下来的：</p>\n<p>我们都有自己擅长的事，当然也有自己的绝不擅长甚至不愿触碰的事儿，很不幸，上台发言就是我不愿触碰的事儿，我害怕自己讲不清楚，害怕自己口齿不清，害怕失败，这或许是这次失败的一个重要原因吧。我们应该考虑下次答辩换一个人的，换一个会说的人，再有就是大二科创一定要好好选队友，海鹏非常可以，有拼劲儿，天行表达非常好，到时候再说，我只是一个中规中矩的驱动人物罢了，现在需要多学一点知识，也好让人家接受你成为队友。</p>\n<p>我算是认识到了，要想做好一件事情，一个好的态度是非常是非常重要的。对应到这次科创，这态度体现在，如下几个方面，我们有没有好好做这个项目或者说有没有做，有没有认真准备PPT，有没有认真准备报告。总结起来就是既要好好做也要好好说，anyway，这一次已经过去了，我们要把剩下的路走完。</p>\n<p>合理安排自己的时间，不要再浪费了，有许多美好值得去追求，有很多有意义的事儿可以去做，不要再浪费时间做一些没有意义的如玩手机的事儿了。</p>\n<p>最后，不要再赶ddl，一定要提前做好。</p>\n","tags":[{"name":"记录","slug":"记录","permalink":"https://jonathan1214.github.io/tags/记录/"}]}]