[{"title":"second-week","date":"2020-03-22T13:39:06.000Z","path":"2020/03/22/second-week/","text":"没想到有和上周一样，在周一写下上周的日常。不过这次我有话说，不是因为贪玩游戏，实在是因为周六晚上的突发事件打乱了周日的计划，不得已在半夜在农村道路上走上7里路，第二天已经没有精力去写这玩意儿了。翻看上周每天写下的只言片语，我发现若是只给我自己看，那还是有点东西可写的。 无法抵挡的快乐放纵在放纵当时带来的快乐无与伦比，让我无法阻挡，虽然我已经很少体验到放纵的快乐，但我深知它的吸引力是多么强大。放纵对我而言是个什么样的标准呢？一天打上三把游戏已经是放纵了，大概就是这样，那么我可以说周四我放纵了一次。我处于一种完全沉浸式投入的状态，不在乎自己眼睛的疲劳，全心投入，决心赢下当前的比赛，但我还想赢得更多，于是不断地玩下去。最终局数来到了4，花去了2h，我停了下来，没有继续玩下去。因为心心念念着学习知识，我停了下来，放弃了快乐。但是我知道，下一次我还是会沉浸其中，因为它能让我短暂地逃离现实，这是无法抵挡的快乐。 一个平庸的人几乎每天都要上课，老师讲得那些我从来没有听过的知识，但没有多大程度引起我的兴趣，对我而言学习它只是身为学生的一种职责。我被动地接受他们传递过来的东西，OSI参考模型、TCP/IP参考模型、ALOHA随机接入协议还有光纤的若干性质，我几乎没有记下什么东西，但是我尝试去发现其中的规则，那是一种很美的东西，我尝试像一个『一无所知』的人，面对这些问题我能给出什么样的解决方案，大部分时候我什么也发现不了，对于这些问题我也一筹莫展，更别提解决方案，我不过是个平庸的人。 教育使我成为什么样的人？通常我不会想这样的问题，因为只不过是活着而以，不需要赋予人生意义，成为一个什么样的人也许真的无关紧要。周六看了郑强教授的一个视频，让我想考虑下这个问题，但我知道我想不明白的，我只能回顾自己的人生，并尝试从一些事件归纳出自己被教育成一个什么样的人，具体内容慢慢写吧。 我是随机漫步的傻瓜我是个随机漫步的的傻瓜，但是我并没有受到眷顾，所以我还是个彻底的傻瓜。","content":"<p>没想到有和上周一样，在周一写下上周的日常。不过这次我有话说，不是因为贪玩游戏，实在是因为周六晚上的突发事件打乱了周日的计划，不得已在半夜在农村道路上走上7里路，第二天已经没有精力去写这玩意儿了。翻看上周每天写下的只言片语，我发现若是只给我自己看，那还是有点东西可写的。<br><a id=\"more\"></a></p>\n<h2 id=\"无法抵挡的快乐\"><a href=\"#无法抵挡的快乐\" class=\"headerlink\" title=\"无法抵挡的快乐\"></a>无法抵挡的快乐</h2><p>放纵在放纵当时带来的快乐无与伦比，让我无法阻挡，虽然我已经很少体验到放纵的快乐，但我深知它的吸引力是多么强大。放纵对我而言是个什么样的标准呢？一天打上三把游戏已经是放纵了，大概就是这样，那么我可以说周四我放纵了一次。我处于一种完全沉浸式投入的状态，不在乎自己眼睛的疲劳，全心投入，决心赢下当前的比赛，但我还想赢得更多，于是不断地玩下去。最终局数来到了4，花去了2h<br>，我停了下来，没有继续玩下去。因为心心念念着学习知识，我停了下来，放弃了快乐。但是我知道，下一次我还是会沉浸其中，因为它能让我短暂地逃离现实，这是无法抵挡的快乐。</p>\n<h2 id=\"一个平庸的人\"><a href=\"#一个平庸的人\" class=\"headerlink\" title=\"一个平庸的人\"></a>一个平庸的人</h2><p>几乎每天都要上课，老师讲得那些我从来没有听过的知识，但没有多大程度引起我的兴趣，对我而言学习它只是身为学生的一种职责。我被动地接受他们传递过来的东西，OSI参考模型、TCP/IP参考模型、ALOHA随机接入协议还有光纤的若干性质，我几乎没有记下什么东西，但是我尝试去发现其中的规则，那是一种很美的东西，我尝试像一个『一无所知』的人，面对这些问题我能给出什么样的解决方案，大部分时候我什么也发现不了，对于这些问题我也一筹莫展，更别提解决方案，我不过是个平庸的人。</p>\n<h2 id=\"教育使我成为什么样的人？\"><a href=\"#教育使我成为什么样的人？\" class=\"headerlink\" title=\"教育使我成为什么样的人？\"></a>教育使我成为什么样的人？</h2><p>通常我不会想这样的问题，因为只不过是活着而以，不需要赋予人生意义，成为一个什么样的人也许真的无关紧要。周六看了郑强教授的一个视频，让我想考虑下这个问题，但我知道我想不明白的，我只能回顾自己的人生，并尝试从一些事件归纳出自己被教育成一个什么样的人，具体内容慢慢写吧。</p>\n<h2 id=\"我是随机漫步的傻瓜\"><a href=\"#我是随机漫步的傻瓜\" class=\"headerlink\" title=\"我是随机漫步的傻瓜\"></a>我是随机漫步的傻瓜</h2><p>我是个随机漫步的的傻瓜，但是我并没有受到眷顾，所以我还是个彻底的傻瓜。</p>\n","tags":[{"name":"记录","slug":"记录","permalink":"https://jonathan1214.github.io/tags/记录/"},{"name":"weekly","slug":"weekly","permalink":"https://jonathan1214.github.io/tags/weekly/"}]},{"title":"信道共享技术简述与ALOHA的仿真","date":"2020-03-21T08:04:28.000Z","path":"2020/03/21/channel-sharing-and-aloha-imulation/","text":"MAC（Media Access Control）协议，即介质访问控制协议。MAC层需要实现数据帧的封装卸装、帧寻址和识别、帧的接受和发送、链路的管理、帧的差错控制等。屏蔽了不同物理链路的种类差异性。其核心是对有限物理资源的高效利用。在Ad Hoc网络中，由于其无中心和使用无线信道等特点，对MAC协议的要求更高，需要解决的新带来的问题有：选择什么样的信道共享方式，如何处理终端暴露问题，如何隐藏终端，以及如何处理节点移动带来的影响。本文将探讨简单的信道共享技术，并对动态接入协议ALOHA进行分析。 信道共享技术分类信道共享技术又称为多点接入技术，原理是通过一个专用信道将所有的用户连接起来。按照多个用户与一个主机连接的访问方法来划分，信道共享技术可以分为通过集中器或复用器相连和直接相连，前者即信道复用，后者又可分为受控接入和随机接入。 信道复用 受控接入 随机接入 信道复用这是一种应用的比较成熟的技术，集中器或复用器按顺序不断扫描各个端口，或采用中断技术来接受用户信息或转发。如FDM，TDM，CDM，WDM和STDM。考虑一个实际例子：两个用户A和B，都需要需要发送信息；如果采用FDM方式，则分别为A和B分配一条不同频率的信道，然后一起发送；如果采用TDM方式，则A和B分时发送，可以使用相同频率的信道。这可以通过集中器扫描，也可以通过用户发送请求产生中断来执行。其实这就是一种静态的信道分配，按频率、时间或码字对信道进行划分。显然，这会造成资源的浪费。 受控接入受控接入方式的网络拓扑是环型结构，分为集中式控制和分散式控制。集中式控制使用轮询方法，主机按顺序逐个询问各站是否有数据需要发送。分散式控制即使用令牌，在环路中有一个特殊的帧——『令牌』，沿着环路传递，只有获得了令牌的站才有权发送信息。 随机接入随机接入方式的网络拓扑是总线型结构，所有的站点可随时发送数据，争用信道，容易产生冲突，经典的协议有ALOHA，CSMA和CSMA/CD。 信道的静态和动态分配信道的静态分配即将信道资源N等分，这个资源包括时隙（slot）、频谱（frequency）和码字（code），适用于用户数量少、数据量大的情况。问题在于这种信道的分配方式不合理，它不能满足用户对资源占用的不同需求，效率低，不合适多站点，不适于突发性数据。 信道的动态分配使用多路访问协议动态分配信道资源提高信道利用率。可以这么理解：不对信道资源进行划分，用户产生了需求就进行处理，处理时占用全部的信道资源。这么做不可避免的会产生信道争用和冲突问题，可以牺牲一点自由，使用受控接入方式可以隐藏争用问题和解决冲突问题。或者可以直面信道争用和冲突，使用随机接入方式，其中一个重要的协议就是ALOHA。 从一个更高的角度上来看，信道复用技术是一种信道的静态分配技术，受控接入和随机接入是一种信道的动态分配技术。 ALOHA前文讲到，ALOHA协议是一种信道的动态分配协议，它是一种信道共享方式的随机接入技术。在这种动态分配的方式下，信道有三种状态，传输，空闲和竞争，且所有的站点都通过同一信道发送或接受帧，某一特定时刻只允许一个站点使用信道。 以一个数据帧A的发送为例，考虑其如何才能成功发送。发送时机有两种选择，连续时间或时间片，前者允许在任意时刻发送，后者将时间用时钟分离为片段，帧只允许在每一个片段开始瞬间发生。若是以连续时间发送，帧发送时，若信道是空闲状态，则成功开始发送帧，此时信道为传输状态，假设在帧发送时间内又有数据帧B的发送请求产生，则信道进入竞争状态，产生了冲突，帧A发送失败，帧B也发送失败，都需要重传，二者分别随机等待一段时间，然后进行发送，直到发送成功。 ALOHA帧传输示意图我们把以连续时间发送的称为纯ALOHA（pure ALOHA），按时间片发送到称为时隙ALOHA（slotted ALOHA），下面对它们的信道利用率进行分析。 pure ALOHA 信道利用率分析 纯ALOHA的信道吞吐率与网络负载的关系 slotted ALOHA 信道利用率分析 时隙ALOHA的信道吞吐率与网络负载的关系","content":"<p>MAC（Media Access Control）协议，即介质访问控制协议。MAC层需要实现数据帧的封装卸装、帧寻址和识别、帧的接受和发送、链路的管理、帧的差错控制等。屏蔽了不同物理链路的种类差异性。其核心是<strong>对有限物理资源的高效利用</strong>。在Ad Hoc网络中，由于其无中心和使用无线信道等特点，对MAC协议的要求更高，需要解决的新带来的问题有：选择什么样的信道共享方式，如何处理终端暴露问题，如何隐藏终端，以及如何处理节点移动带来的影响。本文将探讨简单的信道共享技术，并对动态接入协议<code>ALOHA</code>进行分析。<br><a id=\"more\"></a></p>\n<h2 id=\"信道共享技术分类\"><a href=\"#信道共享技术分类\" class=\"headerlink\" title=\"信道共享技术分类\"></a>信道共享技术分类</h2><p>信道共享技术又称为多点接入技术，原理是通过一个专用信道将所有的用户连接起来。按照多个用户与一个主机连接的访问方法来划分，信道共享技术可以分为通过集中器或复用器相连和直接相连，前者即信道复用，后者又可分为受控接入和随机接入。</p>\n<ul>\n<li><a href=\"#信道复用\">信道复用</a></li>\n<li><a href=\"#受控接入\">受控接入</a></li>\n<li><a href=\"#随机接入\">随机接入</a></li>\n</ul>\n<h3 id=\"信道复用\"><a href=\"#信道复用\" class=\"headerlink\" title=\"信道复用\"></a>信道复用</h3><p>这是一种应用的比较成熟的技术，集中器或复用器按顺序不断扫描各个端口，或采用中断技术来接受用户信息或转发。如<code>FDM</code>，<code>TDM</code>，<code>CDM</code>，<code>WDM</code>和<code>STDM</code>。<br>考虑一个实际例子：两个用户A和B，都需要需要发送信息；如果采用FDM方式，则分别为A和B分配一条不同频率的信道，然后一起发送；如果采用TDM方式，则A和B分时发送，可以使用相同频率的信道。这可以通过集中器扫描，也可以通过用户发送请求产生中断来执行。<br>其实这就是一种静态的信道分配，按频率、时间或码字对信道进行划分。显然，这会造成资源的浪费。</p>\n<h3 id=\"受控接入\"><a href=\"#受控接入\" class=\"headerlink\" title=\"受控接入\"></a>受控接入</h3><p>受控接入方式的网络拓扑是环型结构，分为集中式控制和分散式控制。集中式控制使用轮询方法，主机按顺序逐个询问各站是否有数据需要发送。分散式控制即使用令牌，在环路中有一个特殊的帧——『令牌』，沿着环路传递，只有获得了令牌的站才有权发送信息。</p>\n<h3 id=\"随机接入\"><a href=\"#随机接入\" class=\"headerlink\" title=\"随机接入\"></a>随机接入</h3><p>随机接入方式的网络拓扑是总线型结构，所有的站点可随时发送数据，争用信道，容易产生冲突，经典的协议有ALOHA，CSMA和CSMA/CD。</p>\n<h3 id=\"信道的静态和动态分配\"><a href=\"#信道的静态和动态分配\" class=\"headerlink\" title=\"信道的静态和动态分配\"></a>信道的静态和动态分配</h3><p>信道的静态分配即将信道资源N等分，这个资源包括时隙（slot）、频谱（frequency）和码字（code），适用于用户数量少、数据量大的情况。问题在于这种信道的分配方式不合理，它不能满足用户对资源占用的不同需求，效率低，不合适多站点，不适于突发性数据。</p>\n<p>信道的动态分配使用多路访问协议动态分配信道资源提高信道利用率。可以这么理解：不对信道资源进行划分，用户产生了需求就进行处理，处理时占用全部的信道资源。这么做不可避免的会产生信道争用和冲突问题，可以牺牲一点自由，使用受控接入方式可以隐藏争用问题和解决冲突问题。或者可以直面信道争用和冲突，使用随机接入方式，其中一个重要的协议就是ALOHA。</p>\n<p>从一个更高的角度上来看，信道复用技术是一种信道的静态分配技术，受控接入和随机接入是一种信道的动态分配技术。</p>\n<h2 id=\"ALOHA\"><a href=\"#ALOHA\" class=\"headerlink\" title=\"ALOHA\"></a>ALOHA</h2><p>前文讲到，ALOHA协议是一种信道的动态分配协议，它是一种信道共享方式的随机接入技术。在这种动态分配的方式下，信道有三种状态，<code>传输</code>，<code>空闲</code>和<code>竞争</code>，且所有的站点都通过同一信道发送或接受帧，某一特定时刻只允许一个站点使用信道。</p>\n<p>以一个数据帧A的发送为例，考虑其如何才能成功发送。发送时机有两种选择，连续时间或时间片，前者允许在任意时刻发送，后者将时间用时钟分离为片段，帧只允许在每一个片段开始瞬间发生。若是以连续时间发送，帧发送时，若信道是空闲状态，则成功开始发送帧，此时信道为传输状态，假设在帧发送时间内又有数据帧B的发送请求产生，则信道进入竞争状态，产生了<em>冲突</em>，帧A发送失败，帧B也发送失败，都需要重传，二者分别随机等待一段时间，然后进行发送，直到发送成功。</p>\n<p><div align=\"center\" class=\"img\"><br>    <img src=\"/assets/img/2020/aloha_principle_illustration.png\" alt=\"aloha_principle_illustration\" width=\"750\"><br>    <span align=\"center\" style=\"color:#999\">ALOHA帧传输示意图</span><br></div><br>我们把以连续时间发送的称为纯ALOHA（pure ALOHA），按时间片发送到称为时隙ALOHA（slotted ALOHA），下面对它们的信道利用率进行分析。</p>\n<h3 id=\"pure-ALOHA-信道利用率分析\"><a href=\"#pure-ALOHA-信道利用率分析\" class=\"headerlink\" title=\"pure ALOHA 信道利用率分析\"></a>pure ALOHA 信道利用率分析</h3><p align=\"center\" class=\"img\"><br><img src=\"/assets/img/2020/pure_aloha.jpg\" alt=\"pure_aloha\" width=\"750\"><br>    <span align=\"center\" style=\"color:#999\">纯ALOHA的信道吞吐率与网络负载的关系</span><br></p>\n\n<h3 id=\"slotted-ALOHA-信道利用率分析\"><a href=\"#slotted-ALOHA-信道利用率分析\" class=\"headerlink\" title=\"slotted ALOHA 信道利用率分析\"></a>slotted ALOHA 信道利用率分析</h3><p align=\"center\" class=\"img\"><br>    <img src=\"/assets/img/2020/slotted_aloha.jpg\" alt=\"slotted_aloha\" width=\"750\"><br>    <span align=\"center\" style=\"color:#999\">时隙ALOHA的信道吞吐率与网络负载的关系</span><br></p>\n","tags":[{"name":"网络","slug":"网络","permalink":"https://jonathan1214.github.io/tags/网络/"},{"name":"MAC协议","slug":"MAC协议","permalink":"https://jonathan1214.github.io/tags/MAC协议/"},{"name":"MATLAB","slug":"MATLAB","permalink":"https://jonathan1214.github.io/tags/MATLAB/"}]},{"title":"新学期的第一周","date":"2020-03-15T12:15:57.000Z","path":"2020/03/15/first-week-record-of-new-term/","text":"震惊的Joey 不知不觉间大三已经过完一半，想起在过去的两年半中好像没有值得纪念的事，有点无可奈何，但要说没有发生那么一件在当时让我很有感触的事，当然也不可能，只是我以为自己的记忆会帮我保存那些真正重要的感觉，因此没有记录，但是这样的事怎么会有那么多呢？亲人故去、终有所成之类的记忆深刻的事不常发生，更多的是生活中有感触的小事，它们发生很触动我，但它们又是那么不起眼，不久后我就会忘记。过去的都过去了，不过现在我不想就让现在的它们被遗忘，我要尽可能地记录。 新学期的第一周也就这么过去了，或者说新学期的第三周就这么过去了，因为疫情耽搁在家没法返校，导致前两周的电工实习没法线下上也没法在线上操作，因此前两周没课，所以这一周才算是我的新学期第一周，没有开始上课怎么能叫新学期呢？不管怎么算，这一周的的确确就这么过去了。 新学期的前三门课过去的一周里，我上了三门课：《计算机通信网络》、《无线自组织网络与应用》和《光通信网络》。每科两节课，一共是六节课。三位老师都很有意思，有说自己从教一纪不知点名为何物的，有网课平台整三四个的，课下还提醒你『你啥时候进的直播啥时候出去我这都有记录，那些进来签个到就走了的同学自己注意点』，也有正常上课群里发『1』签到的。抛开这些不说，老师们课上得挺好。 atimelogger 记录每一分钟周一晚上突然翻到这个自己两年前就下载过的APP————atimelogger，这是一个记录自己每一分钟用在何处的APP，我决定不再试一把，尝试记录自己每一分钟用在何处。从周二开始，这一周每一天我都几乎记录下了自己的每一分钟，这种感觉很奇妙，当你做什么的时候，你会意识到有一个时钟在走，你会不由自主地集中注意力，想要它走慢一点或者抓紧利用这有限的时间。后面我想，不管它在不在，我的生命时钟都在不停地走，不知道在某一天就会停下来，因为它是如此的不可感知，我很少注意到它，但是这个APP帮助我意识到了，它具象了我的生命时钟，让我感受到我的时间在不断消耗，我必须抓紧每一分钟。atimelogger上的记录显示：我每天都花了30~40分钟玩2K19；每天晚上我都会看一集『老友记』，用时22分钟；每天都会记单词，用时20~30分钟；每天我都至少在『微信读书』APP上看了1h书；每天我都至少在床上睡了8个小时；每天我都至少在学习成长上花了6h。我开始喜欢上这种记录的感觉。 重启 Blog周四晚上折腾了一晚，重启Blog，后面几天也在不断完善，终于到了现在这个样子。换了站点的头像，给站点添加了访问人数统计，为每一篇博文添加阅读数统计，在此感谢不蒜子大佬的脚本。周六晚上还添加了相册，到周日晚上，终于可以正常使用了。关于重启博客我是这样想的，上个月我就重启了『记录计划』，只是在手机上写，既然都要记录，为什么不放到网上呢？这样还方便查看，而且我会更有动力去写，Blog是一个比较好的选择。 话不多说，以上就是这一周，关于上的这些课的具体内容我会在后面的文章中详细记录。这些网络类的课很有意思，它们有一种规则的美感，我想如果能自己亲手制定某些规则并加以实现肯定让人兴奋。生活总是有很多的不确定，但我确定关于『记录』这件事我会坚持下去。","content":"<p></p><p align=\"center\" class=\"img\"><br>    <img src=\"/assets/img/2020/astonished_joey.jpg\" alt=\"astonished_joey\" width=\"750\"><br>    <span align=\"center\" style=\"color:#999\">震惊的Joey</span></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><p></p></h2><p>不知不觉间大三已经过完一半，想起在过去的两年半中好像没有值得纪念的事，有点无可奈何，但要说没有发生那么一件在当时让我很有感触的事，当然也不可能，只是我以为自己的记忆会帮我保存那些真正重要的感觉，因此没有记录，但是这样的事怎么会有那么多呢？亲人故去、终有所成之类的记忆深刻的事不常发生，更多的是生活中有感触的小事，它们发生很触动我，但它们又是那么不起眼，不久后我就会忘记。过去的都过去了，不过现在我不想就让现在的它们被遗忘，我要尽可能地记录。<br><a id=\"more\"></a></p>\n<p>新学期的第一周也就这么过去了，或者说新学期的第三周就这么过去了，因为疫情耽搁在家没法返校，导致前两周的电工实习没法线下上也没法在线上操作，因此前两周没课，所以这一周才算是我的新学期第一周，没有开始上课怎么能叫新学期呢？不管怎么算，这一周的的确确就这么过去了。</p>\n<h2 id=\"新学期的前三门课\"><a href=\"#新学期的前三门课\" class=\"headerlink\" title=\"新学期的前三门课\"></a>新学期的前三门课</h2><p>过去的一周里，我上了三门课：《计算机通信网络》、《无线自组织网络与应用》和《光通信网络》。每科两节课，一共是六节课。三位老师都很有意思，有说自己从教一纪不知点名为何物的，有网课平台整三四个的，课下还提醒你『你啥时候进的直播啥时候出去我这都有记录，那些进来签个到就走了的同学自己注意点』，也有正常上课群里发『1』签到的。抛开这些不说，老师们课上得挺好。</p>\n<h2 id=\"atimelogger-记录每一分钟\"><a href=\"#atimelogger-记录每一分钟\" class=\"headerlink\" title=\"atimelogger 记录每一分钟\"></a>atimelogger 记录每一分钟</h2><p>周一晚上突然翻到这个自己两年前就下载过的APP————atimelogger，这是一个记录自己每一分钟用在何处的APP，我决定不再试一把，尝试记录自己每一分钟用在何处。从周二开始，这一周每一天我都几乎记录下了自己的每一分钟，这种感觉很奇妙，当你做什么的时候，你会意识到有一个时钟在走，你会不由自主地集中注意力，想要它走慢一点或者抓紧利用这有限的时间。后面我想，不管它在不在，我的生命时钟都在不停地走，不知道在某一天就会停下来，因为它是如此的不可感知，我很少注意到它，但是这个APP帮助我意识到了，它具象了我的生命时钟，让我感受到我的时间在不断消耗，我必须抓紧每一分钟。<br>atimelogger上的记录显示：我每天都花了30~40分钟玩2K19；每天晚上我都会看一集『老友记』，用时22分钟；每天都会记单词，用时20~30分钟；每天我都至少在『微信读书』APP上看了1h书；每天我都至少在床上睡了8个小时；每天我都至少在学习成长上花了6h。我开始喜欢上这种记录的感觉。</p>\n<h2 id=\"重启-Blog\"><a href=\"#重启-Blog\" class=\"headerlink\" title=\"重启 Blog\"></a>重启 Blog</h2><p>周四晚上折腾了一晚，重启Blog，后面几天也在不断完善，终于到了现在这个样子。换了站点的头像，给站点添加了访问人数统计，为每一篇博文添加阅读数统计，在此感谢不蒜子大佬的脚本。周六晚上还添加了<code>相册</code>，到周日晚上，终于可以正常使用了。关于重启博客我是这样想的，上个月我就重启了『记录计划』，只是在手机上写，既然都要记录，为什么不放到网上呢？这样还方便查看，而且我会更有动力去写，Blog是一个比较好的选择。</p>\n<hr>\n<p>话不多说，以上就是这一周，关于上的这些课的具体内容我会在后面的文章中详细记录。这些网络类的课很有意思，它们有一种规则的美感，我想如果能自己亲手制定某些规则并加以实现肯定让人兴奋。生活总是有很多的不确定，但我确定关于『记录』这件事我会坚持下去。</p>\n","tags":[{"name":"记录","slug":"记录","permalink":"https://jonathan1214.github.io/tags/记录/"},{"name":"weekly","slug":"weekly","permalink":"https://jonathan1214.github.io/tags/weekly/"}]},{"title":"union-find算法的原理及实现","date":"2020-03-13T07:26:53.000Z","path":"2020/03/13/union-find/","text":"在计算机网络中，对于任意两个节点，可以在其间构建一条连接建立通信，这样做没有问题，但是在整个网络中都这么做会导致需要建立的连接非常多，容易计算得到N个节点的网络需要的连接数N(N-1)/2，这增加了网络的负担，实现起来也不容易，有什么办法改进呢？六度空间理论大家都知道，说的是最多通过六个人，我们可以和世界上任何人建立联系，那么如何知道两个人之间是否可以建立联系呢？这两个问题其实都属于连通性问题，可以使用union-find算法解决，步骤如下： 1. 数据准备p和q表示两个抽象的节点，可以用整数表示，如果『p，q 是相连的』，则意味着： 自反性：p和p是相连的。 对称性：如果p和q相连，则q和p也是相连的。 传递性：如果p和q相连，q和r相连，则p和r也相连。 我们可以用一个数组表示所有的节点，数组的每个位置表示一个节点，每个位置的值表示这个节点所在分量的标识符，初始化的时候每个节点的标识符都是其本身，如下所示： 12345void UF(int N) &#123; a = new int[N]; // 初始化节点数组 for (int i = 0; i &lt; N; i++) a[i] = i;&#125; 2. 实现quick-find在union-find算法中，有两个目标需要实现：判断两个节点是否连通和连接两个节点的。一种简单的思路是这样的，规定同属一个连通分量的标识符相同，比如：节点0，1和2是连通的，我们选择1为标识符，那么a[0]=a[1]=a[2]=1。这样做判断两个节点是否连通就可以在常数时间完成，基于此规则我们可以实现quick-find算法，但是这样做union的成本就会上升，每次union，需要遍历所有的节点，并对合适节点的标识符进行改变，这是个平方级别的算法，如下所示。 123456789101112boolean isConnected(int p, int q) &#123; return find(p)==find(q);&#125;int find(int p) &#123; return a[p]; &#125;void union(int p, int q) &#123; int pp = find(p); // p 节点的标识符 int qq = find(q); // q 节点的标识符 if (pp == qq) return; // 将 pp 标识符全部改成 qq for (int i = 0; i &lt; a.length; i++) if (a[i] == pp) a[i] = qq;&#125; quick-unionquick-find算法中，union的成本是平方级别的，其原因在于每次union需要遍历全部的节点，可以进行一些调整，得到改进，这就是quick-union算法。具体实现：在同一类别的中的节点，我们不再让所有节点保存相同的标识符，而是在节点中保持其父节点，类似一棵树，不过是向上走的，子节点指向父节点，根节点保存的是他自己，这样一来，进行union操作时，至于遍历找到根节点，然后让其中一个根节点指向另一个根节点即可，进行find操作时，只需遍历找到根节点即指向自身的节点。 12345678910int find(int p) &#123; while (a[p] != p) p = a[p]; return p;&#125;void union(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); // pRoot 节点指向 Qroot a[pRoot] = qRoot;&#125; 加权 quick-union这样做没什么问题，但是在最坏情况下，节点是依次相连的，串成一串，这会导致算法的性能下降，我们对其稍加改进，每次union时，都把节点数小的那一组连接到节点数大的那一组，这就是加权的quick-union算法。实现这个算法我们需要一个数组保存每个节点下节点的数目，对根节点而言，这个数就是它所在组的大小。 123456789101112131415161718192021UF(int N) &#123; a = new int[N]; // 初始化节点数组 sz = new int[N]; // 保存节点数目 for (int i = 0; i &lt; N; i++) a[i] = i; for (int i = 0; i &lt; N; i++) sz[i] = 1;&#125;// find 算法没有改变void union(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) return; if (sz[pRoot] &gt; sz[qRoot]) &#123; // p 所在组较大 a[qRoot] = pRoot; // 将q连接到q上 sz[pRoot] += sz[qRoot]; // 更新 pRoot 下的节点数 &#125; else &#123; // q 所在组较大 a[pRoot] = qRoot; sz[qRoot] += sz[pRoot]; &#125;&#125; 路径压缩还有一种路径压缩算法可以改进quick-union，即每次查找时，都把途径的节点指向根节点，这样均摊下来的find成本比较小，可以证明，路径压缩的加权quick-union算法是实现union-find最快的算法。 12345678910int find(int p) &#123; int x = p, t; while (a[p] != p) p = a[p]; // 找到根节点 while (x != p) &#123; // 直到到达根节点 t = a[x]; // 保存当前节点的父节点 a[x] = p; // 当前节点直接连接到根节点 x = t; // 移动到当前节点的父节点 &#125;&#125;// union 算法不变 回到开头的那两个问题，有了union-find算法，我们来尝试解决它们。对于网络中节点是否需要构建新的连接，抽象出网络的节点构建起UF后，执行isConnected()即可判断是否需要建立新的连接，对于两个人是否可以建立连接的问题，我们用同样的方法也可以解决，但要是想通过最少的中间人就认识一个人，该怎么做呢，这又是另外一个问题了。","content":"<p>在计算机网络中，对于任意两个节点，可以在其间构建一条连接建立通信，这样做没有问题，但是在整个网络中都这么做会导致需要建立的连接非常多，容易计算得到<code>N</code>个节点的网络需要的连接数<code>N(N-1)/2</code>，这增加了网络的负担，实现起来也不容易，有什么办法改进呢？六度空间理论大家都知道，说的是最多通过六个人，我们可以和世界上任何人建立联系，那么如何知道两个人之间是否可以建立联系呢？这两个问题其实都属于连通性问题，可以使用<code>union-find</code>算法解决，步骤如下：</p>\n<h2 id=\"1-数据准备\"><a href=\"#1-数据准备\" class=\"headerlink\" title=\"1. 数据准备\"></a>1. 数据准备</h2><p><code>p</code>和<code>q</code>表示两个抽象的节点，可以用整数表示，如果『p，q 是相连的』，则意味着：</p>\n<ul>\n<li>自反性：<code>p</code>和<code>p</code>是相连的。</li>\n<li>对称性：如果<code>p</code>和<code>q</code>相连，则<code>q</code>和<code>p</code>也是相连的。</li>\n<li>传递性：如果<code>p</code>和<code>q</code>相连，<code>q</code>和<code>r</code>相连，则<code>p</code>和<code>r</code>也相连。</li>\n</ul>\n<p>我们可以用一个数组表示所有的节点，数组的每个位置表示一个节点，每个位置的值表示这个节点所在分量的标识符，初始化的时候每个节点的标识符都是其本身，如下所示：<br><a id=\"more\"></a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">UF</span><span class=\"params\">(<span class=\"keyword\">int</span> N)</span> </span>&#123;</span><br><span class=\"line\">    a = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[N]; <span class=\"comment\">// 初始化节点数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++)</span><br><span class=\"line\">        a[i] = i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-实现\"><a href=\"#2-实现\" class=\"headerlink\" title=\"2. 实现\"></a>2. 实现</h2><h3 id=\"quick-find\"><a href=\"#quick-find\" class=\"headerlink\" title=\"quick-find\"></a>quick-find</h3><p>在<code>union-find</code>算法中，有两个目标需要实现：判断两个节点是否连通和连接两个节点的。一种简单的思路是这样的，规定同属一个连通分量的标识符相同，比如：节点<code>0</code>，<code>1</code>和<code>2</code>是连通的，我们选择<code>1</code>为标识符，那么<code>a[0]=a[1]=a[2]=1</code>。这样做判断两个节点是否连通就可以在常数时间完成，基于此规则我们可以实现<code>quick-find</code>算法，但是这样做<code>union</code>的成本就会上升，每次<code>union</code>，需要遍历所有的节点，并对合适节点的标识符进行改变，这是个平方级别的算法，如下所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isConnected</span><span class=\"params\">(<span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> q)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> find(p)==find(q);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> p)</span> </span>&#123; <span class=\"keyword\">return</span> a[p]; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">union</span><span class=\"params\">(<span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> q)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pp = find(p);   <span class=\"comment\">// p 节点的标识符</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> qq = find(q);   <span class=\"comment\">// q 节点的标识符</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pp == qq) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 将 pp 标识符全部改成 qq</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; a.length; i++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a[i] == pp) a[i] = qq;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"quick-union\"><a href=\"#quick-union\" class=\"headerlink\" title=\"quick-union\"></a>quick-union</h3><p>quick-find算法中，union的成本是平方级别的，其原因在于每次union需要遍历全部的节点，可以进行一些调整，得到改进，这就是quick-union算法。具体实现：在同一类别的中的节点，我们不再让所有节点保存相同的标识符，而是在节点中保持其父节点，类似一棵树，不过是向上走的，子节点指向父节点，根节点保存的是他自己，这样一来，进行union操作时，至于遍历找到根节点，然后让其中一个根节点指向另一个根节点即可，进行find操作时，只需遍历找到根节点即指向自身的节点。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> p)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (a[p] != p) p = a[p];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">union</span><span class=\"params\">(<span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> q)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pRoot = find(p);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> qRoot = find(q);</span><br><span class=\"line\">    <span class=\"comment\">// pRoot 节点指向 Qroot</span></span><br><span class=\"line\">    a[pRoot] = qRoot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"加权-quick-union\"><a href=\"#加权-quick-union\" class=\"headerlink\" title=\"加权 quick-union\"></a>加权 quick-union</h3><p>这样做没什么问题，但是在最坏情况下，节点是依次相连的，串成一串，这会导致算法的性能下降，我们对其稍加改进，每次union时，都把节点数小的那一组连接到节点数大的那一组，这就是加权的quick-union算法。实现这个算法我们需要一个数组保存每个节点下节点的数目，对根节点而言，这个数就是它所在组的大小。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UF(<span class=\"keyword\">int</span> N) &#123;</span><br><span class=\"line\">    a = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[N];     <span class=\"comment\">// 初始化节点数组</span></span><br><span class=\"line\">    sz = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[N];    <span class=\"comment\">// 保存节点数目</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++)</span><br><span class=\"line\">        a[i] = i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++)</span><br><span class=\"line\">        sz[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// find 算法没有改变</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">union</span><span class=\"params\">(<span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> q)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pRoot = find(p);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> qRoot = find(q);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pRoot == qRoot) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sz[pRoot] &gt; sz[qRoot]) &#123; <span class=\"comment\">// p 所在组较大</span></span><br><span class=\"line\">        a[qRoot] = pRoot; <span class=\"comment\">// 将q连接到q上</span></span><br><span class=\"line\">        sz[pRoot] += sz[qRoot]; <span class=\"comment\">// 更新 pRoot 下的节点数</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;    <span class=\"comment\">// q 所在组较大</span></span><br><span class=\"line\">        a[pRoot] = qRoot;</span><br><span class=\"line\">        sz[qRoot] += sz[pRoot];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"路径压缩\"><a href=\"#路径压缩\" class=\"headerlink\" title=\"路径压缩\"></a>路径压缩</h3><p>还有一种路径压缩算法可以改进quick-union，即每次查找时，都把途径的节点指向根节点，这样均摊下来的find成本比较小，可以证明，路径压缩的加权quick-union算法是实现union-find最快的算法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> p)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x = p, t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (a[p] != p) p = a[p]; <span class=\"comment\">// 找到根节点</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (x != p) &#123; <span class=\"comment\">// 直到到达根节点</span></span><br><span class=\"line\">        t = a[x];   <span class=\"comment\">// 保存当前节点的父节点</span></span><br><span class=\"line\">        a[x] = p;   <span class=\"comment\">// 当前节点直接连接到根节点</span></span><br><span class=\"line\">        x = t;      <span class=\"comment\">// 移动到当前节点的父节点</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// union 算法不变</span></span><br></pre></td></tr></table></figure>\n<hr>\n<p>回到开头的那两个问题，有了union-find算法，我们来尝试解决它们。对于网络中节点是否需要构建新的连接，抽象出网络的节点构建起<code>UF</code>后，执行<code>isConnected()</code>即可判断是否需要建立新的连接，对于两个人是否可以建立连接的问题，我们用同样的方法也可以解决，但要是想通过最少的中间人就认识一个人，该怎么做呢，这又是另外一个问题了。</p>\n","tags":[{"name":"算法","slug":"算法","permalink":"https://jonathan1214.github.io/tags/算法/"},{"name":"Java","slug":"Java","permalink":"https://jonathan1214.github.io/tags/Java/"},{"name":"union-find","slug":"union-find","permalink":"https://jonathan1214.github.io/tags/union-find/"}]},{"title":"算法的分析方法","date":"2020-03-10T13:30:43.000Z","path":"2020/03/10/a-way-to-algorithm-analysis/","text":"也看了几天『算法』了，总是觉得不得要领，在此做一点笔记想必会有所帮助，能够完整地写下来或者清楚地讲述给别人并使之理解才算掌握了知识，这个观点来自费曼，我深以为然。 算法及其重要性算法 被用来描述一种有限的、确定的、有效的并适合计算机程序来实现的解决问题的方法，它是计算机科学的基础，是这个领域研究的核心。『算法』在前言中就如此讲到： 算法和数据结构的学习的学习是所有计算机教学计划的基础。 我想算法的重要性已不言而喻，这也是我在此努力学习的原因，当然我不是计算机系的学生，但我深信一定程度上了解算法和其分析方法对我的专业学习和理解也很有帮助。 使用数据抽象开发可重用的算法虽然我关心的是算法背后的逻辑，但是真正实现起来还是落在代码上，为了保证其可重用性，使用数据抽象，让我们更关注算法的内核，而不是具体的数据。按照下面的步骤解决问题： 定义 API 根据特定的应用场景开发用例代码 描述一种数据结构，并在 API 说对应的抽象数据类型的实现中根据它定义类的实例变量 描述算法 分析算法的性能特点 算法分析诸如『我的算法会运行多久？』和『为什么我的程序耗尽了所有的内存』这样的基础问题，我们使用 科学方法 可以给出实际性的回答，如下所示，同时使用 数学分析 为算法建立模型，还可以使用 实验数据 验证模型。 细致的观察真实世界的特点 根据观察的结果提出假设模型 预测未来事件 继续观测并核实预测的准确性 如此反复直到确认预测和观察一致 进行实际分析之前，首先要确定 输入模型 和 问题的规模，其实就是说 输入数据量的大小 和 数据的特点 对运行时间的影响，显然运行时间会随着规模的增大而变长。 关于数学分析，依据 Knuth 的观点，程序运行的总时间主要与 执行每条语句的耗时 和 执行每条语句的频率有关。对于前者，这由机器决定，我们不关心，而后者由程序和输入决定，这正是我们要分析的。对于语句频率的分析我们会采用近似的方法，这由会得到 增长的数量级 这一概念，当输入规模很大时，这被验证是可行的，而我们正是关注算法处理大规模输入的性能。 增长的数量级概念的应用使我们能够 将程序和它实现的算法隔离开，算法和输入模型决定了增长的数量级。 使用 成本模型 评估算法的性质，该模型定义了算法中的基本操作，如数组的访问次数和元素的交换次数等等。在选定的数学模型下，我们或许可以用精确的数学语言说明算法的性质，这正是我们进行数学分析的目的。 以上我们可以得出分析程序运行时间数学模型的步骤如下： 确定输入模型下，定义问题的规模 识别内循环 根据内循环的操作确定成本模型 对于规定的输入，判断这些操作的执行频率","content":"<p>也看了几天『算法』了，总是觉得不得要领，在此做一点笔记想必会有所帮助，能够完整地写下来或者清楚地讲述给别人并使之理解才算掌握了知识，这个观点来自费曼，我深以为然。<br><!-- 这里应该添加一个目录 --><br><a id=\"more\"></a></p>\n<h2 id=\"算法及其重要性\"><a href=\"#算法及其重要性\" class=\"headerlink\" title=\"算法及其重要性\"></a>算法及其重要性</h2><p><strong>算法</strong> 被用来描述一种有限的、确定的、有效的并适合计算机程序来实现的解决问题的方法，它是计算机科学的基础，是这个领域研究的核心。『算法』在前言中就如此讲到：</p>\n<blockquote>\n<p>算法和数据结构的学习的学习是所有计算机教学计划的基础。</p>\n</blockquote>\n<p>我想算法的重要性已不言而喻，这也是我在此努力学习的原因，当然我不是计算机系的学生，但我深信一定程度上了解算法和其分析方法对我的专业学习和理解也很有帮助。</p>\n<h2 id=\"使用数据抽象开发可重用的算法\"><a href=\"#使用数据抽象开发可重用的算法\" class=\"headerlink\" title=\"使用数据抽象开发可重用的算法\"></a>使用数据抽象开发可重用的算法</h2><p>虽然我关心的是算法背后的逻辑，但是真正实现起来还是落在代码上，为了保证其可重用性，使用数据抽象，让我们更关注算法的内核，而不是具体的数据。按照下面的步骤解决问题：</p>\n<ul>\n<li>定义 API</li>\n<li>根据特定的应用场景开发用例代码</li>\n<li>描述一种数据结构，并在 API 说对应的抽象数据类型的实现中根据它定义类的实例变量</li>\n<li>描述算法</li>\n<li>分析算法的性能特点</li>\n</ul>\n<h2 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h2><p>诸如『我的算法会运行多久？』和『为什么我的程序耗尽了所有的内存』这样的基础问题，我们使用 <em>科学方法</em> 可以给出实际性的回答，如下所示，同时使用 <em>数学分析</em> 为算法建立模型，还可以使用 <em>实验数据</em> 验证模型。</p>\n<ul>\n<li>细致的观察真实世界的特点</li>\n<li>根据观察的结果提出假设模型</li>\n<li>预测未来事件</li>\n<li>继续观测并核实预测的准确性</li>\n<li>如此反复直到确认预测和观察一致</li>\n</ul>\n<p>进行实际分析之前，首先要确定 <strong>输入模型</strong> 和 <strong>问题的规模</strong>，其实就是说 <strong>输入数据量的大小</strong> 和 <strong>数据的特点</strong> 对运行时间的影响，显然运行时间会随着规模的增大而变长。</p>\n<p>关于数学分析，依据 Knuth 的观点，程序运行的总时间主要与 <strong>执行每条语句的耗时</strong> 和 <strong>执行每条语句的频率有关</strong>。对于前者，这由机器决定，我们不关心，而后者由程序和输入决定，这正是我们要分析的。对于语句频率的分析我们会采用近似的方法，这由会得到 <strong>增长的数量级</strong> 这一概念，当输入规模很大时，这被验证是可行的，而我们正是关注算法处理大规模输入的性能。</p>\n<p>增长的数量级概念的应用使我们能够 <strong>将程序和它实现的算法隔离开</strong>，算法和输入模型决定了增长的数量级。</p>\n<p>使用 <strong>成本模型</strong> 评估算法的性质，该模型定义了算法中的基本操作，如数组的访问次数和元素的交换次数等等。在选定的数学模型下，我们或许可以用精确的数学语言说明算法的性质，这正是我们进行数学分析的目的。</p>\n<p>以上我们可以得出分析程序运行时间数学模型的步骤如下：</p>\n<ul>\n<li>确定输入模型下，定义问题的规模</li>\n<li>识别内循环</li>\n<li>根据内循环的操作确定成本模型</li>\n<li>对于规定的输入，判断这些操作的执行频率</li>\n</ul>\n","tags":[{"name":"算法","slug":"算法","permalink":"https://jonathan1214.github.io/tags/算法/"},{"name":"Java","slug":"Java","permalink":"https://jonathan1214.github.io/tags/Java/"}]},{"title":"记录高频硬件课程设计","date":"2019-12-29T01:23:10.000Z","path":"2019/12/29/record-of-high-frequency-course-design/","text":"本文绝大部分内容是在19年12月29日写的，我记得很清楚，那天是周日上午，我没有为即将到来的通原考试而复习，而是选择去写点东西记录几天前刚刚结束的高频课设，这是一次很难忘的经历，有痛苦也有快乐，有想过放弃但还是坚持了下来，感谢自己和队友们。现在是2020年3月15日，本该在学校度过周日的我，和所有的大学生一样，因为肺炎疫情只能在家里学习，我没什么学习状态，有些无聊，因此整理博客，把这篇去年的记录整理整理，发到GitHubBlog上，留作纪念，发表日期还是使用去年写这篇文章的日子。 最终验收12月24号，高频硬件课设验收，在队友的强烈要求下，我们选择了一个比较宽松的老师给我们验收，因为我们功率达不到，但还想 『恰完烂分』，这能对他的保研有所帮助。最后的结果很好，我们拿到了5分（满分5分），『烂分恰完』。 最终验收时电路连接和波形 开始12月17号周二下午考完『随机过程』，终于有时间休息了，躺了一个小时，吃个饭，室友已经去搞硬件了，虽然已经是晚上9点多了，但我还想去，带上东西，去李老师办公室焊。折腾了两个小时，焊好了一个西勒振荡器，但没有测试工具，只能第二天测试焊接是否正确，测试工具缺乏和焊接出错这两个问题在整个课设过程中一直困扰着我们。 第一天晚上焊好的西勒振荡器 一起干第二天是周三，没有课，我和赵公子决定去实验室接着焊板子，顺便测试下昨晚上焊的振荡器。两个小时后，我们焊好了发射机和接收机的振荡器，经过测试，他的能用，而我的那块振荡器产生了寄生调幅。检查了电路没有任何问题，折腾到下午，最后发现是射极偏置电阻过大导致的，微调射极电阻，即可解决这个问题。 下午和晚上我们都在实验室呆着，一直做到晚上11点。因为我已经很久没焊接东西，有点手生，他更是没啥经验，我们效率比较低，只焊好了一个乘法电路、一个中频放大器和一个包络检波器。后面测试时发现，我焊接的那个乘法电路不能实现信号相乘。那时我还不知道，接下来3天我都会把时间花在乘法电路上，如果早知道调试它会这么折腾，第一天晚上就应该当机立断重新焊一个的。 心生退意接下来的几天我感到痛苦不堪，我焊接乘法电路始终不好使，不知为什么我就是不愿重新焊一块，执着地想把它修好，但这一切都是徒劳的。看着周围的同学一个个都做出来乘法电路了，我开始怀疑自己：如果做不出来是不是证明我不行，我怎么能不行呢？要不放弃吧，这样就不存在证明了，我告诉自己这些bonus对我来说并不那么重要，我保研与否与这课设5分没什么关系。沃老板执着地说焊板子的烟搞得他很难受，实验室里面人太多了，空气太差，乌烟瘴气，他想回寝室做，这样的参与状态让我心有不快，偏偏他才是一定要拿这 5 分保研的人，为什么我要受这些精神折磨，我当时的确不想再做下去了。 周六早上，纠结了许久，我去教化补充了些元器件，决定去实验室再焊一个乘法器，还说服沃老板也焊一个接收机的乘法电路。我不知道是什么力量支撑着我继续做下去，这件事对我来说不是那么必要，最诱人的bonus并不是我一定需要的，如果不做课设，我可以去复习通原，我可以享受轻松的一周。事后我仔细想了想，大概是因为我自己的性格决定的，我不是那种遇到问题就放弃的人，借口谁都有一些，但是作为我，一旦开始做了，就要做到最后，没有中途放弃的，之前的软件仿真就是如此，没有理由硬件不坚持下去，到这个时候，其实做这个课设已经变成了和自己较劲了，我不想就这么输了。 周六下午去做了通信原理实验，晚上终于焊好我的第二块乘法电路，测试再次失败，沃老板也焊好接收机混频电路，经过测试也失败。这时候我心态已经到了最低点了，我真的不想再来了，前面说的那么多不服输如何如何，可是看着别人一个个做好，我的却始终不行，旁边还有人明着嘲讽我，这使我明白『挫败感』是何含义。晚上10点，我和沃老板回寝室了，赵公子在周五下午有事回家了，但他做的已经足够多了。我突然决定不再去了。 坚持才是胜利周日上午我还是去实验室了，我想就是什么都做不出来，也得一直在实验室坐着，我就要和它刚到底。好在一切坚持都没有白费，我的乘法电路测试成功了，事实证明我的电路设计没有问题，焊接的也没有问题，昨晚测试失败只是因为电路连线没有接好，胜利让我欣喜若狂，我真想大声怒吼：我终于完成了。另一边也有好消息传来，沃老板焊的和赵公子焊的乘法电路都是好使的，还有什么比此刻更快乐呢？ 赵公子的乘法器AM波形 沃老板的混频器波形 周日下午发生了一些不愉快的事情，因为下午找不到他人（其实他在午睡），我对沃老板的不满更加强烈了，而那时我已经十分疲惫，愤怒之下，下午3点左右我直接回寝室，拒绝回他消息，然后睡了一觉。期间他来找我，我『哈哈』糊弄过去，不想再干。6点多起来看一眼手机，想了想，还是再去试试，把级联和功率要求做完吧，都已经到这个份上了，干脆就把它做到完。 乘胜追击我不想就此打住，野心开始膨胀了，『恰5分』 是调侃，此时更像是口号。发射机 AM 调制输出接上我焊调试乘法器抽空焊好的小信号放大器，效果非常好！放大了80倍，但我心里清楚，因为没有接负载，最后功率肯定达不到；接收机，混频后中频放大再检波，效果很差，但也算检波出来了，在要求不那么严苛的时候，可以拿到分；发射机接收机级联成功，和仿真保持一致。 如此算来，我们已经可以拿到 4.5 分，但是我们不想收手，我们继续调放大器，要把功率的 5 分也拿到手。很不幸，我们没有成功，三极管射极电阻过小，导致射极电流过大，二极管被烧坏了，放大器也就怀了，这又是我们唯一的放大器，级联也没办法做了，这下只有 4 分了，后悔，懊恼。 第二天周一，已经是12月23号了，我都没想到自己会在这上面花上近一周时间。白天上了一天课，晚上我们接着调试了一下，还是那个问题，AM 波后的小信号放大器不好使，级联就不行，功率也没有。赵公子也回来了，我们让他重新焊了一个，失败了，因为我临时对之前测试成功的电路做了修改，为了减小电流避免三极管烧毁的事再发生，但是我没想到这么一改，电流太小，放大倍数达不到要求，而且我应该自己亲手焊的。可以说今天又是一无所获。但我不会就此打住，我不愿放弃。 周二上午上完微波课，我立马去教化买了元件，再焊一个小信号放大器，再试一次，不到最后，谁也不知道结果，我不想放弃。一番折腾，焊好，测试，成功。 下午验收前一刻，上周三买的陶瓷滤波器终于从深圳邮到了学校，我赶紧去取回来，接到电路中，完美!『烂分恰完』。 后记做完这次课设，心里有太多感慨，很多次我都想放弃了，但是总有一股力量把我拉了回来，这其中有对朋友承诺的坚守也有自己那股不服输的劲，验收成功那一刻我有点想哭，是啊，这整个过程只有我自己这么看重吧，最后还在自我感动，但如果没有这自我感动，我不知道自己能否坚持下来。当然，课设整个过程也暴露了我的一些问题：我需要有更强大的精神力量，激励自己前进，也要学会如何带领团队前进。","content":"<p>本文绝大部分内容是在19年12月29日写的，我记得很清楚，那天是周日上午，我没有为即将到来的通原考试而复习，而是选择去写点东西记录几天前刚刚结束的高频课设，这是一次很难忘的经历，有痛苦也有快乐，有想过放弃但还是坚持了下来，感谢自己和队友们。现在是2020年3月15日，本该在学校度过周日的我，和所有的大学生一样，因为肺炎疫情只能在家里学习，我没什么学习状态，有些无聊，因此整理博客，把这篇去年的记录整理整理，发到GitHubBlog上，留作纪念，发表日期还是使用去年写这篇文章的日子。<br><a id=\"more\"></a></p>\n<h2 id=\"最终验收\"><a href=\"#最终验收\" class=\"headerlink\" title=\"最终验收\"></a>最终验收</h2><p>12月24号，高频硬件课设验收，在队友的强烈要求下，我们选择了一个比较宽松的老师给我们验收，因为我们功率达不到，但还想 <strong>『恰完烂分』</strong>，这能对他的保研有所帮助。最后的结果很好，我们拿到了5分（满分5分），<strong>『烂分恰完』</strong>。</p>\n<div align=\"center\" class=\"img\"><br>    <img src=\"/assets/img/2019/final.jpg\" alt=\"验收\" height=\"400\"><br>    <p align=\"center\" style=\"color:#999\">最终验收时电路连接和波形</p><br></div>\n\n<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><p>12月17号周二下午考完『随机过程』，终于有时间休息了，躺了一个小时，吃个饭，室友已经去搞硬件了，虽然已经是晚上9点多了，但我还想去，带上东西，去李老师办公室焊。折腾了两个小时，焊好了一个西勒振荡器，但没有测试工具，只能第二天测试焊接是否正确，测试工具缺乏和焊接出错这两个问题在整个课设过程中一直困扰着我们。</p>\n<div align=\"center\" class=\"img\"><br>    <img src=\"/assets/img/2019/siler_oscillator.jpg\" alt=\"西勒振荡器\" height=\"400\"><br>    <p align=\"center\" style=\"color:#999\">第一天晚上焊好的西勒振荡器</p><br></div>\n\n<h2 id=\"一起干\"><a href=\"#一起干\" class=\"headerlink\" title=\"一起干\"></a>一起干</h2><p>第二天是周三，没有课，我和赵公子决定去实验室接着焊板子，顺便测试下昨晚上焊的振荡器。两个小时后，我们焊好了发射机和接收机的振荡器，经过测试，他的能用，而我的那块振荡器产生了寄生调幅。检查了电路没有任何问题，折腾到下午，最后发现是射极偏置电阻过大导致的，微调射极电阻，即可解决这个问题。</p>\n<p>下午和晚上我们都在实验室呆着，一直做到晚上11点。因为我已经很久没焊接东西，有点手生，他更是没啥经验，我们效率比较低，只焊好了一个乘法电路、一个中频放大器和一个包络检波器。后面测试时发现，我焊接的那个乘法电路不能实现信号相乘。那时我还不知道，接下来3天我都会把时间花在乘法电路上，如果早知道调试它会这么折腾，第一天晚上就应该当机立断重新焊一个的。</p>\n<h2 id=\"心生退意\"><a href=\"#心生退意\" class=\"headerlink\" title=\"心生退意\"></a>心生退意</h2><p>接下来的几天我感到痛苦不堪，我焊接乘法电路始终不好使，不知为什么我就是不愿重新焊一块，执着地想把它修好，但这一切都是徒劳的。看着周围的同学一个个都做出来乘法电路了，我开始怀疑自己：如果做不出来是不是证明我不行，我怎么能不行呢？要不放弃吧，这样就不存在证明了，我告诉自己这些bonus对我来说并不那么重要，我保研与否与这课设5分没什么关系。沃老板执着地说焊板子的烟搞得他很难受，实验室里面人太多了，空气太差，乌烟瘴气，他想回寝室做，这样的参与状态让我心有不快，偏偏他才是一定要拿这 5 分保研的人，为什么我要受这些精神折磨，我当时的确不想再做下去了。</p>\n<p>周六早上，纠结了许久，我去教化补充了些元器件，决定去实验室再焊一个乘法器，还说服沃老板也焊一个接收机的乘法电路。我不知道是什么力量支撑着我继续做下去，这件事对我来说不是那么必要，最诱人的bonus并不是我一定需要的，如果不做课设，我可以去复习通原，我可以享受轻松的一周。事后我仔细想了想，大概是因为我自己的性格决定的，我不是那种遇到问题就放弃的人，借口谁都有一些，但是作为我，一旦开始做了，就要做到最后，没有中途放弃的，之前的软件仿真就是如此，没有理由硬件不坚持下去，到这个时候，其实做这个课设已经变成了和自己较劲了，我不想就这么输了。</p>\n<p>周六下午去做了通信原理实验，晚上终于焊好我的第二块乘法电路，测试再次失败，沃老板也焊好接收机混频电路，经过测试也失败。这时候我心态已经到了最低点了，我真的不想再来了，前面说的那么多不服输如何如何，可是看着别人一个个做好，我的却始终不行，旁边还有人明着嘲讽我，这使我明白『挫败感』是何含义。晚上10点，我和沃老板回寝室了，赵公子在周五下午有事回家了，但他做的已经足够多了。我突然决定不再去了。</p>\n<h2 id=\"坚持才是胜利\"><a href=\"#坚持才是胜利\" class=\"headerlink\" title=\"坚持才是胜利\"></a>坚持才是胜利</h2><p>周日上午我还是去实验室了，我想就是什么都做不出来，也得一直在实验室坐着，我就要和它刚到底。好在一切坚持都没有白费，我的乘法电路测试成功了，事实证明我的电路设计没有问题，焊接的也没有问题，昨晚测试失败只是因为电路连线没有接好，胜利让我欣喜若狂，我真想大声怒吼：我终于完成了。另一边也有好消息传来，沃老板焊的和赵公子焊的乘法电路都是好使的，还有什么比此刻更快乐呢？</p>\n<div align=\"center\"><br>    <img src=\"/assets/img/2019/amplitude_modulation.jpg\" alt=\"AM调幅\" height=\"400\"><br>    <p align=\"center\" style=\"color:#999\">赵公子的乘法器AM波形</p><br>    <img src=\"/assets/img/2019/mixing.jpg\" alt=\"混频\" height=\"400\"><br>    <p align=\"center\" style=\"color:#999\">沃老板的混频器波形</p><br></div>\n\n<p>周日下午发生了一些不愉快的事情，因为下午找不到他人（其实他在午睡），我对沃老板的不满更加强烈了，而那时我已经十分疲惫，愤怒之下，下午3点左右我直接回寝室，拒绝回他消息，然后睡了一觉。期间他来找我，我『哈哈』糊弄过去，不想再干。6点多起来看一眼手机，想了想，还是再去试试，把级联和功率要求做完吧，都已经到这个份上了，干脆就把它做到完。</p>\n<h2 id=\"乘胜追击\"><a href=\"#乘胜追击\" class=\"headerlink\" title=\"乘胜追击\"></a>乘胜追击</h2><p>我不想就此打住，野心开始膨胀了，<strong>『恰5分』</strong> 是调侃，此时更像是口号。发射机 AM 调制输出接上我焊调试乘法器抽空焊好的小信号放大器，效果非常好！放大了80倍，但我心里清楚，因为没有接负载，最后功率肯定达不到；接收机，混频后中频放大再检波，效果很差，但也算检波出来了，在要求不那么严苛的时候，可以拿到分；发射机接收机级联成功，和仿真保持一致。</p>\n<p>如此算来，我们已经可以拿到 4.5 分，但是我们不想收手，我们继续调放大器，要把功率的 5 分也拿到手。很不幸，我们没有成功，三极管射极电阻过小，导致射极电流过大，二极管被烧坏了，放大器也就怀了，这又是我们唯一的放大器，级联也没办法做了，这下只有 4 分了，后悔，懊恼。</p>\n<p>第二天周一，已经是12月23号了，我都没想到自己会在这上面花上近一周时间。白天上了一天课，晚上我们接着调试了一下，还是那个问题，AM 波后的小信号放大器不好使，级联就不行，功率也没有。赵公子也回来了，我们让他重新焊了一个，失败了，因为我临时对之前测试成功的电路做了修改，为了减小电流避免三极管烧毁的事再发生，但是我没想到这么一改，电流太小，放大倍数达不到要求，而且我应该自己亲手焊的。可以说今天又是一无所获。但我不会就此打住，我不愿放弃。</p>\n<p>周二上午上完微波课，我立马去教化买了元件，再焊一个小信号放大器，再试一次，不到最后，谁也不知道结果，我不想放弃。一番折腾，焊好，测试，成功。</p>\n<p>下午验收前一刻，上周三买的陶瓷滤波器终于从深圳邮到了学校，我赶紧去取回来，接到电路中，完美!<strong>『烂分恰完』</strong>。</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>做完这次课设，心里有太多感慨，很多次我都想放弃了，但是总有一股力量把我拉了回来，这其中有对朋友承诺的坚守也有自己那股不服输的劲，验收成功那一刻我有点想哭，是啊，这整个过程只有我自己这么看重吧，最后还在自我感动，但如果没有这自我感动，我不知道自己能否坚持下来。当然，课设整个过程也暴露了我的一些问题：我需要有更强大的精神力量，激励自己前进，也要学会如何带领团队前进。</p>\n","tags":[{"name":"记录","slug":"记录","permalink":"https://jonathan1214.github.io/tags/记录/"}]},{"title":"Believe_in_yourself","date":"2018-06-18T14:30:53.000Z","path":"2018/06/18/Believe-in-yourself/","text":"最近有点烦躁，事情一件接着一件地扑面而来，丝毫不给我喘气的机会，为了排遣苦闷，我嘴上的脏话多了不少，不过好在这一切都将过去了，过去了之后我一定要好好开始，现在，我只有祈祷最后能有一个好的结果。这是一个疯狂的六月！英语课程考试(6.7)，英语口语测试(6.14)，六级考试(6.16)，科创答辩(6.20)，数学建模考试(6.21)，近代史考试(6.26)，英语期末考试(6.29)……这还远没有结束，七月是工大的小学期时间！八月才放暑假！九月开学！坏消息是大物和微积分的考试放到小学期了，当然，这也可以算是好消息，至少六月份可以喘口气了，真正毫无疑问的好消息自然就是我们会搬进新公寓！","content":"<p>最近有点烦躁，事情一件接着一件地扑面而来，丝毫不给我喘气的机会，为了排遣苦闷，我嘴上的脏话多了不少，不过好在这一切都将过去了，过去了之后我一定要好好开始，现在，我只有祈祷最后能有一个好的结果。<br><a id=\"more\"></a><br>这是一个疯狂的六月！<br>英语课程考试(6.7)，英语口语测试(6.14)，六级考试(6.16)，科创答辩(6.20)，数学建模考试(6.21)，近代史考试(6.26)，英语期末考试(6.29)……这还远没有结束，七月是工大的小学期时间！八月才放暑假！九月开学！坏消息是大物和微积分的考试放到小学期了，当然，这也可以算是好消息，至少六月份可以喘口气了，真正毫无疑问的好消息自然就是我们会搬进新公寓！</p>\n","tags":[{"name":"记录","slug":"记录","permalink":"https://jonathan1214.github.io/tags/记录/"}]},{"title":"数据结构复习","date":"2018-05-14T12:25:46.000Z","path":"2018/05/14/review-data-structure/","text":"先抄一段Dave在他的书《The Pragmatic Programmer》中的话： You’re a Pragmatic Programmer. You aren’t wedded to any particular technology, but you have a broad enough background in the science, and your experience with practical projects allow you to choose good solution in particular situations. Theory and practice combine to make you strong. You adjust your approach to suit the current circumstance and environment. And you do this continuously as the work progresses. Pragmatic Programmers get the job done, and do it well. Ok，现在开始吧！ C语言程序设计开始 先上第一段代码： 1234567#include &lt;stdio.h&gt;int main(void)&#123; printf(\"Hello world\\n\"); printf(\"This is a C program\"); return 0;&#125; 这是一个简单的C程序，我从这里开始，解释什么的是不需要的。 第二段代码：1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;int main (void)&#123; //这个程序根据你输入的两个整数和输入的一个四则运算符进行运算 int a, b; unsigned int Bool = 0; char ch; printf(\"请输入两个整数：\"); scanf(\"%d\", &amp;a); scanf(\"%d\", &amp;a); printf(\"\\n请输入一个四则运算符：\"); Bool = scanf(\"%c\", &amp;ch); switch (ch) &#123; case '+': printf(\"\\n%d + %d = %d\", a, b, a+b); break; case '-': printf(\"\\n%d - %d = %d\", a, b, a-b); break:; case '*': printf(\"\\n%d * %d = %d\", a, b, a*b); break; case '/': printf(\"\\n%d / %d = %f\", a, b, float(a)/b); break; default: printf(\"输入的不是四则运算符！！！\"); break; &#125; return 0;&#125; OK，上面的代码写出来了！没有什么问题！记几个需要注意的地方： 1. `scanf()`的是有返回值，读到了几个正确的输入就返回几，例如在上面的代码的中，如果输入了一个字符，`Bool`的值就变成`1`，在这里作用不大，不过就是为了复习嘛，无所谓的啦。 2. 注意`switch() case`语句的用法：`switch()`括号内的变量类型一定要是__整型或者字符型__。 第三段代码：1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main (void)&#123; //定义一个二维数组并初始化 int a[2][3] = &#123; &#123;1, 2, 3&#125;, &#123;4, 5, 6&#125; &#125;; //几个指针的声明 int *pt; int (*pa)[3]; //注意：[]的优先级高于* int *pax[3]; //注意与上一个进行对比，这是不一样的 int ar1[2][3]; int ar2[3][2]; int **p2; //以下均是有效的赋值 pt = &amp;a[0][0]; pa = &amp;a[0]; //在这里pt和pa的值相同 pa = &amp;a[1]; p2 = &amp;pt;&#125; 从上面就可以看出来，指针这个东西还是很烦人的，不过也不难，多看几遍就行了，还有要注意指针和数组的关系。指针比数组更本质！ 第四段代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344//找二维数组的鞍点，行最小且列最大的即为鞍点#include &lt;stdio.h&gt;int main (void)&#123; int a[20][20]; int Row, Col; int i, j; printf(\"请输入数组的行数和列数：\"); scanf(\"%d%d\", Row, Col); printf(\"\\n请输入%d个整数：\\n\\t\", Row*Col); for (i = 0; i &lt; Row; i++) for (j = 0; j &lt; Col; j++) scanf(\"%d\", &amp;a[i][j]); for (i = 0; i &lt; Row; i++) &#123; int temp = a[i][0]; int k = 0; int f = 1; for (j = 1; j &lt; Col; j++) &#123; if (temp &gt; a[i][j]) &#123; temp = a[i][j]; k = j; &#125; &#125; for (j = 0; j &lt; Row; j++) &#123; if (j == i) continue; else &#123; if (a[j][k] &gt; a[i][k]) f = 0; &#125; &#125; if (f) printf(\"\\n%d\", &amp;a[i][k]); else printf(\"\\n无鞍点\"); &#125; return 0;&#125; 我也不管什么优化了，丑就丑吧，几个循环套起来又怕什么，比比谁写的更丑，没有运行时间和内存使用限制，写起来就是爽！ 第五段代码：12345678910111213141516171819#include &lt;stdio.h&gt;int main (void)&#123; printf(\"这是一个计算函数值的程序：\\n\"); int x, y; printf(\"请输入整数x的值：\"); scanf(\"%d\", &amp;x); if (x &lt; 0) y = 5*x; else &#123; if (x &lt; 8) y = 2*x - 1; else y = x + 4; &#125; printf(\"\\ny = %d\", y); return 0;&#125; 这段代码没什么意思，纯粹是送的。 第六段代码：1234567891011121314151617181920#include &lt;stdio.h&gt;void Pri_as_ord(int *p, int *q)&#123; int temp; if (*p &gt; *q) &#123; temp = *p; *p = *q; *q = temp; &#125;&#125;int main (void)&#123; int a, b; printf(\"请输入两个整数：\"); scanf(\"%d%d\", &amp;a, &amp;b); Pri_as_ord(&amp;a, &amp;b); printf(\"按由小到大的顺序输出：%d %d\", a, b); return 0;&#125; 还是没什么意思，接着写！ 第七段代码：12345678910111213141516171819202122232425262728293031323334353637383940/*录入三个学生的学号和各自两门课的成绩*/#include &lt;stdio.h&gt;struct Student&#123; int num; float score1; float score2;&#125;;void Best(struct Student student[], int n)&#123; int i, m, aver[n]; for (i = 0; i &lt; n; i++) aver[i] = (student[i].score1 + student[i].score2)/2; if (aver[0] &gt; aver[1]) &#123; if (aver[0] &gt; aver[2]) m = 0; else m = 2; &#125; else &#123; if (aver[1] &gt; aver[2]) m = 1; else m = 2; &#125; printf(\"平均成绩最高的学生的学号是：%d\", student[m].num);&#125;int main (void)&#123; int i = 1; struct Student student[3]; for (; i &lt; 4; i++) printf(\"请输入第%d个学生的学号和两门课的成绩:%d %f %f\", i, student[i-1].num, student[i-1].score1, student[i-1].score2); Best(student, 3); return 0;&#125; 哇！写得想吐了！超级累！不管继续！ 第八段代码123456789101112131415161718192021222324252627282930313233343536/*这只是一个函数，用来实现删除单链表中码值相同的节点，只保留一个假设节点是这样的：struct node&#123; int data; struct node *next; &#125;;*/void Del(struct node *head)&#123; struct node *p, *q, *s; p = head-&gt;next; if (p == NULL) printf(\"Empty List\"); else &#123; while (p-&gt;next != NULL) &#123; q = p-&gt;next; do &#123; while ((q-&gt;data != p-&gt;data) &amp;&amp; (q-&gt;next != NULL)) &#123; s = q; q = q-&gt;next; &#125; if (q-&gt;data == x) &#123; s-&gt;next = q-&gt;next; free (q); &#125; p = s-&gt;next; &#125; while (p != NULL); p = p-&gt;next; &#125; &#125;&#125; 上面的代码有点烦，不过好在思路还算清晰，没有遇到问题，就是时间花得太长了，单链表还是不够熟练，接着来！ 第九段代码：12345678910111213141516171819202122232425//一个队列入排操作struct queue&#123; int item[max]; int front; int rear;&#125;;//初始化时rear=-1，front为0~max-1的任意值//front指向队列第一个元素的前一个位置，rear指向队尾元素所在位置//front=rear时队列满，rear=-1时队列空struct queue q;void Inqueue(struct queue q, int x)&#123; if (q.front == q.rear) printf(\"队满\"); else &#123; if (q.rear = -1) q.rear = q.front; if (q.rear = max-1) q.rear = 0; q.rear += 1; q.item[q.rear] = x; &#125;&#125; 简单的顺序存储的队列，实现入排操作不难，弄懂原理就好。","content":"<p>先抄一段Dave在他的书《The Pragmatic Programmer》中的话：</p>\n<blockquote>\n<p>You’re a Pragmatic Programmer. You aren’t wedded to any particular technology, but you have a broad enough background in the science, and your experience with practical projects allow you to choose good solution in particular situations. Theory and practice combine to make you strong. You adjust your approach to suit the current circumstance and environment. And you do this continuously as the work progresses. Pragmatic Programmers get the job done, and do it well.</p>\n</blockquote>\n<p>Ok，现在开始吧！</p>\n<a id=\"more\"></a>\n<h1 id=\"C语言程序设计\"><a href=\"#C语言程序设计\" class=\"headerlink\" title=\"C语言程序设计\"></a>C语言程序设计</h1><h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><ol>\n<li>先上第一段代码：</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Hello world\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"This is a C program\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是一个简单的C程序，我从这里开始，解释什么的是不需要的。</p>\n<ol start=\"2\">\n<li>第二段代码：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//这个程序根据你输入的两个整数和输入的一个四则运算符进行运算</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a, b;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> Bool = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> ch;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"请输入两个整数：\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;a);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;a);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n请输入一个四则运算符：\"</span>);</span><br><span class=\"line\">    Bool = <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%c\"</span>, &amp;ch);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (ch)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'+'</span>: <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n%d + %d = %d\"</span>, a, b, a+b);</span><br><span class=\"line\">                  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'-'</span>: <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n%d - %d = %d\"</span>, a, b, a-b);</span><br><span class=\"line\">                  <span class=\"keyword\">break</span>:;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'*'</span>: <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n%d * %d = %d\"</span>, a, b, a*b);</span><br><span class=\"line\">                  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'/'</span>: <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n%d / %d = %f\"</span>, a, b, <span class=\"keyword\">float</span>(a)/b);</span><br><span class=\"line\">                  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:  <span class=\"built_in\">printf</span>(<span class=\"string\">\"输入的不是四则运算符！！！\"</span>);</span><br><span class=\"line\">                  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>OK，上面的代码写出来了！没有什么问题！记几个需要注意的地方：</p>\n<pre><code>1. `scanf()`的是有返回值，读到了几个正确的输入就返回几，例如在上面的代码的中，如果输入了一个字符，`Bool`的值就变成`1`，在这里作用不大，不过就是为了复习嘛，无所谓的啦。\n2. 注意`switch() case`语句的用法：`switch()`括号内的变量类型一定要是__整型或者字符型__。\n</code></pre><ol start=\"3\">\n<li>第三段代码：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//定义一个二维数组并初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a[<span class=\"number\">2</span>][<span class=\"number\">3</span>] = &#123;</span><br><span class=\"line\">        &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>&#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//几个指针的声明</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> *pt;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*pa)[<span class=\"number\">3</span>];  <span class=\"comment\">//注意：[]的优先级高于*</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> *pax[<span class=\"number\">3</span>];   <span class=\"comment\">//注意与上一个进行对比，这是不一样的</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ar1[<span class=\"number\">2</span>][<span class=\"number\">3</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ar2[<span class=\"number\">3</span>][<span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> **p2;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//以下均是有效的赋值</span></span><br><span class=\"line\">    pt = &amp;a[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">    pa = &amp;a[<span class=\"number\">0</span>];   <span class=\"comment\">//在这里pt和pa的值相同</span></span><br><span class=\"line\">    pa = &amp;a[<span class=\"number\">1</span>];</span><br><span class=\"line\">    p2 = &amp;pt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>从上面就可以看出来，指针这个东西还是很烦人的，不过也不难，多看几遍就行了，还有要注意指针和数组的关系。指针比数组更本质！</p>\n<ol start=\"4\">\n<li>第四段代码：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//找二维数组的鞍点，行最小且列最大的即为鞍点</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a[<span class=\"number\">20</span>][<span class=\"number\">20</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> Row, Col;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, j;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"请输入数组的行数和列数：\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, Row, Col);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n请输入%d个整数：\\n\\t\"</span>, Row*Col);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; Row; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; Col; j++)</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;a[i][j]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; Row; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = a[i][<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> f = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">1</span>; j &lt; Col; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (temp &gt; a[i][j])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                temp = a[i][j];</span><br><span class=\"line\">                k = j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; Row; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j == i)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (a[j][k] &gt; a[i][k])</span><br><span class=\"line\">                    f = <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f)</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n%d\"</span>, &amp;a[i][k]);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n无鞍点\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>我也不管什么优化了，丑就丑吧，几个循环套起来又怕什么，比比谁写的更丑，没有运行时间和内存使用限制，写起来就是爽！</p>\n<ol start=\"5\">\n<li>第五段代码：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"这是一个计算函数值的程序：\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"请输入整数x的值：\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;x);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        y = <span class=\"number\">5</span>*x;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">8</span>)</span><br><span class=\"line\">            y = <span class=\"number\">2</span>*x - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            y = x + <span class=\"number\">4</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\ny = %d\"</span>, y);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这段代码没什么意思，纯粹是送的。</p>\n<ol start=\"6\">\n<li>第六段代码：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Pri_as_ord</span><span class=\"params\">(<span class=\"keyword\">int</span> *p, <span class=\"keyword\">int</span> *q)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (*p &gt; *q)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        temp = *p;</span><br><span class=\"line\">        *p = *q;</span><br><span class=\"line\">        *q = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a, b;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"请输入两个整数：\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;a, &amp;b);</span><br><span class=\"line\">    Pri_as_ord(&amp;a, &amp;b);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"按由小到大的顺序输出：%d %d\"</span>, a, b);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>还是没什么意思，接着写！</p>\n<ol start=\"7\">\n<li>第七段代码：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*录入三个学生的学号和各自两门课的成绩</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> num;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> score1;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> score2;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Best</span><span class=\"params\">(struct Student student[], <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, m, aver[n];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">        aver[i] = (student[i].score1 + student[i].score2)/<span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (aver[<span class=\"number\">0</span>] &gt; aver[<span class=\"number\">1</span>])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (aver[<span class=\"number\">0</span>] &gt; aver[<span class=\"number\">2</span>])</span><br><span class=\"line\">            m = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            m = <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (aver[<span class=\"number\">1</span>] &gt; aver[<span class=\"number\">2</span>])</span><br><span class=\"line\">            m = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            m = <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"平均成绩最高的学生的学号是：%d\"</span>, student[m].num);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span> <span class=\"title\">student</span>[3];</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; i &lt; <span class=\"number\">4</span>; i++)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"请输入第%d个学生的学号和两门课的成绩:%d %f %f\"</span>,</span><br><span class=\"line\">                i, student[i<span class=\"number\">-1</span>].num, student[i<span class=\"number\">-1</span>].score1, student[i<span class=\"number\">-1</span>].score2);</span><br><span class=\"line\">    Best(student, <span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>哇！写得想吐了！超级累！不管继续！</p>\n<ol start=\"8\">\n<li>第八段代码<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*这只是一个函数，用来实现删除单链表中码值相同的节点，只保留一个</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">假设节点是这样的：struct node&#123;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\tint data;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\tstruct node *next;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t&#125;;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Del</span><span class=\"params\">(struct node *head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> *<span class=\"title\">p</span>, *<span class=\"title\">q</span>, *<span class=\"title\">s</span>;</span></span><br><span class=\"line\">    p = head-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Empty List\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p-&gt;next != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            q = p-&gt;next;</span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> ((q-&gt;data != p-&gt;data) &amp;&amp; (q-&gt;next != <span class=\"literal\">NULL</span>))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    s = q;</span><br><span class=\"line\">                    q = q-&gt;next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (q-&gt;data == x)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    s-&gt;next = q-&gt;next;</span><br><span class=\"line\">                    <span class=\"built_in\">free</span> (q);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                p = s-&gt;next;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> (p != <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">            p = p-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>上面的代码有点烦，不过好在思路还算清晰，没有遇到问题，就是时间花得太长了，单链表还是不够熟练，接着来！</p>\n<ol start=\"9\">\n<li>第九段代码：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//一个队列入排操作</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">queue</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> item[max];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> front;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> rear;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化时rear=-1，front为0~max-1的任意值</span></span><br><span class=\"line\"><span class=\"comment\">//front指向队列第一个元素的前一个位置，rear指向队尾元素所在位置</span></span><br><span class=\"line\"><span class=\"comment\">//front=rear时队列满，rear=-1时队列空</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">queue</span> <span class=\"title\">q</span>;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Inqueue</span><span class=\"params\">(struct <span class=\"built_in\">queue</span> q, <span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (q.front == q.rear)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"队满\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (q.rear = <span class=\"number\">-1</span>)</span><br><span class=\"line\">            q.rear = q.front;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (q.rear = max<span class=\"number\">-1</span>)</span><br><span class=\"line\">            q.rear = <span class=\"number\">0</span>;</span><br><span class=\"line\">        q.rear += <span class=\"number\">1</span>;</span><br><span class=\"line\">        q.item[q.rear] = x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>简单的顺序存储的队列，实现入排操作不难，弄懂原理就好。</p>\n","tags":[{"name":"C/C++","slug":"C-C","permalink":"https://jonathan1214.github.io/tags/C-C/"},{"name":"考试","slug":"考试","permalink":"https://jonathan1214.github.io/tags/考试/"},{"name":"数据结构","slug":"数据结构","permalink":"https://jonathan1214.github.io/tags/数据结构/"}]},{"title":"一点思考","date":"2018-04-16T14:17:54.000Z","path":"2018/04/16/A_little_thinking/","text":"时间总是不等人的，转眼大一快过完了，看着现在的窘境，回首过去，难免有一点伤感，如果那些时候换些选择，现在肯定不一样，不过转念一想，每准一切都是最好的安排，在那些时候做的那些选择成就了今天的我，好坏都这样吧，我得直视前方，正所谓，往者不可谏，来者犹可追。","content":"<p>时间总是不等人的，转眼大一快过完了，看着现在的窘境，回首过去，难免有一点伤感，如果那些时候换些选择，现在肯定不一样，不过转念一想，每准一切都是最好的安排，在那些时候做的那些选择成就了今天的我，好坏都这样吧，我得直视前方，正所谓，往者不可谏，来者犹可追。</p>\n","tags":[{"name":"思考","slug":"思考","permalink":"https://jonathan1214.github.io/tags/思考/"}]},{"title":"记录科创中期答辩","date":"2018-04-13T12:10:29.000Z","path":"2018/04/13/My_first_lose/","text":"今天下午的科创中期答辩我们组当掉了，说实话我们什么都没做，单纯的想敷衍过去，很不幸，老师没有让我们通过，4月29号要再来一次，希望可以通过吧。关于这次答辩，我还是有些东西想记下来的： 我们都有自己擅长的事，当然也有自己的绝不擅长甚至不愿触碰的事儿，很不幸，上台发言就是我不愿触碰的事儿，我害怕自己讲不清楚，害怕自己口齿不清，害怕失败，这或许是这次失败的一个重要原因吧。我们应该考虑下次答辩换一个人的，换一个会说的人，再有就是大二科创一定要好好选队友，海鹏非常可以，有拼劲儿，天行表达非常好，到时候再说，我只是一个中规中矩的驱动人物罢了，现在需要多学一点知识，也好让人家接受你成为队友。 我算是认识到了，要想做好一件事情，一个好的态度是非常是非常重要的。对应到这次科创，这态度体现在，如下几个方面，我们有没有好好做这个项目或者说有没有做，有没有认真准备PPT，有没有认真准备报告。总结起来就是既要好好做也要好好说，anyway，这一次已经过去了，我们要把剩下的路走完。 合理安排自己的时间，不要再浪费了，有许多美好值得去追求，有很多有意义的事儿可以去做，不要再浪费时间做一些没有意义的如玩手机的事儿了。 最后，不要再赶ddl，一定要提前做好。","content":"<p>今天下午的科创中期答辩我们组当掉了，说实话我们什么都没做，单纯的想敷衍过去，很不幸，老师没有让我们通过，4月29号要再来一次，希望可以通过吧。<br><a id=\"more\"></a><br>关于这次答辩，我还是有些东西想记下来的：</p>\n<p>我们都有自己擅长的事，当然也有自己的绝不擅长甚至不愿触碰的事儿，很不幸，上台发言就是我不愿触碰的事儿，我害怕自己讲不清楚，害怕自己口齿不清，害怕失败，这或许是这次失败的一个重要原因吧。我们应该考虑下次答辩换一个人的，换一个会说的人，再有就是大二科创一定要好好选队友，海鹏非常可以，有拼劲儿，天行表达非常好，到时候再说，我只是一个中规中矩的驱动人物罢了，现在需要多学一点知识，也好让人家接受你成为队友。</p>\n<p>我算是认识到了，要想做好一件事情，一个好的态度是非常是非常重要的。对应到这次科创，这态度体现在，如下几个方面，我们有没有好好做这个项目或者说有没有做，有没有认真准备PPT，有没有认真准备报告。总结起来就是既要好好做也要好好说，anyway，这一次已经过去了，我们要把剩下的路走完。</p>\n<p>合理安排自己的时间，不要再浪费了，有许多美好值得去追求，有很多有意义的事儿可以去做，不要再浪费时间做一些没有意义的如玩手机的事儿了。</p>\n<p>最后，不要再赶ddl，一定要提前做好。</p>\n","tags":[{"name":"记录","slug":"记录","permalink":"https://jonathan1214.github.io/tags/记录/"}]}]