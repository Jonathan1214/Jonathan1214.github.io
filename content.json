[{"title":"NS2 的介绍（六）—— trace 分析示例","date":"2020-04-08T04:41:36.000Z","path":"2020/04/ns2-trace-analysis-example/","text":"本文将展示一个 trace 分析示例，从中可以知道如何从 NS2 中生成 trace，如何解释 trace，如何从 trace 中得到有用的信息。在 模拟示例 给出的代码 ns-simple.tcl 中的第 15、16 行，我们打开了一个 trace 文件，在 finish 步骤中，我们向 trace 文件中写入了 trace 信息。 12345#...#open trace fileset f [open out.tr w]$ns trace-all $f#... 执行代码ns-simple.tcl会生成一个 NAM trace 文件，该文件作为 NAM 的输入，同时还会生成一个名为 out.tr 的文件，该文件用于我们的模拟分析。下图展示了 trace 的格式和来自 out.tr 的 trace 数据示例。每一个 trace 行依次为以下部分： 事件描述符：+，-，d，r 事件发生的模拟时间，单位：秒 发起事件的节点 接受的节点 packet 类型 packet 大小，单位 Byte 分隔符：—— flow id：使用者在 OTcl 脚本中定义的 flow id。在模拟中用不到，可用于后续分析 源地址 目的地址 网络层协议下 packet 序列编号：UDP 协议不需要使用编号但也会携带，便于分析；每一个 packet 编号唯一 拿到模拟数据后，我们要做的就是筛选出需要的信息，并把它们转换成更容易理解的形式然后分析。下面是一简单的数据转换示例，对上面得到的 out.tr 文件，在终端中执行 cat out.tr | grep &quot; 2 3 cbr &quot; | grep ^r | awk &#39;BEGIN {oldtime=0;oldpacket=0;} {dif=$12-oldpacket;if(dif==0) dif=1; if(dif&gt;0) {printf(&quot;%d\\t%f\\n&quot;,$12,($2-oldtime)/dif); oldtime=$2;oldpacket=$12}}&#39; &gt; jitter.txt，即可在目录下得到一个输出文件 jitter.txt。该命令从 trace 中提取节点 3 从 2 中接收 packet 的事件，并计算接收当前 packet 距离接收上一个 packet 的 packet 时延（接收时间差/packetID差）。使用 gnuplot 可以画出如下图像，X 轴为 packet 序列号，Y 轴为模拟时间（单位：秒）。 更多对 trace 的分析用法，参考 。 这个例子中，仿真后的分析在 shell 终端中进行，但是这些处理也可以在输入的 OTcl 脚本中进行，我们将在下一节讨论。 参考：WPI","content":"<p>本文将展示一个 trace 分析示例，从中可以知道如何从 NS2 中生成 trace，如何解释 trace，如何从 trace 中得到有用的信息。在 <a href=\"/2020/04/ns2-simple-simulation-example/\" title=\"模拟示例\">模拟示例</a> 给出的代码 <a href=\"/2020/04/ns2-trace-analysis-example/ns-simple.tcl\" title=\"ns-simple.tcl\">ns-simple.tcl</a> 中的第 15、16 行，我们打开了一个 trace 文件，在 finish 步骤中，我们向 trace 文件中写入了 trace 信息。<a id=\"more\"></a></p>\n<figure class=\"highlight tcl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#...</span></span><br><span class=\"line\"><span class=\"comment\">#open trace file</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> f [<span class=\"keyword\">open</span> out.tr w]</span><br><span class=\"line\">$ns <span class=\"keyword\">trace</span>-all $f</span><br><span class=\"line\">#...</span><br></pre></td></tr></table></figure>\n<p>执行代码<a href=\"/2020/04/ns2-trace-analysis-example/ns-simple.tcl\" title=\"ns-simple.tcl\">ns-simple.tcl</a>会生成一个 NAM trace 文件，该文件作为 NAM 的输入，同时还会生成一个名为 out.tr 的文件，该文件用于我们的模拟分析。下图展示了 trace 的格式和来自 out.tr 的 trace 数据示例。<br><br>每一个 trace 行依次为以下部分：</p>\n<ul>\n<li>事件描述符：+，-，d，r</li>\n<li>事件发生的模拟时间，单位：秒</li>\n<li>发起事件的节点</li>\n<li>接受的节点</li>\n<li>packet 类型</li>\n<li>packet 大小，单位 Byte</li>\n<li>分隔符：——</li>\n<li>flow id：使用者在 OTcl 脚本中定义的 flow id。在模拟中用不到，可用于后续分析</li>\n<li>源地址</li>\n<li>目的地址</li>\n<li>网络层协议下 packet 序列编号：UDP 协议不需要使用编号但也会携带，便于分析；每一个 packet 编号唯一</li>\n</ul>\n<p>拿到模拟数据后，我们要做的就是筛选出需要的信息，并把它们转换成更容易理解的形式然后分析。下面是一简单的数据转换示例，对上面得到的 out.tr 文件，在终端中执行 <code>cat out.tr | grep &quot; 2 3 cbr &quot; | grep ^r | awk &#39;BEGIN {oldtime=0;oldpacket=0;} {dif=$12-oldpacket;if(dif==0) dif=1; if(dif&gt;0) {printf(&quot;%d\\t%f\\n&quot;,$12,($2-oldtime)/dif); oldtime=$2;oldpacket=$12}}&#39; &gt; jitter.txt</code>，即可在目录下得到一个输出文件 jitter.txt。该命令从 trace 中提取节点 3 从 2 中接收 packet 的事件，并计算接收当前 packet 距离接收上一个 packet 的 packet 时延（接收时间差/packetID差）。使用 gnuplot 可以画出如下图像，X 轴为 packet 序列号，Y 轴为模拟时间（单位：秒）。</p>\n<p>更多对 trace 的分析用法，参考 。</p>\n<p>这个例子中，仿真后的分析在 shell 终端中进行，但是这些处理也可以在输入的 OTcl 脚本中进行，我们将在下一节讨论。</p>\n<hr>\n<p>参考：<a href=\"http://nile.wpi.edu.cn/NS/\" target=\"_blank\" rel=\"noopener\">WPI</a></p>\n","tags":[{"name":"网络","slug":"网络","permalink":"https://jonathan1214.github.io/tags/网络/"},{"name":"NS2","slug":"NS2","permalink":"https://jonathan1214.github.io/tags/NS2/"}]},{"title":"NS2 的介绍（五）—— 数据分组","date":"2020-04-07T08:06:51.000Z","path":"2020/04/ns2-packet/","text":"在前面两篇文章中我们分别介绍了 NS2 中非常重要的两个组成——事件调度器和网络组件，我们知道了 packet（数据分组）是如何在节点之间传递的，现在让我们来看看数据分组在 NS2 中是如何表示的。一个 NS2 数据分组由一个头部信息的栈和可选的数据空间组成，如下图所示。在简单仿真示例提到过，数据分组头格式在创建 Simulator 对象时被初始化，在 Simulator 对象中，一系列栈排列注册了的 header 头（有可能不可见）被定义，如 common 头（它通常被任何需要的对象使用）、IP 头、TCP 头、RTP 头（UDP 使用 RTP 头）和 trace 头，且每个 header 在栈中的偏移都会被记录下来。这意味着不管一个头有没有被使用，当一个 packet（数据分组）被代理分配时创建的栈中都会含有它，并且网络对象使用相应的 offset（偏移值）就可以获得数据分组的栈中的任意头。通常，一个 packet（数据分组）只有一个特定的 head（头部）栈，尽管通过分配数据空间，packet（数据分组）可以携带实际的（来自 application）信息，很少有 application（应用）和 agent（代理）的实现会支持这种做法，这是因为在非实时的模拟中传递真实数据是没有意义的。但是如果你想实现一个可以跨过网络去和另一个 application 通信的 application 的话，你也许可以使用这个特性，不过需要在下层的代理实现中做一点改动，还可以为 application 创建一个新的 header，然后修改下层的代理向这个新建的 header 写入受到的数据。后面这种方法会在后面的一篇文章中讲到。 参考：WPI","content":"<p>在前面两篇文章中我们分别介绍了 NS2 中非常重要的两个组成——<a href=\"../ns2-event-scheduler\">事件调度器</a>和<a href=\"../ns2-network-components\">网络组件</a>，我们知道了 packet（数据分组）是如何在节点之间传递的，现在让我们来看看数据分组在 NS2 中是如何表示的。<br><a id=\"more\"></a><br>一个 NS2 数据分组由一个<strong>头部信息的栈</strong>和<strong>可选的数据空间</strong>组成，如下图所示。在<a href=\"../ns2-simple-simulation-example\">简单仿真示例</a>提到过，数据分组头格式在创建 Simulator 对象时被初始化，在 Simulator 对象中，一系列栈排列注册了的 header 头（有可能不可见）被定义，如 common 头（它通常被任何需要的对象使用）、IP 头、TCP 头、RTP 头（UDP 使用 RTP 头）和 trace 头，且每个 header 在栈中的偏移都会被记录下来。这意味着不管一个头有没有被使用，当一个 packet（数据分组）被代理分配时创建的栈中都会含有它，并且网络对象使用相应的 offset（偏移值）就可以获得数据分组的栈中的任意头。<br><img src=\"/assets/img/2020/ns_packet_format.png\" alt=\"img\"><br>通常，一个 packet（数据分组）只有一个特定的 head（头部）栈，尽管通过分配数据空间，packet（数据分组）可以携带实际的（来自 application）信息，很少有 application（应用）和 agent（代理）的实现会支持这种做法，这是因为<strong>在非实时的模拟中传递真实数据是没有意义的</strong>。但是如果你想实现一个可以跨过网络去和另一个 application 通信的 application 的话，你也许可以使用这个特性，不过需要在下层的代理实现中做一点改动，还可以为 application 创建一个新的 header，然后修改下层的代理向这个新建的 header 写入受到的数据。后面这种方法会在后面的一篇文章中讲到。</p>\n<hr>\n<p>参考：<a href=\"http://nile.wpi.edu.cn/NS/\" target=\"_blank\" rel=\"noopener\">WPI</a></p>\n","tags":[{"name":"网络","slug":"网络","permalink":"https://jonathan1214.github.io/tags/网络/"},{"name":"NS2","slug":"NS2","permalink":"https://jonathan1214.github.io/tags/NS2/"}]},{"title":"NS2 的介绍（四）—— 网络组件","date":"2020-04-06T01:30:03.000Z","path":"2020/04/ns2-network-components/","text":"我们在前文讨论 NS2 中一个非常重要的组成——事件调度器，这篇文章将讨论 NS2 另一个关键的组成——网络组件，主要是复合网络组件。下图展示了 NS2 中部分 OTcl 类的部分体系结构，有助于我们理解基本的网络组件（network component），在这个链接中可以找到 NS2 类的完整的体系结构。 类的部分体系结构层级的根是 TclObject 类，它是所有 OTcl 库对象的父类，如 scheduler（调度器），network component（网络组件），（timer）计时器和其他，包括 NAM 相关的类。NsObject 类是 OTclObject 的直接子类，同时也是所有基本 network component（网络组件）对象的父类，这些 network component 构成复合网络对象如 node （节点）和 link （连接），用来处理 packet。基于可能的输出 data path （数据路径）的数量，基本 network component （网络组件）进一步分为两类，Connector（连接器）和 Classifier（分类器），只有一个输出 data path（数据路径）的网络对象归到 Connector（连接器）下，而有多条输出 data path（数据路径）的归到 Classifier （分类器）下。 节点和路由选择node（节点）是一个由节点入口对象和分类器构成的复合对象，如下图所示，NS2 中有两种 node （节点），unicast（单播）节点和 multicast （多播）节点。单播节点中有两个分类器，一个是负责单播路由选择的地址分类器，另一个是端口分类器。类似地，多播节点也有两个分类器，一个分类器负责区分多播 packet 和单播 packet，另一个多播分类器负责多播路由选择。 节点在 NS2 中，默认节点设置为单播，如要使用多播节点，需要在 OTcl 脚本中显式声明，创建 scheduler（调度器）对象后立即声明，而后所有的节点都会被创建为多播节点。确定节点类型后，使用者还需要手动选择一个路由选择协议，不可使用默认协议。 unicast： $ns rtproto &lt;type&gt; &lt;type&gt;：Static，Session，DV，cost，multi-path multicast： $ns multicast 放在 set $ns [new Scheduler] 后 $ns mrtproto &lt;type&gt; &lt;type&gt;：CtrMCast，DM，ST，BST 关于路由选择的更多信息，可以参考 NS2 手册。 连接link（连接）是 NS2 中另一个主要的复合对象，当使用者使用 Simulator 对象的 duplex-link 成员函数，就可以创建一个双向连接，该连接包括两条单向连接，分别连接的双方，如下图所示。 另一个要注意到是，节点的输出队列其实被实现为 simplex （单向）连接的一部分。从队列中 dequeue （出队）的 packet被传递给模拟连接延时的 Delay（延时）对象，而从队列中 drop （抛弃）的 packet 的被传递给一个 Null 代理然后被释放。最后，TTL 对象为每一个接受到的 packet 计算（time to live parameter）生命参数的时间，并更新 packet 的 TTL 字段。 连接 追踪在 NS2 中，网络活动在单向连接中被记录，如果 simulator （模拟器）被指引去追踪网络活动（使用 $ns trace-all &lt;file&gt; 或 $ns namtrace-all &lt;file&gt;），那么 link （连接）在创建后，会有如下图所示的 trace（追踪）对象插入其中。使用者也可以在给定的源节点和目的节点间自定义一个 type 类型的 trace 对象，使用 creat-trace {type &lt;file&gt; &lt;src&gt; &lt;dst&gt;} 命令即可。 当插入到 link 中的 trace 对象（如 EnqT，DeqT 和 RecvT）受到一个 packet 时，它会向特定的 trace 文件中写入信息，且不需要消耗模拟时间，然后把该 packet 传递给下一个网络对象。trace 的格式讲在后面讨论。 插入了 trace 对象的连接 队列监视器本质上，tracing （追踪）对象被设计成可以记录 packet 的到达所在位置的时间。尽管使用者可以从 trace 中获得足够多的信息，如果他们对特定输出队列中发生的事的细节感兴趣，他们可以通过一些设置来获取这些信息。比如，如果使用者对 RED 队列的行为感兴趣，想计算平均队列大小的 dynamics 和某一特定 RED 队列的实时队列大小，或者其他有关监视队列的需求，队列监视器就可以有所帮助。队列监视行为使用队列监视器对象和 snoop 队列对象实现，如下图所示。 当一个 packet 到达时，snoop 队列对象通知 queue monitor（队列监视器）该事件，由队列监视器监视队列。后续会给出一个 RED 队列监视的例子，详细情况可以参考那个例子。现在只需要注意到，snoop 队列对象除了图中所示的用法，它还可以与 tracing （追踪）对象并行使用。 插入了 trace 对象的连接 一个 packet 流动的例子到现在为止，我们分析了两个最重要的网络组件——节点和连接。下图展示了一个模拟网络建立和 packet 流动的内部情况。网络由两个节点 n0 和 n1 组成，网络地址分别 0 和 1。绑定在 n0 上的一个 TCP 代理使用端口 0 与 绑定在 n1 上的使用端口 0 的 TCP sink 对象通信。最后，一个 FTP 应用绑定到 TCP 代理上，请求发送一些数据。注意，下图没有显示出 FTP 在 TCP 上的具体行为，仅仅展示仿真网络和 packet 流动的详细内部情况。 插入了 trace 对象的连接 参考：WPI","content":"<p>我们在<a href=\"/2020/04/ns2-event-scheduler\">前文</a>讨论 NS2 中一个非常重要的组成——事件调度器，这篇文章将讨论 NS2 另一个关键的组成——网络组件，主要是复合网络组件。<br><a id=\"more\"></a><br>下图展示了 NS2 中部分 OTcl 类的部分体系结构，有助于我们理解基本的网络组件（network component），在<a href=\"http://www.sop.inria.fr/rodeo/personnel/Antonie.Clerget/ns\" target=\"_blank\" rel=\"noopener\">这个链接</a>中可以找到 NS2 类的完整的体系结构。</p>\n<p></p><p align=\"center\" class=\"img\"><br>    <img src=\"/assets/img/2020/partial_class_hierarchy.png\" alt=\"partial_class_hierarchy\" width=\"500\"><br>    <span align=\"center\" style=\"color:#999\">类的部分体系结构</span><br></p><br>层级的根是 TclObject 类，它是所有 OTcl 库对象的父类，如 scheduler（调度器），network component（网络组件），（timer）计时器和其他，包括 NAM 相关的类。NsObject 类是 OTclObject 的直接子类，同时也是所有基本 network component（网络组件）对象的父类，这些 network component 构成复合网络对象如 node （节点）和 link （连接），用来处理 packet。基于可能的输出 data path （数据路径）的数量，基本 network component （网络组件）进一步分为两类，Connector（连接器）和 Classifier（分类器），只有一个输出 data path（数据路径）的网络对象归到 Connector（连接器）下，而有多条输出 data path（数据路径）的归到 Classifier （分类器）下。<p></p>\n<h2 id=\"节点和路由选择\"><a href=\"#节点和路由选择\" class=\"headerlink\" title=\"节点和路由选择\"></a>节点和路由选择</h2><p>node（节点）是一个由节点入口对象和分类器构成的复合对象，如下图所示，NS2 中有两种 node （节点），unicast（单播）节点和 multicast （多播）节点。单播节点中有两个分类器，一个是负责单播路由选择的地址分类器，另一个是端口分类器。类似地，多播节点也有两个分类器，一个分类器负责区分多播 packet 和单播 packet，另一个多播分类器负责多播路由选择。</p>\n<p></p><p align=\"center\" class=\"img\"><br>    <img src=\"/assets/img/2020/node.png\" alt=\"node\" width=\"600\"><br>    <span align=\"center\" style=\"color:#999\">节点</span><br></p><br>在 NS2 中，默认节点设置为单播，如要使用多播节点，需要在 OTcl 脚本中显式声明，创建 scheduler（调度器）对象后立即声明，而后所有的节点都会被创建为多播节点。确定节点类型后，使用者还需要手动选择一个路由选择协议，不可使用默认协议。<p></p>\n<ul>\n<li>unicast：<ul>\n<li><code>$ns rtproto &lt;type&gt;</code></li>\n<li><code>&lt;type&gt;</code>：Static，Session，DV，cost，multi-path</li>\n</ul>\n</li>\n<li>multicast：<ul>\n<li><code>$ns multicast</code> 放在 <code>set $ns [new Scheduler]</code> 后</li>\n<li><code>$ns mrtproto &lt;type&gt;</code></li>\n<li><code>&lt;type&gt;</code>：CtrMCast，DM，ST，BST</li>\n</ul>\n</li>\n</ul>\n<p>关于路由选择的更多信息，可以参考 <a href=\"http://www.isi.edu/nsnam/ns/ns-documentation.html\" target=\"_blank\" rel=\"noopener\">NS2 手册</a>。</p>\n<h2 id=\"连接\"><a href=\"#连接\" class=\"headerlink\" title=\"连接\"></a>连接</h2><p>link（连接）是 NS2 中另一个主要的复合对象，当使用者使用 Simulator 对象的 <code>duplex-link</code> 成员函数，就可以创建一个双向连接，该连接包括两条单向连接，分别连接的双方，如下图所示。</p>\n<p>另一个要注意到是，节点的输出队列其实被实现为 simplex （单向）连接的一部分。从队列中 dequeue （出队）的 packet被传递给模拟连接延时的 Delay（延时）对象，而从队列中 drop （抛弃）的 packet 的被传递给一个 Null 代理然后被释放。最后，TTL 对象为每一个接受到的 packet 计算（time to live parameter）生命参数的时间，并更新 packet 的 TTL 字段。</p>\n<div align=\"center\" class=\"img\"><br>    <img src=\"/assets/img/2020/link.png\" alt=\"link\" width=\"400\"><br>    <span align=\"center\" style=\"color:#999\">连接</span><br></div>\n\n<h3 id=\"追踪\"><a href=\"#追踪\" class=\"headerlink\" title=\"追踪\"></a>追踪</h3><p>在 NS2 中，网络活动在单向连接中被记录，如果 simulator （模拟器）被指引去追踪网络活动（使用 <code>$ns trace-all &lt;file&gt;</code> 或 <code>$ns namtrace-all &lt;file&gt;</code>），那么 link （连接）在创建后，会有如下图所示的 trace（追踪）对象插入其中。使用者也可以在给定的源节点和目的节点间自定义一个 type 类型的 trace 对象，使用 <code>creat-trace {type &lt;file&gt; &lt;src&gt; &lt;dst&gt;}</code> 命令即可。</p>\n<p>当插入到 link 中的 trace 对象（如 EnqT，DeqT 和 RecvT）受到一个 packet 时，它会向特定的 trace 文件中写入信息，且不需要消耗模拟时间，然后把该 packet 传递给下一个网络对象。trace 的格式讲在后面讨论。</p>\n<div align=\"center\" class=\"img\"><br>    <img src=\"/assets/img/2020/link_with_trace.png\" alt=\"link_with_trace\" width=\"750\"><br>    <span align=\"center\" style=\"color:#999\">插入了 trace 对象的连接</span><br></div>\n\n<h3 id=\"队列监视器\"><a href=\"#队列监视器\" class=\"headerlink\" title=\"队列监视器\"></a>队列监视器</h3><p>本质上，tracing （追踪）对象被设计成可以记录 packet 的到达所在位置的时间。尽管使用者可以从 trace 中获得足够多的信息，如果他们对特定输出队列中发生的事的细节感兴趣，他们可以通过一些设置来获取这些信息。比如，如果使用者对 RED 队列的行为感兴趣，想计算平均队列大小的 dynamics 和某一特定 RED 队列的实时队列大小，或者其他有关监视队列的需求，队列监视器就可以有所帮助。队列监视行为使用队列监视器对象和 snoop 队列对象实现，如下图所示。</p>\n<p>当一个 packet 到达时，snoop 队列对象通知 queue monitor（队列监视器）该事件，由队列监视器监视队列。后续会给出一个 RED 队列监视的例子，详细情况可以参考那个例子。现在只需要注意到，snoop 队列对象除了图中所示的用法，它还可以与 tracing （追踪）对象并行使用。</p>\n<div align=\"center\" class=\"img\"><br>    <img src=\"/assets/img/2020/link_with_snoop_queue.png\" alt=\"link_with_snoop_queue\" width=\"750\"><br>    <span align=\"center\" style=\"color:#999\">插入了 trace 对象的连接</span><br></div>\n\n<h2 id=\"一个-packet-流动的例子\"><a href=\"#一个-packet-流动的例子\" class=\"headerlink\" title=\"一个 packet 流动的例子\"></a>一个 packet 流动的例子</h2><p>到现在为止，我们分析了两个最重要的网络组件——节点和连接。下图展示了一个模拟网络建立和 packet 流动的内部情况。<br>网络由两个节点 n0 和 n1 组成，网络地址分别 0 和 1。绑定在 n0 上的一个 TCP 代理使用端口 0 与 绑定在 n1 上的使用端口 0 的 TCP sink 对象通信。最后，一个 FTP 应用绑定到 TCP 代理上，请求发送一些数据。<br>注意，下图没有显示出 FTP 在 TCP 上的具体行为，仅仅展示仿真网络和 packet 流动的详细内部情况。</p>\n<div align=\"center\" class=\"img\"><br>    <img src=\"/assets/img/2020/packet_flow.png\" alt=\"packet_flow\" width=\"750\"><br>    <span align=\"center\" style=\"color:#999\">插入了 trace 对象的连接</span><br></div>\n\n<hr>\n<p>参考：<a href=\"http://nile.wpi.edu.cn/NS/\" target=\"_blank\" rel=\"noopener\">WPI</a></p>\n","tags":[{"name":"网络","slug":"网络","permalink":"https://jonathan1214.github.io/tags/网络/"},{"name":"NS2","slug":"NS2","permalink":"https://jonathan1214.github.io/tags/NS2/"}]},{"title":"NS2 的介绍（三）—— 事件调度器","date":"2020-04-04T00:32:25.000Z","path":"2020/04/ns2-event-scheduler/","text":"在上一篇文章中，我们从一个简单的例子出发，从零开始编写了一个 NS2 模拟用的 OTcl 脚本，我们需要在脚本中完成以下任务： 创建 Simulator 对象； 创建 node 对象并构建 node 间的连接 link； 创建代理对象和 traffic 源对象，连接 node 和代理，连接代理和 traffic 源； 创建模拟场景 scenario，即定义调度任务； 开始模拟。 按照以上这些步骤编写就可完成模拟脚本编写。这篇文章中要介绍的是第 4 个步骤创建模拟场景的详细信息，我们将讨论 NS2 中的离散事件调度器。如第一篇文章中谈到的，在 NS2 中，事件调度器主要是由一些网络组件来使用，组件们模拟 packet 的处理时需要调度程序作为延时器或计时器。如下图展示，每一个网络对象使用一个时间调度器，图中需要注意：（1）网络对象发出一个事件那么它就要在预定的时间点上处理这个事件；（2）网络对象间的数据路径和事件路径不相同；若深入到代码层面，包在网络对象中传递时，发送方使用 send(Packet* p){target_-&gt;recv(p); 语句发送，接收方使用 recv(Packet*, Handler* h = 0) 方法接收。 离散事件调度器NS2 实现了两种事件调度器，实时调度器和非实时调度器。非实时调度器有三种实现，分别为 List、Heap 和 Calendar，它们逻辑上是一样的，之所以有这么多实现，是由于向下兼容的原因。默认的非实时调度器是 Calender 方式实现的。实时调度器是为仿真 emulation 使用的，允许仿真器 simulator 和真实的网络交互。下面这个就是一个指定事件调度器的例子。 set ns [new Simulator] $ns use-scheduler Heap 事件调度器还可以调度模拟事件，比如启动一个 FTP 应用或者结束模拟。事件调度器对象本身有一些模拟调度成员函数，比如 at &lt;time&gt; &quot;&lt;string&gt;&quot;，它就可以在发起一个在特定的模拟时间 &lt;time> 发生的叫做 AtEvent 的事件。AtEvent 其实是 Event 类的子类，它扩展了额外的变量保存 at &lt;time&gt; &quot;&lt;string&gt;&quot; 中的 string，尽管有扩展，它在事件调度器中和一般的事件还是被相同对待的。模拟开始后，当模拟时间到达事件队列中的 AtEvent 应该被调度的时间时，该 AtEvent 就会被传递给一个 AtEvent Handler，AtEvent Handler 只被创建一次并处理所有的的 AtEvent，AtEvent 的 &lt;string> 确定的 OTcl 命令也会被执行。下面是一个模拟事件调度示例： set ns [new Simulator] $ns use-scheduler Heap $ns at 300.5 &quot;complete_sim&quot; proc complete_sim {} {...} 注意到在上面的例子中，at &lt;time&gt; &quot;&lt;string&gt;&quot; 是 Simulator 对象 ns 的成员函数，但是我们要记住，Simulator 对象仅仅只是起到一个用户接口的作用，事实上它会去调用网络对象或者调度器对象的成员函数，由它们真正地完成工作。下面是一个函数列表和简单说明，这些函数就是 Simulator 对象用来接口调度器成员函数的成员函数。 成员函数 说明 Simulator instproc now 返回调度器对现在时间的 notion Simulator isntproc at args 在特定的时间调度执行代码 Simulator instproc at-now args 立即调度执行代码 Simulator instproc after n args n 秒后调度执行代码 Simulator instproc run args 启动调度器 Simulator instproc halt 停止或赞同调度器 参考：WPI","content":"<p>在<a href=\"/2020/04/ns2-simple-simulation-example\">上一篇文章</a>中，我们从一个简单的例子出发，从零开始编写了一个 NS2 模拟用的 OTcl 脚本，我们需要在脚本中完成以下任务：</p>\n<ol>\n<li>创建 Simulator 对象；</li>\n<li>创建 node 对象并构建 node 间的连接 link；</li>\n<li>创建代理对象和 traffic 源对象，连接 node 和代理，连接代理和 traffic 源；</li>\n<li>创建模拟场景 scenario，即定义调度任务；</li>\n<li>开始模拟。</li>\n</ol>\n<p>按照以上这些步骤编写就可完成模拟脚本编写。这篇文章中要介绍的是第 4 个步骤创建模拟场景的详细信息，我们将讨论 NS2 中的离散事件调度器。<br><a id=\"more\"></a><br>如<a href=\"/2020/04/02/ns2-simulation-overview\">第一篇文章</a>中谈到的，在 NS2 中，事件调度器主要是由一些网络组件来使用，组件们模拟 packet 的处理时需要调度程序作为延时器或计时器。如下图展示，每一个网络对象使用一个时间调度器，图中需要注意：<br>（1）网络对象发出一个事件那么它就要在预定的时间点上处理这个事件；<br>（2）网络对象间的数据路径和事件路径不相同；<br>若深入到代码层面，包在网络对象中传递时，发送方使用 <code>send(Packet* p){target_-&gt;recv(p);</code> 语句发送，接收方使用 <code>recv(Packet*, Handler* h = 0)</code> 方法接收。</p>\n<p><div align=\"center\" class=\"img\"><br>    <img src=\"/assets/img/2020/discrete_event_scheduler.png\" alt=\"discrete_event_scheduler\" width=\"750\"><br>    <span align=\"center\" style=\"color:#999\">离散事件调度器</span><br></div><br>NS2 实现了两种事件调度器，实时调度器和非实时调度器。非实时调度器有三种实现，分别为 List、Heap 和 Calendar，它们逻辑上是一样的，之所以有这么多实现，是由于向下兼容的原因。默认的非实时调度器是 Calender 方式实现的。实时调度器是为仿真 emulation 使用的，允许仿真器 simulator 和真实的网络交互。下面这个就是一个指定事件调度器的例子。</p>\n<pre><code>set ns [new Simulator]\n$ns use-scheduler Heap\n</code></pre><p>事件调度器还可以调度模拟事件，比如启动一个 FTP 应用或者结束模拟。事件调度器对象本身有一些模拟调度成员函数，比如 <code>at &lt;time&gt; &quot;&lt;string&gt;&quot;</code>，它就可以在发起一个在特定的模拟时间 &lt;time> 发生的叫做 <code>AtEvent</code> 的事件。<code>AtEvent</code> 其实是 <code>Event</code> 类的子类，它扩展了额外的变量保存 <code>at &lt;time&gt; &quot;&lt;string&gt;&quot;</code> 中的 <code>string</code>，尽管有扩展，它在事件调度器中和一般的事件还是被相同对待的。模拟开始后，当模拟时间到达事件队列中的 AtEvent 应该被调度的时间时，该 <code>AtEvent</code> 就会被传递给一个 <code>AtEvent Handler</code>，<code>AtEvent Handler</code> 只被创建一次并处理所有的的 <code>AtEvent</code>，<code>AtEvent</code> 的 &lt;string> 确定的 OTcl 命令也会被执行。下面是一个模拟事件调度示例：</p>\n<pre><code>set ns [new Simulator]\n$ns use-scheduler Heap\n$ns at 300.5 &quot;complete_sim&quot;\n\nproc complete_sim {} {...}\n</code></pre><p>注意到在上面的例子中，<code>at &lt;time&gt; &quot;&lt;string&gt;&quot;</code> 是 Simulator 对象 ns 的成员函数，但是我们要记住，Simulator 对象仅仅只是起到一个用户接口的作用，事实上它会去调用网络对象或者调度器对象的成员函数，由它们真正地完成工作。下面是一个函数列表和简单说明，这些函数就是 Simulator 对象用来接口调度器成员函数的成员函数。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">成员函数</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Simulator instproc now</td>\n<td style=\"text-align:left\">返回调度器对现在时间的 notion</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Simulator isntproc at args</td>\n<td style=\"text-align:left\">在特定的时间调度执行代码</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Simulator instproc at-now args</td>\n<td style=\"text-align:left\">立即调度执行代码</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Simulator instproc after n args</td>\n<td style=\"text-align:left\">n 秒后调度执行代码</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Simulator instproc run args</td>\n<td style=\"text-align:left\">启动调度器</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Simulator instproc halt</td>\n<td style=\"text-align:left\">停止或赞同调度器</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p>参考：<a href=\"http://nile.wpi.edu.cn/NS/\" target=\"_blank\" rel=\"noopener\">WPI</a></p>\n","tags":[{"name":"网络","slug":"网络","permalink":"https://jonathan1214.github.io/tags/网络/"},{"name":"NS2","slug":"NS2","permalink":"https://jonathan1214.github.io/tags/NS2/"}]},{"title":"NS2 的介绍（二）—— 模拟示例","date":"2020-04-03T02:25:25.000Z","path":"2020/04/ns2-simple-simulation-example/","text":"我们在前一篇文章中简单介绍了 NS2，它是一个离散事件驱动的网络模拟器，从具体实现来看，它就是一个 OTcl 脚本解释器，由模拟事件调度程序、网络组件对象库和网络启动(plumbing)模块库组成。文中还介绍了这些部分是如何一起协同实现网络模拟的。有了关于 NS2 的基本概念，下面就来看一个具体的模拟示例，看看 OTcl 脚本如何编写，如何进行一个网络模拟吧。 OTcl 脚本编写前面提到，NS2 是一个 OTcl 解释器，在它上面进行模拟就需要编写 OTcl 脚本。在介绍 OTcl 编写之前，我们需要知道 Tcl 和 OTcl 的关系就像 C 和 C++ 的关系一样，在前者的基础上，后者增加了面向对象特性，下面就来看看 Tcl 和 OTcl 脚本如何编写吧。 Tcl 脚本一份 Tcl 脚本如下所示，需要关注的点如表所示，详细可以参考易百教程，对于基本的 NS2 脚本编写，了解这些就够了。 操作 关键字 格式 示例 定义 procedure proc proc &lt;procname&gt; {&lt;argumentlist&gt;} {&lt;contents&gt;} 第 2 行 定义变量 set set &lt;variablename&gt; &lt;variablevalue&gt; 第 3 行 表达式值替换 expr [expr &lt;expression&gt;] 第 5 行 变量值替换 $ $&lt;variablename&gt; 第 5 行 输出 puts puts &quot;&lt;contents&gt;&quot; 第 9 行 for 循环 for for {&lt;initial&gt;} {&lt;condition&gt;} {actioneveryloop} {&lt;mainLoopExpression&gt;} 第 7 行 if 条件选择语句 if if {&lt;condition&gt;} {&lt;expression&gt;} 第 8 行 ex-tcl.tclview raw12345678910111213141516# 定义一个 procedureproc test {} { set a 43 set b 27 set c [expr $a + $b] set d [expr [expr $a - $b] * $c] for {set k 0} {$k &lt; 10} {incr k} { if {$k &lt; 5} { puts \"k &lt; 5, pow = [expr pow($d, $k)]\" } else { puts \"k &gt;= 5, mod = [expr $d % $k]\" } }}# 调用 procedure testtest 将文件保存为 ex-tcl.tcl，然后在Shell中执行 ns ex-tcl.tcl，得到的的输出如下： 12345678910k &lt; 5, pow = 1.0k &lt; 5, pow = 1120.0k &lt; 5, pow = 1254400.0k &lt; 5, pow = 1404928000.0k &lt; 5, pow = 1573519360000.0k &gt;= 5, mod = 0k &gt;= 5, mod = 4k &gt;= 5, mod = 0k &gt;= 5, mod = 0k &gt;= 5, mod = 4 OTcl 脚本相比于 Tcl，OTcl 增加了面向对象功能，下面这个例子展示了 OTcl 中对象是如何被创建和使用的。作为一个 NS2 的使用者，我们可能不会需要编写自己的 OTcl 对象，但是了解它们还是很有帮助的，因为我们在 NS2 模拟中使用的所有的对象，无论它们是 C++ 编写后连接到 OTcl 还是是直接使用OTcl 编写的，它们本质上都是 OTcl 对象。 下面这个例子中创建了两个类 mom 和 kid，它们都有成员函数 greet，声明类之后，在第 17~19 行我们对类进行了实例化，并定义了实例的成员变量的值，然后在 23、24 行调用了两个实例的成员函数。从代码从我们很容易可以看出： 如何对类进行实例化？ 如何改变类实例的成员变量的值？ 如何调用类实例的成员函数？ 那么如何定义一个类和子类呢？定义一个类需要使用关键字 Class 创建一个类，使用关键字 instproc 定义类的成员函数。类的继承使用关键字 -superclass，在成员函数中，$self 的作用就好像 C++ 中的 this 指针一样，关键字 instvar 检查后面紧跟的变量名是否已在类或父类中被声明，如果已经被声明，那这个变量就是已声明变量的引用，反之，这就是一个新的变量声明。最后，创建一个类实例，需要使用关键字 new。 ex-otcl.tclview raw123456789101112131415161718192021222324# add a member function called \"greet\"Class mommom instproc greet {} { $self instvar age_ puts \"$age_ year old mom say: How are you doing\"}# child classClass kid -superclass momkid instproc greet {} { $self instvar age_ puts \"$age_ year old kid say: What's up, dude?'\"}# creat instanceset a [new mom]$a set age_ 45set b [new kid]$b set age_ 15# calling member function$a greet$b greet 文件保存为 ex-otcl.tcl，在 Bash 中执行 ns ex-otcl.tcl，得到如下的输出： 123445 year old mom say: How are you doing15 year old kid say: What&apos;s up, dude?&apos; 简单的 NS2 模拟示例现在我们已经知道了基本的 OTcl 脚本是如何编写的了，现在来看看如何编写一个执行 NS2 模拟的 OTcl 脚本吧。下面的 ns-simple.tcl OTcl 脚本中进行了简单的网络配置，执行如图所示的模拟方案。下载代码后，在 Bash 中执行 ns ns-simple.tcl 即可。 一个简单的网络拓扑和模拟方案示意图从图中可以看到，这个网络包括四个节点：n0，n1，n2和n3。n0 和 n2 间是双向连接，n1 和 n2 间的连接有 2Mpbs 的带宽，传输时延为 10ms。n2 和 n3 之间为双向连接，传输带宽为 1.7Mbps，传输时延为 20ms。每个节点都使用一个 DropTail 队列，队列最大长度为 10。n0 节点上绑定了一个 tcp 代理，该代理和绑定在 n3 上的『sink』代理间构建了一条连接 (connection)。默认情况下，tcp 代理可以生成的最大 packet 为 1KByte。tcp『sink』代理生成确认接受分组 P 的 ACK 并将 ACk 发送给分组的发送者（即发送分组 P 的 tcp 代理），然后释放接收到的分组 P。n1 节点上绑定了一个 udp 代理，该代理和绑定在 n3 上的『null』代理间建立了一条连接。『null』代理字释放接收到的 packet，不会向 packet 的发送方发送 ACK。ftp 和 cbr 是 traffic 生成器，分别绑定到 tcp 和 udp 代理上。cbr 被设定为可以生成以 1Mbps 的速率生成 1KByte 大小的 packet，它在 0.1s 时开始工作到 4.5s 时停止，而 ftp 在 1.0s 时开始工作到 4.0s 停止。 ns-simple.tclview raw12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788# create a simulator objectset ns [new Simulator]# set color for NAM$ns color 1 blue$ns color 2 red# creat four Nodesset n0 [$ns node]set n1 [$ns node]set n2 [$ns node]set n3 [$ns node]# open NAM file and trace fileset f [open out.tr w]$ns trace-all $fset nf [open out.nam w]$ns namtrace-all $nf# 设置节点间的连接$ns duplex-link $n0 $n2 2Mb 10ms DropTail$ns duplex-link $n1 $n2 2Mb 10ms DropTail$ns duplex-link $n2 $n3 1.7Mb 20ms DropTail# 设置 n2 n3 队列大小$ns queue-limit $n2 $n3 10# 设置 NAM 中节点的位置$ns duplex-link-op $n0 $n2 orient right-down$ns duplex-link-op $n1 $n2 orient right-up$ns duplex-link-op $n2 $n3 orient right# NAM 设置$ns duplex-link-op $n2 $n3 queuePos 0.5# 设置 TCP 连接set tcp [new Agent/TCP]$tcp set class_ 2$ns attach-agent $n0 $tcpset sink [new Agent/TCPSink]$ns attach-agent $n3 $sink$ns connect $tcp $sink# 在 TCP 连接上启动 FTPset ftp [new Application/FTP]$ftp attach-agent $tcp$ftp set type_ FTP# 设置 UDP 连接set udp [new Agent/UDP]$ns attach-agent $n1 $udpset null [new Agent/Null]$ns attach-agent $n3 $null$ns connect $udp $null$udp set fid_ 2# 在 UDP 连接上设置 CBRset cbr [new Application/Traffic/CBR]$cbr attach-agent $udp$cbr set type_ CBR$cbr set packet_size_ 1000$cbr set random_ false# 为CBR 和 FTP 代理调度事件$ns at 0.1 \"$cbr start\"$ns at 1.0 \"$ftp start\"$ns at 4.0 \"$ftp stop\"$ns at 4.5 \"$cbr stop\"# 释放tcp和sink代理 会自动释放$ns at 4.5 \"ns detach-agent $n0 $tcp ; $ns detach-agent $n3 $sink\"# 调用 finish 步骤$ns at 5.0 \"finish\"proc finish {} { global ns f nf $ns flush-trace close $f close $nf puts \"running nam...\" exec nam out.nam &amp; exit 0}puts \"CBR packet size = [$cbr set packet_size_]\"puts \"CBR interval = [$cbr set interval_]\"$ns run 从 Simulator 对象开始网络的基本设置下面是对上述脚本的解释，总体上来看，NS 脚本从创建一个 Simulator 对象实例开始。注意：代码中，&lt;&gt; 包围的内容在使用时要按照实际情况替代成正确的内容。 set ns [new Simulator]：生成一个 NS2 simulator 对象实例为 ns。这一行代码完成了一些工作： 初始化 packet 格式 创建一个调度器（默认为 calendar 调度器） 选择默认的地址格式 Simulator 的成员函数可以完成如下工作： 创建一些复合对象，如节点 node 和 连接 link 连接网络组件对象 设置网络组件对象的参数 创建代理间的连接，如 tcp 和 sink 间的连接 明确 NAM 展示的选项等等 大多数成员函数用于模拟设置（如 plumbing 函数）和调度，也有一些用于 NAM 展示的设置。Simulator 对象成员函数在文件 ns-2.35/tcl/lib/ns-lib.tcl 中实现。 $ns color &lt;fid&gt; &lt;color&gt;：为流 id 即 fid 确定的流中 packet 设置颜色。该 Simulator 对象的成员函数为 NAM 展示服务，对实际的模拟有影响。 $ns namtrace-all &lt;file-descrption&gt;：这个成员函数告诉模拟器（simulator）按照 NAM 的输入的格式记录模拟痕迹（trace）到文件中，同时也给出了 $ns flush-trace 命令要写入的文件。类似的，函数 trace-all 用来记录模拟痕迹（trace），但是是基本的格式。 proc finish {}：一个模拟结束够调用的函数，通过 $ns at 5.0 &quot;finish&quot; 调用。在函数中，定义了模拟后的后续操作，如保存文件。 set n0 [$ns node]：成员函数 node 创建一个节点 node0。NS2 中的节点是一个复合类，由地址和端口分类器组成。用户创建节点时，也可以分别创建一个地址和端口分类器对象，然后再把它们连接起来，但是这个 Simulator 成员函数让节点创建变得简单。文件 ns-2.35/tcl/lib/ns-lib.tcl 和 ns-2.35/tcl/lib/ns-node.tcl 中有关于创建节点的详细信息。 $ns duplex-link &lt;node1&gt; &lt;node2&gt; &lt;bandwidth&gt; &lt;delay&gt; &lt;queue-type&gt;：创建两条单向连接，指定带宽和时延，然后连接声明的两个节点。在 NS2 中，节点的输出队列实现为一个连接的一部分，因此用户在创建连接时要指明队列类型 queue-type。上面的代码中使用的 DropTail 队列，如果想使用其他队列，修改队列类型即可。连接的实现在下一篇文章会提到，类似节点，连接也是一个复合类型，用户可以创建出它的子对象然后把他们和节点连接起来。有关连接的源代码在文件 ns-2.35/tcl/lib/ns-lib.tcl 和 ns-2.35/tcl/lib/ns-link.tcl 中。在连接模块中，我们可以进行很多个性化的操作，详请参考 NS2 文档。 $ns queue-limit &lt;node1&gt; &lt;node2&gt; &lt;number&gt;：设置两条连接 node1 和 node2 单向连接的队列大小。 $ns duplex-link-op &lt;node1&gt; &lt;node2&gt; ...：NAM 展示的设置，即设置节点的位置。 设置代理和 traffic 源现在，基本的网络设置以及完成了，下一就是启动 traffic 代理，如 TCP 和 UDP，这两个代理的 traffic 源分别为 FTP 和 CBR，然后把代理绑定到对应的节点上，把 traffic 绑定到对应的代理上。 set &lt;tcpname&gt; [new Agent/TCP]：创建一个名为 tcpname 的代理。总的来说，用户都是以这种方式创建任何代理或 traffic 源。代理和 traffic 源其实是基本对象（非复合对象），它们是基于 C++ 实现的，然后连接到 OTcl 上，因此没有特殊的 Simulator 对象的成员函数来创建这些对象实例。用户应该知晓这些代理和 traffic 源对象的类名，如 Agent/TCP，Agent/TCPSink，Application/FTP 等等，详细可参看 NS2 的文档，在文件 ns-2.35/tcl/lib/ns-default.tcl 也可以找到相关信息，文件中包含了可使用的网络对象的默认参数值设置，因此，它可以很好的告诉我们哪种网络对象在 NS2 中可以使用，可设置的参数有哪些。 $ns attach-agent &lt;node&gt; &lt;agent&gt;：为节点绑定代理。事实上，这个attach-agent函数调用节点的成员函数attach来完成绑定工作，因此也可以使用如 $n0 attach $tcp0 将 节点 代理 tcp0 绑定到节点 n0 上。 $ns connect &lt;agent1&gt; &lt;agent2&gt;：创建了两个代理之后，下一步就是建立逻辑网络连接，通过这一行语句，代理间将对方的网络和端口地址设置为目的地址，从而建立网络连接。 编写模拟场景假设所有的网络设置已经完成了，接下来就该编写模拟场景 scenario。Simulator 对象有许多调度成员函数，下面这个是最经常被使用的： $ns at &lt;time&gt; &quot;&lt;string&gt;&quot;：让调度器在指定的 time 时执行 string 中的命令。如 $ns at 0.1 &quot;$cbr start&quot;，让调度器调用 CBR traffic 源对象的一个名为 start 的成员函数，start 会开始启动 CBR 发送数据。在 NS2 中，一个 traffic 源通常不会发生真实的数据，它会通知下层的代理『有一些数据要发生』，代理就会知道有多少数据要发生，然后由代理创建 packet 并发送出去。 开始模拟配置好网络，写好调度程序和指定模拟后的数据保存操作之后，最后开始模拟即可，脚本中的最后一句：$ns run 声明开始模拟。 参考：WPI","content":"<p>我们在前<a href=\"/2020/04/ns2-simulation-overview\">一篇文章</a>中简单介绍了 NS2，它是一个离散事件驱动的网络模拟器，从具体实现来看，它就是一个 OTcl 脚本解释器，由模拟事件调度程序、网络组件对象库和网络启动(plumbing)模块库组成。文中还介绍了这些部分是如何一起协同实现网络模拟的。有了关于 NS2 的基本概念，下面就来看一个具体的模拟示例，看看 OTcl 脚本如何编写，如何进行一个网络模拟吧。<br><a id=\"more\"></a></p>\n<h2 id=\"OTcl-脚本编写\"><a href=\"#OTcl-脚本编写\" class=\"headerlink\" title=\"OTcl 脚本编写\"></a>OTcl 脚本编写</h2><p>前面提到，NS2 是一个 OTcl 解释器，在它上面进行模拟就需要编写 OTcl 脚本。在介绍 OTcl 编写之前，我们需要知道 Tcl 和 OTcl 的关系就像 C 和 C++ 的关系一样，在前者的基础上，后者增加了面向对象特性，下面就来看看 Tcl 和 OTcl 脚本如何编写吧。</p>\n<h3 id=\"Tcl-脚本\"><a href=\"#Tcl-脚本\" class=\"headerlink\" title=\"Tcl 脚本\"></a>Tcl 脚本</h3><p>一份 Tcl 脚本如下所示，需要关注的点如表所示，详细可以参考<a href=\"https://yiibai.com/tcl\" target=\"_blank\" rel=\"noopener\">易百教程</a>，对于基本的 NS2 脚本编写，了解这些就够了。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">操作</th>\n<th style=\"text-align:left\">关键字</th>\n<th style=\"text-align:left\">格式</th>\n<th style=\"text-align:left\">示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">定义 procedure</td>\n<td style=\"text-align:left\"><code>proc</code></td>\n<td style=\"text-align:left\"><code>proc &lt;procname&gt; {&lt;argumentlist&gt;} {&lt;contents&gt;}</code></td>\n<td style=\"text-align:left\">第 2 行</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">定义变量</td>\n<td style=\"text-align:left\"><code>set</code></td>\n<td style=\"text-align:left\"><code>set &lt;variablename&gt; &lt;variablevalue&gt;</code></td>\n<td style=\"text-align:left\">第 3 行</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">表达式值替换</td>\n<td style=\"text-align:left\"><code>expr</code></td>\n<td style=\"text-align:left\"><code>[expr &lt;expression&gt;]</code></td>\n<td style=\"text-align:left\">第 5 行</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">变量值替换</td>\n<td style=\"text-align:left\"><code>$</code></td>\n<td style=\"text-align:left\"><code>$&lt;variablename&gt;</code></td>\n<td style=\"text-align:left\">第 5 行</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">输出</td>\n<td style=\"text-align:left\"><code>puts</code></td>\n<td style=\"text-align:left\"><code>puts &quot;&lt;contents&gt;&quot;</code></td>\n<td style=\"text-align:left\">第 9 行</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">for 循环</td>\n<td style=\"text-align:left\"><code>for</code></td>\n<td style=\"text-align:left\"><code>for {&lt;initial&gt;} {&lt;condition&gt;} {actioneveryloop} {&lt;mainLoopExpression&gt;}</code></td>\n<td style=\"text-align:left\">第 7 行</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">if 条件选择语句</td>\n<td style=\"text-align:left\"><code>if</code></td>\n<td style=\"text-align:left\"><code>if {&lt;condition&gt;} {&lt;expression&gt;}</code></td>\n<td style=\"text-align:left\">第 8 行</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight tcl\"><figcaption><span>ex-tcl.tcl</span><a href=\"/downloads/code/ex-tcl.tcl\">view raw</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 定义一个 procedure</span></span><br><span class=\"line\"><span class=\"keyword\">proc</span><span class=\"title\"> test</span> {} {</span><br><span class=\"line\">    <span class=\"keyword\">set</span> a <span class=\"number\">43</span></span><br><span class=\"line\">    <span class=\"keyword\">set</span> b <span class=\"number\">27</span></span><br><span class=\"line\">    <span class=\"keyword\">set</span> c [<span class=\"keyword\">expr</span> $a + $b]</span><br><span class=\"line\">    <span class=\"keyword\">set</span> d [<span class=\"keyword\">expr</span> [<span class=\"keyword\">expr</span> $a - $b] * $c]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> {<span class=\"keyword\">set</span> k <span class=\"number\">0</span>} {$k &lt; <span class=\"number\">10</span>} {<span class=\"keyword\">incr</span> k} {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> {$k &lt; <span class=\"number\">5</span>} {</span><br><span class=\"line\">            <span class=\"keyword\">puts</span> <span class=\"string\">\"k &lt; 5, pow = [expr pow($d, $k)]\"</span></span><br><span class=\"line\">        } else {</span><br><span class=\"line\">            <span class=\"keyword\">puts</span> <span class=\"string\">\"k &gt;= 5, mod = [expr $d % $k]\"</span></span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\"># 调用 procedure test</span></span><br><span class=\"line\">test</span><br></pre></td></tr></table></figure>\n<p>将文件保存为 <code>ex-tcl.tcl</code>，然后在Shell中执行 <code>ns ex-tcl.tcl</code>，得到的的输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">k &lt; 5, pow = 1.0</span><br><span class=\"line\">k &lt; 5, pow = 1120.0</span><br><span class=\"line\">k &lt; 5, pow = 1254400.0</span><br><span class=\"line\">k &lt; 5, pow = 1404928000.0</span><br><span class=\"line\">k &lt; 5, pow = 1573519360000.0</span><br><span class=\"line\">k &gt;= 5, mod = 0</span><br><span class=\"line\">k &gt;= 5, mod = 4</span><br><span class=\"line\">k &gt;= 5, mod = 0</span><br><span class=\"line\">k &gt;= 5, mod = 0</span><br><span class=\"line\">k &gt;= 5, mod = 4</span><br></pre></td></tr></table></figure>\n<h3 id=\"OTcl-脚本\"><a href=\"#OTcl-脚本\" class=\"headerlink\" title=\"OTcl 脚本\"></a>OTcl 脚本</h3><p>相比于 Tcl，OTcl 增加了面向对象功能，下面这个例子展示了 OTcl 中对象是如何被创建和使用的。作为一个 NS2 的使用者，我们可能不会需要编写自己的 OTcl 对象，但是了解它们还是很有帮助的，因为我们在 NS2 模拟中使用的所有的对象，无论它们是 C++ 编写后连接到 OTcl 还是是直接使用OTcl 编写的，它们本质上都是 OTcl 对象。</p>\n<p>下面这个例子中创建了两个类 <code>mom</code> 和 <code>kid</code>，它们都有成员函数 <code>greet</code>，声明类之后，在第 17~19 行我们对类进行了实例化，并定义了实例的成员变量的值，然后在 23、24 行调用了两个实例的成员函数。从代码从我们很容易可以看出：</p>\n<ul>\n<li>如何对类进行实例化？</li>\n<li>如何改变类实例的成员变量的值？</li>\n<li>如何调用类实例的成员函数？</li>\n</ul>\n<p>那么如何定义一个类和子类呢？定义一个类需要使用关键字 <code>Class</code> 创建一个类，使用关键字 <code>instproc</code> 定义类的成员函数。类的继承使用关键字 <code>-superclass</code>，在成员函数中，<code>$self</code> 的作用就好像 C++ 中的 <code>this</code> 指针一样，关键字 <code>instvar</code> 检查后面紧跟的变量名是否已在类或父类中被声明，如果已经被声明，那这个变量就是已声明变量的引用，反之，这就是一个新的变量声明。最后，创建一个类实例，需要使用关键字 <code>new</code>。</p>\n<figure class=\"highlight tcl\"><figcaption><span>ex-otcl.tcl</span><a href=\"/downloads/code/ex-otcl.tcl\">view raw</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># add a member function called \"greet\"</span></span><br><span class=\"line\">Class mom</span><br><span class=\"line\">mom instproc greet {} {</span><br><span class=\"line\">    $self instvar age_</span><br><span class=\"line\">    <span class=\"keyword\">puts</span> <span class=\"string\">\"$age_ year old mom say:</span></span><br><span class=\"line\"><span class=\"string\">        How are you doing\"</span></span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\"># child class</span></span><br><span class=\"line\">Class kid -superclass mom</span><br><span class=\"line\">kid instproc greet {} {</span><br><span class=\"line\">    $self instvar age_</span><br><span class=\"line\">    <span class=\"keyword\">puts</span> <span class=\"string\">\"$age_ year old kid say:</span></span><br><span class=\"line\"><span class=\"string\">        What's up, dude?'\"</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># creat instance</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> a [new mom]</span><br><span class=\"line\">$a <span class=\"keyword\">set</span> age_ <span class=\"number\">45</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> b [new kid]</span><br><span class=\"line\">$b <span class=\"keyword\">set</span> age_ <span class=\"number\">15</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># calling member function</span></span><br><span class=\"line\">$a greet</span><br><span class=\"line\">$b greet</span><br></pre></td></tr></table></figure>\n<p>文件保存为 <code>ex-otcl.tcl</code>，在 Bash 中执行 <code>ns ex-otcl.tcl</code>，得到如下的输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">45 year old mom say:</span><br><span class=\"line\">        How are you doing</span><br><span class=\"line\">15 year old kid say:</span><br><span class=\"line\">        What&apos;s up, dude?&apos;</span><br></pre></td></tr></table></figure>\n<h2 id=\"简单的-NS2-模拟示例\"><a href=\"#简单的-NS2-模拟示例\" class=\"headerlink\" title=\"简单的 NS2 模拟示例\"></a>简单的 NS2 模拟示例</h2><p>现在我们已经知道了基本的 OTcl 脚本是如何编写的了，现在来看看如何编写一个执行 NS2 模拟的 OTcl 脚本吧。<br>下面的 <code>ns-simple.tcl</code> OTcl 脚本中进行了简单的网络配置，执行如图所示的模拟方案。下载代码后，在 Bash 中执行 <code>ns ns-simple.tcl</code> 即可。</p>\n<p><div align=\"center\" class=\"img\"><br>    <img src=\"/assets/img/2020/simple_simulation_scenario.png\" alt=\"structure_of_ns2\" width=\"750\"><br>    <span align=\"center\" style=\"color:#999\">一个简单的网络拓扑和模拟方案示意图</span><br></div><br>从图中可以看到，这个网络包括四个节点：n0，n1，n2和n3。n0 和 n2 间是双向连接，n1 和 n2 间的连接有 2Mpbs 的带宽，传输时延为 10ms。n2 和 n3 之间为双向连接，传输带宽为 1.7Mbps，传输时延为 20ms。每个节点都使用一个 DropTail 队列，队列最大长度为 10。<br>n0 节点上绑定了一个 tcp 代理，该代理和绑定在 n3 上的『sink』代理间构建了一条连接 (connection)。默认情况下，tcp 代理可以生成的最大 packet 为 1KByte。tcp『sink』代理生成确认接受分组 P 的 ACK 并将 ACk 发送给分组的发送者（即发送分组 P 的 tcp 代理），然后释放接收到的分组 P。<br>n1 节点上绑定了一个 udp 代理，该代理和绑定在 n3 上的『null』代理间建立了一条连接。『null』代理字释放接收到的 packet，不会向 packet 的发送方发送 ACK。<br>ftp 和 cbr 是 traffic 生成器，分别绑定到 tcp 和 udp 代理上。cbr 被设定为可以生成以 1Mbps 的速率生成 1KByte 大小的 packet，它在 0.1s 时开始工作到 4.5s 时停止，而 ftp 在 1.0s 时开始工作到 4.0s 停止。</p>\n<figure class=\"highlight tcl\"><figcaption><span>ns-simple.tcl</span><a href=\"/downloads/code/ns-simple.tcl\">view raw</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># create a simulator object</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> ns [new Simulator]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># set color for NAM</span></span><br><span class=\"line\">$ns color <span class=\"number\">1</span> blue</span><br><span class=\"line\">$ns color <span class=\"number\">2</span> red</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># creat four Nodes</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> n0 [$ns node]</span><br><span class=\"line\"><span class=\"keyword\">set</span> n1 [$ns node]</span><br><span class=\"line\"><span class=\"keyword\">set</span> n2 [$ns node]</span><br><span class=\"line\"><span class=\"keyword\">set</span> n3 [$ns node]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># open NAM file and trace file</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> f [<span class=\"keyword\">open</span> out.tr w]</span><br><span class=\"line\">$ns <span class=\"keyword\">trace</span>-all $f</span><br><span class=\"line\">set nf [<span class=\"keyword\">open</span> out.nam w]</span><br><span class=\"line\">$ns namtrace-all $nf</span><br><span class=\"line\"></span><br><span class=\"line\"># 设置节点间的连接</span><br><span class=\"line\">$ns duplex-link $n0 $n2 <span class=\"number\">2</span>Mb <span class=\"number\">10</span>ms DropTail</span><br><span class=\"line\">$ns duplex-link $n1 $n2 <span class=\"number\">2</span>Mb <span class=\"number\">10</span>ms DropTail</span><br><span class=\"line\">$ns duplex-link $n2 $n3 <span class=\"number\">1.7</span>Mb <span class=\"number\">20</span>ms DropTail</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置 n2 n3 队列大小</span></span><br><span class=\"line\">$ns queue-limit $n2 $n3 <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置 NAM 中节点的位置</span></span><br><span class=\"line\">$ns duplex-link-op $n0 $n2 orient right-down</span><br><span class=\"line\">$ns duplex-link-op $n1 $n2 orient right-up</span><br><span class=\"line\">$ns duplex-link-op $n2 $n3 orient right</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># NAM 设置</span></span><br><span class=\"line\">$ns duplex-link-op $n2 $n3 queuePos <span class=\"number\">0.5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置 TCP 连接</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> tcp [new Agent/TCP]</span><br><span class=\"line\">$tcp <span class=\"keyword\">set</span> class_ <span class=\"number\">2</span></span><br><span class=\"line\">$ns attach-agent $n0 $tcp</span><br><span class=\"line\">set sink [new Agent/TCPSink]</span><br><span class=\"line\">$ns attach-agent $n3 $sink</span><br><span class=\"line\">$ns connect $tcp $sink</span><br><span class=\"line\"># 在 TCP 连接上启动 FTP</span><br><span class=\"line\"><span class=\"keyword\">set</span> ftp [new Application/FTP]</span><br><span class=\"line\">$ftp attach-agent $tcp</span><br><span class=\"line\">$ftp <span class=\"keyword\">set</span> type_ FTP</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置 UDP 连接</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> udp [new Agent/UDP]</span><br><span class=\"line\">$ns attach-agent $n1 $udp</span><br><span class=\"line\">set null [new Agent/Null]</span><br><span class=\"line\">$ns attach-agent $n3 $null</span><br><span class=\"line\">$ns connect $udp $null</span><br><span class=\"line\">$udp <span class=\"keyword\">set</span> fid_ <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"comment\"># 在 UDP 连接上设置 CBR</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> cbr [new Application/Traffic/CBR]</span><br><span class=\"line\">$cbr attach-agent $udp</span><br><span class=\"line\">$cbr <span class=\"keyword\">set</span> type_ CBR</span><br><span class=\"line\">$cbr <span class=\"keyword\">set</span> packet_size_ <span class=\"number\">1000</span></span><br><span class=\"line\">$cbr <span class=\"keyword\">set</span> random_ false</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 为CBR 和 FTP 代理调度事件</span></span><br><span class=\"line\">$ns at <span class=\"number\">0.1</span> <span class=\"string\">\"$cbr start\"</span></span><br><span class=\"line\">$ns at <span class=\"number\">1.0</span> <span class=\"string\">\"$ftp start\"</span></span><br><span class=\"line\">$ns at <span class=\"number\">4.0</span> <span class=\"string\">\"$ftp stop\"</span></span><br><span class=\"line\">$ns at <span class=\"number\">4.5</span> <span class=\"string\">\"$cbr stop\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 释放tcp和sink代理 会自动释放</span></span><br><span class=\"line\">$ns at <span class=\"number\">4.5</span> <span class=\"string\">\"ns detach-agent $n0 $tcp ; $ns detach-agent $n3 $sink\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 调用 finish 步骤</span></span><br><span class=\"line\">$ns at <span class=\"number\">5.0</span> <span class=\"string\">\"finish\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">proc</span><span class=\"title\"> finish</span> {} {</span><br><span class=\"line\">    <span class=\"keyword\">global</span> ns f nf</span><br><span class=\"line\">    $ns <span class=\"keyword\">flush</span>-<span class=\"keyword\">trace</span></span><br><span class=\"line\">    <span class=\"keyword\">close</span> $f</span><br><span class=\"line\">    <span class=\"keyword\">close</span> $nf</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">puts</span> <span class=\"string\">\"running nam...\"</span></span><br><span class=\"line\">    <span class=\"keyword\">exec</span> nam out.nam &amp;</span><br><span class=\"line\">    <span class=\"keyword\">exit</span> <span class=\"number\">0</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">puts</span> <span class=\"string\">\"CBR packet size = [$cbr set packet_size_]\"</span></span><br><span class=\"line\"><span class=\"keyword\">puts</span> <span class=\"string\">\"CBR interval = [$cbr set interval_]\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ns run</span><br></pre></td></tr></table></figure>\n<h3 id=\"从-Simulator-对象开始网络的基本设置\"><a href=\"#从-Simulator-对象开始网络的基本设置\" class=\"headerlink\" title=\"从 Simulator 对象开始网络的基本设置\"></a>从 Simulator 对象开始网络的基本设置</h3><p>下面是对上述脚本的解释，总体上来看，NS 脚本从创建一个 Simulator 对象实例开始。<br><strong>注意</strong>：代码中，<code>&lt;&gt;</code> 包围的内容在使用时要按照实际情况替代成正确的内容。</p>\n<ul>\n<li><code>set ns [new Simulator]</code>：生成一个 NS2 simulator 对象实例为 ns。这一行代码完成了一些工作：<ul>\n<li>初始化 packet 格式</li>\n<li>创建一个调度器（默认为 calendar 调度器）</li>\n<li>选择默认的地址格式</li>\n</ul>\n</li>\n</ul>\n<p>Simulator 的成员函数可以完成如下工作：</p>\n<ul>\n<li>创建一些复合对象，如节点 node 和 连接 link</li>\n<li>连接网络组件对象</li>\n<li>设置网络组件对象的参数</li>\n<li>创建代理间的连接，如 tcp 和 sink 间的连接</li>\n<li>明确 NAM 展示的选项等等</li>\n</ul>\n<p>大多数成员函数用于模拟设置（如 plumbing 函数）和调度，也有一些用于 NAM 展示的设置。Simulator 对象成员函数在文件 <code>ns-2.35/tcl/lib/ns-lib.tcl</code> 中实现。</p>\n<ul>\n<li><code>$ns color &lt;fid&gt; &lt;color&gt;</code>：为流 id 即 fid 确定的流中 packet 设置颜色。该 Simulator 对象的成员函数为 NAM 展示服务，对实际的模拟有影响。</li>\n<li><code>$ns namtrace-all &lt;file-descrption&gt;</code>：这个成员函数告诉模拟器（simulator）按照 NAM 的输入的格式记录模拟痕迹（trace）到文件中，同时也给出了 <code>$ns flush-trace</code> 命令要写入的文件。类似的，函数 <code>trace-all</code> 用来记录模拟痕迹（trace），但是是基本的格式。</li>\n<li><code>proc finish {}</code>：一个模拟结束够调用的函数，通过 <code>$ns at 5.0 &quot;finish&quot;</code> 调用。在函数中，定义了模拟后的后续操作，如保存文件。</li>\n<li><code>set n0 [$ns node]</code>：成员函数 <code>node</code> 创建一个节点 node0。NS2 中的节点是一个复合类，由地址和端口分类器组成。用户创建节点时，也可以分别创建一个地址和端口分类器对象，然后再把它们连接起来，但是这个 Simulator 成员函数让节点创建变得简单。文件 <code>ns-2.35/tcl/lib/ns-lib.tcl</code> 和 <code>ns-2.35/tcl/lib/ns-node.tcl</code> 中有关于创建节点的详细信息。</li>\n<li><code>$ns duplex-link &lt;node1&gt; &lt;node2&gt; &lt;bandwidth&gt; &lt;delay&gt; &lt;queue-type&gt;</code>：创建两条单向连接，指定带宽和时延，然后连接声明的两个节点。在 NS2 中，节点的输出队列实现为一个连接的一部分，因此用户在创建连接时要指明队列类型 queue-type。上面的代码中使用的 DropTail 队列，如果想使用其他队列，修改队列类型即可。连接的实现在下一篇文章会提到，类似节点，连接也是一个复合类型，用户可以创建出它的子对象然后把他们和节点连接起来。有关连接的源代码在文件 <code>ns-2.35/tcl/lib/ns-lib.tcl</code> 和 <code>ns-2.35/tcl/lib/ns-link.tcl</code> 中。在连接模块中，我们可以进行很多个性化的操作，详请参考 NS2 文档。</li>\n<li><code>$ns queue-limit &lt;node1&gt; &lt;node2&gt; &lt;number&gt;</code>：设置两条连接 node1 和 node2 单向连接的队列大小。</li>\n<li><code>$ns duplex-link-op &lt;node1&gt; &lt;node2&gt; ...</code>：NAM 展示的设置，即设置节点的位置。</li>\n</ul>\n<h3 id=\"设置代理和-traffic-源\"><a href=\"#设置代理和-traffic-源\" class=\"headerlink\" title=\"设置代理和 traffic 源\"></a>设置代理和 traffic 源</h3><p>现在，基本的网络设置以及完成了，下一就是启动 traffic 代理，如 TCP 和 UDP，这两个代理的 traffic 源分别为 FTP 和 CBR，然后把代理绑定到对应的节点上，把 traffic 绑定到对应的代理上。</p>\n<ul>\n<li><code>set &lt;tcpname&gt; [new Agent/TCP]</code>：创建一个名为 tcpname 的代理。总的来说，用户都是以这种方式创建任何代理或 traffic 源。代理和 traffic 源其实是基本对象（非复合对象），它们是基于 C++ 实现的，然后连接到 OTcl 上，因此没有特殊的 Simulator 对象的成员函数来创建这些对象实例。用户应该知晓这些代理和 traffic 源对象的类名，如 Agent/TCP，Agent/TCPSink，Application/FTP 等等，详细可参看 NS2 的文档，在文件 <code>ns-2.35/tcl/lib/ns-default.tcl</code> 也可以找到相关信息，文件中包含了可使用的网络对象的默认参数值设置，因此，它可以很好的告诉我们哪种网络对象在 NS2 中可以使用，可设置的参数有哪些。</li>\n<li><code>$ns attach-agent &lt;node&gt; &lt;agent&gt;</code>：为节点绑定代理。事实上，这个<code>attach-agent</code>函数调用节点的成员函数<code>attach</code>来完成绑定工作，因此也可以使用如 <code>$n0 attach $tcp0</code> 将 节点 代理 tcp0 绑定到节点 n0 上。</li>\n<li><code>$ns connect &lt;agent1&gt; &lt;agent2&gt;</code>：创建了两个代理之后，下一步就是建立逻辑网络连接，通过这一行语句，代理间将对方的网络和端口地址设置为目的地址，从而建立网络连接。</li>\n</ul>\n<h3 id=\"编写模拟场景\"><a href=\"#编写模拟场景\" class=\"headerlink\" title=\"编写模拟场景\"></a>编写模拟场景</h3><p>假设所有的网络设置已经完成了，接下来就该编写模拟场景 scenario。Simulator 对象有许多调度成员函数，下面这个是最经常被使用的：</p>\n<ul>\n<li><code>$ns at &lt;time&gt; &quot;&lt;string&gt;&quot;</code>：让调度器在指定的 time 时执行 string 中的命令。如 <code>$ns at 0.1 &quot;$cbr start&quot;</code>，让调度器调用 CBR traffic 源对象的一个名为 start 的成员函数，start 会开始启动 CBR 发送数据。在 NS2 中，一个 traffic 源通常不会发生真实的数据，它会通知下层的代理『有一些数据要发生』，代理就会知道有多少数据要发生，然后由代理创建 packet 并发送出去。</li>\n</ul>\n<h3 id=\"开始模拟\"><a href=\"#开始模拟\" class=\"headerlink\" title=\"开始模拟\"></a>开始模拟</h3><p>配置好网络，写好调度程序和指定模拟后的数据保存操作之后，最后开始模拟即可，脚本中的最后一句：<code>$ns run</code> 声明开始模拟。</p>\n<hr>\n<p>参考：<a href=\"http://nile.wpi.edu.cn/NS/\" target=\"_blank\" rel=\"noopener\">WPI</a></p>\n","tags":[{"name":"网络","slug":"网络","permalink":"https://jonathan1214.github.io/tags/网络/"},{"name":"NS2","slug":"NS2","permalink":"https://jonathan1214.github.io/tags/NS2/"}]},{"title":"NS2 的介绍（一）—— 概述","date":"2020-04-02T08:15:03.000Z","path":"2020/04/ns2-simulation-overview/","text":"最近在上一门叫『无线自组织网络与应用』的课程，介绍了很多以前没有接触过的概念，包括了一个叫 NS2 的仿真工具，在前面一篇文章中介绍的 AHOHA 协议也是在这门课程中有被详细讲述的。这篇文章基本上是这篇文章的翻译，介绍 NS2 这个仿真工具，给出这个它的概述。 NS2是什么NS2 是一个使用 C++ 和 OTcl 编写的面向对象的离散事件驱动的网络仿真器，在 UCBerkely 被开发出来。它主要用于局域网和广域网仿真。由于缺少适合新手入门的教程，NS2对于初学者来说不是很友好。 概述NS2 可以仿真各种各样的IP网络。它实现了一些网络协议如 TCP 和 UDP，文件传输协议如 FTP、Telnet、Web、CBR 和 VBR，路由队列管理机制如 DropTail、RED 和 CBQ，路由选择算法如 Dijkstra，等等。针对局域网仿真，NS2 还实现了组播和一些 MAC 层协议。这里要介绍的是 NS2 的基本结构，然后按照例子介绍细节。 用户角度的NS概览NS2 是 OTcl 脚本解释器，包括仿真事件调度程序、网络组件对象库和网络启动 (plumbing) 模块库。plumbing 模块通常实现为基本模拟对象成员函数。换句话说，使用 NS2，你需要使用 OTcl 语言写一个脚本，包括以下内容： 初始化一个事件调度程序 使用网络对象和 plumbing 函数建立网络拓扑结构 通过事件调度程序告知何时开始发送分组 network object 网络对象plumbing 函数通过为对象设定指向合适的对象的邻居指针，在网络对象中探索可能的数据通路，进而建立起整个网络。如此一来，使用者想要创建一个新的网络对象变得简单，只需写一个新的对象或者从对象库中创建一个复合对象，然后探索 (plumb) 通过这个新对象的数据通路即可。听起来比较复杂，但是 plumbing OTcl 模块让这一切变得非常简单，这也是 NS2 的强大之处。 event scheduler 事件调度程序除网络对象外，NS2 中另一个主要的组件就是事件调度程序。在 NS2 中，一个事件就是一个包 ID，这个 ID 是唯一的，涵盖了分配时间，以及用来处理该事件的指向下一个对象的指针。在 NS2 中，一个事件调度程序记录着模拟时间，并通过调用适当的网络组件启动在事件队列中调度好的应该在当前启动的所有事件，这些组件通常是发出事件并让事件与事件指出的包一起完成正确的指令。网络组件间进行通信，传递 packet，但是并不会消耗真实的仿真时间。所有需要消耗仿真时间来处理 packet 的网络组件通过使用事件调度程序完成，组件为待处理到packet发出一个事件然后等待组件自己启动事件，再进行进一步的行动处理 packet。 举个例子，一个网络转发组件S模拟一次转发的延时为 20us，它为一个需要转发的 packet P 向调度程序发出一个延时 20us 的事件 E，20us 后，调度程序 M 从事件队列中调度出这个事件 E 并把它立即发给转发组件 S ，然后由转发组件 S 将 packet P 交给适当的输出链接组件。 还有一种用法将事件调度程序当作计时器。比如，TCP 需要一个计时器记录一个 packet 的发送时间以备重发（发送一个具有相同 TCP 编号且不同 NS packet ID 的 packet）。计时器和延时器用类似的方式使用事件调度程序，不同之处在于计时器计算与 packet 相关的时间值，然后一段特定的时间过去后对该 packet 做合适的动作（如上面那个例子，计算 packet 的发送时间，如果超过预定时间重发该 packet），而不是模拟一个延时， C++ 与 NS2NS2 不仅可以用 OTcl 编写也可以用 C++ 编写。处于效率考量，NS2 将数据路径的实现和控制路径的实现分离开来，为了减少 packet 和事件的处理时间（注意，不是仿真时间），数据路径中的事件调度程序和基本网络组件对象用 C++ 编写然后编译，使用编译好的对象，OTcl 解释器通过一个 OTcl 连接为每一个 C++ 对象创建配对的 OTcl 对象，为成员函数创建配对的控制函数，为成员变量创建配对的配置变量，这样一来，对 C++ 对象的控制就传递给了 OTcl。向一个连接到 OTcl 的 C++ 对象中添加成员函数也是可能的，C++ 对象中不需要在一次模拟中被控制的或者不需要在内部被其他对象使用使用的，是不需要被连接到 OTcl 中。同样地，一个不在数据路径中的对象也可以使用 OTcl 实现。如图为一个对象在 C++ 和 OTcl 中的层次体系，可以看到，连接到 C++ 的 OTcl 对象和它连接的 C++ 对象具有相同的层次结构。 C++ 和 OTcl 的连接 NS2 的大体结构如图为 NS2 的整体结构，使用者站在图中的左下角，在 Tcl 中，使用 OTcl 库中的仿真对象设计并控制模拟。事件调度程序和绝大多数网络组件是通过 C++ 实现的，并且 OTcl 通过 OTcl 连接 (linkage) 可以使用到它们，而这个连接是通过 tclcl 实现的。这些东西共同构成了 NS2，它就是一个扩展了面向对象的 Tcl 解释器和网络模拟库。 NS2 的体系结构图 小结本文简单分析了 NS2 的大体结构和体系结构。现在来考虑下如何获得 NS2 的仿真结果，如第一张图所示，，当仿真结束时，NS2 按照输入的 Tcl（或 OTcl）脚本中的说明产生一个或者多个文本输出文件，其中包含了详细的仿真数据。这些数据可用于后续的仿真分析中，或者作为图形化仿真展示工具 NAM 的输入。 参考：WPI 大学的资源","content":"<p>最近在上一门叫『无线自组织网络与应用』的课程，介绍了很多以前没有接触过的概念，包括了一个叫 NS2 的仿真工具，在前面<a href=\"/2020/03/latex-notes-1-basic-concepts/\">一篇文章</a>中介绍的 AHOHA 协议也是在这门课程中有被详细讲述的。这篇文章基本上是<a href=\"http://nile.wpi.edu.cn/NS/\" target=\"_blank\" rel=\"noopener\">这篇文章</a>的翻译，介绍 NS2 这个仿真工具，给出这个它的概述。<br><a id=\"more\"></a></p>\n<h2 id=\"NS2是什么\"><a href=\"#NS2是什么\" class=\"headerlink\" title=\"NS2是什么\"></a>NS2是什么</h2><p>NS2 是一个使用 C++ 和 OTcl 编写的面向对象的离散事件驱动的网络仿真器，在 UCBerkely 被开发出来。它主要用于局域网和广域网仿真。由于缺少适合新手入门的教程，NS2对于初学者来说不是很友好。</p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>NS2 可以仿真各种各样的IP网络。它实现了一些网络协议如 TCP 和 UDP，文件传输协议如 FTP、Telnet、Web、CBR 和 VBR，路由队列管理机制如 DropTail、RED 和 CBQ，路由选择算法如 Dijkstra，等等。针对局域网仿真，NS2 还实现了组播和一些 MAC 层协议。这里要介绍的是 NS2 的基本结构，然后按照例子介绍细节。</p>\n<p><div align=\"center\" class=\"img\"><br>    <img src=\"/assets/img/2020/structure_of_ns2.png\" alt=\"structure_of_ns2\" width=\"750\"><br>    <span align=\"center\" style=\"color:#999\">用户角度的NS概览</span><br></div><br>NS2 是 OTcl 脚本解释器，包括仿真事件调度程序、网络组件对象库和网络启动 (plumbing) 模块库。plumbing 模块通常实现为基本模拟对象成员函数。换句话说，使用 NS2，你需要使用 OTcl 语言写一个脚本，包括以下内容：</p>\n<ul>\n<li>初始化一个事件调度程序</li>\n<li>使用网络对象和 plumbing 函数建立网络拓扑结构</li>\n<li>通过事件调度程序告知何时开始发送分组</li>\n</ul>\n<h3 id=\"network-object-网络对象\"><a href=\"#network-object-网络对象\" class=\"headerlink\" title=\"network object 网络对象\"></a>network object 网络对象</h3><p>plumbing 函数通过为<em>对象设定指向合适的对象的邻居指针</em>，在网络对象中探索可能的数据通路，进而建立起整个网络。如此一来，使用者想要创建一个新的网络对象变得简单，只需写一个新的对象或者从对象库中创建一个复合对象，然后探索 (plumb) 通过这个新对象的数据通路即可。<br>听起来比较复杂，但是 plumbing OTcl 模块让这一切变得非常简单，这也是 NS2 的强大之处。</p>\n<h3 id=\"event-scheduler-事件调度程序\"><a href=\"#event-scheduler-事件调度程序\" class=\"headerlink\" title=\"event scheduler 事件调度程序\"></a>event scheduler 事件调度程序</h3><p>除网络对象外，NS2 中另一个主要的组件就是事件调度程序。在 NS2 中，一个事件就是一个包 ID，这个 ID 是唯一的，涵盖了分配时间，以及用来处理该事件的指向下一个对象的指针。在 NS2 中，一个事件调度程序<strong>记录着模拟时间</strong>，并通过调用适当的网络组件启动在<strong>事件队列</strong>中调度好的应该在当前启动的所有事件，这些组件通常是发出事件并让事件与事件指出的包一起完成正确的指令。网络组件间进行通信，传递 packet，但是并不会消耗真实的仿真时间。所有需要消耗仿真时间来处理 packet 的网络组件通过使用事件调度程序完成，组件为待处理到packet发出一个事件然后等待组件自己启动事件，再进行进一步的行动处理 packet。</p>\n<p>举个例子，一个网络转发组件S模拟一次转发的延时为 20us，它为一个需要转发的 packet P 向调度程序发出一个延时 20us 的事件 E，20us 后，调度程序 M 从事件队列中调度出这个事件 E 并把它立即发给转发组件 S ，然后由转发组件 S 将 packet P 交给适当的输出链接组件。</p>\n<p>还有一种用法将事件调度程序当作计时器。比如，TCP 需要一个计时器记录一个 packet 的发送时间以备重发（发送一个具有相同 TCP 编号且不同 NS packet ID 的 packet）。计时器和延时器用类似的方式使用事件调度程序，不同之处在于计时器计算与 packet 相关的时间值，然后一段特定的时间过去后对该 packet 做合适的动作（如上面那个例子，计算 packet 的发送时间，如果超过预定时间重发该 packet），而不是模拟一个延时，</p>\n<h2 id=\"C-与-NS2\"><a href=\"#C-与-NS2\" class=\"headerlink\" title=\"C++ 与 NS2\"></a>C++ 与 NS2</h2><p>NS2 不仅可以用 OTcl 编写也可以用 C++ 编写。处于效率考量，NS2 将<strong>数据路径</strong>的实现和<strong>控制路径</strong>的实现分离开来，为了减少 packet 和事件的处理时间（注意，不是仿真时间），数据路径中的事件调度程序和基本网络组件对象用 C++ 编写然后编译，使用编译好的对象，OTcl 解释器通过一个 OTcl 连接为每一个 C++ 对象创建配对的 OTcl 对象，为成员函数创建配对的控制函数，为成员变量创建配对的配置变量，这样一来，对 C++ 对象的控制就传递给了 OTcl。向一个连接到 OTcl 的 C++ 对象中添加成员函数也是可能的，C++ 对象中不需要在一次模拟中被控制的或者不需要在内部被其他对象使用使用的，是不需要被连接到 OTcl 中。同样地，一个不在数据路径中的对象也可以使用 OTcl 实现。如图为一个对象在 C++ 和 OTcl 中的层次体系，可以看到，连接到 C++ 的 OTcl 对象和它连接的 C++ 对象具有相同的层次结构。</p>\n<p align=\"center\" class=\"img\"><br>    <img src=\"/assets/img/2020/cpp_vs_otcl.png\" alt=\"cpp_vs_otcl\" width=\"750\"><br>    <span align=\"center\" style=\"color:#999\">C++ 和 OTcl 的连接</span><br></p>\n\n<h2 id=\"NS2-的大体结构\"><a href=\"#NS2-的大体结构\" class=\"headerlink\" title=\"NS2 的大体结构\"></a>NS2 的大体结构</h2><p>如图为 NS2 的整体结构，使用者站在图中的左下角，在 Tcl 中，使用 OTcl 库中的仿真对象设计并控制模拟。事件调度程序和绝大多数网络组件是通过 C++ 实现的，并且 OTcl 通过 OTcl 连接 (linkage) 可以使用到它们，而这个连接是通过 tclcl 实现的。这些东西共同构成了 NS2，它就是一个扩展了面向对象的 Tcl 解释器和网络模拟库。</p>\n<p align=\"center\" class=\"img\"><br>    <img src=\"/assets/img/2020/architecture_view_of_ns.png\" alt=\"architecture_view_of_ns\" width=\"750\"><br>    <span align=\"center\" style=\"color:#999\">NS2  的体系结构图</span><br></p>\n\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>本文简单分析了 NS2 的大体结构和体系结构。现在来考虑下如何获得 NS2 的仿真结果，如第一张图所示，，当仿真结束时，NS2 按照输入的 Tcl（或 OTcl）脚本中的说明产生一个或者多个文本输出文件，其中包含了详细的仿真数据。这些数据可用于后续的仿真分析中，或者作为图形化仿真展示工具 NAM 的输入。</p>\n<hr>\n<p>参考：<a href=\"http://nile.wpi.edu.cn/NS/\" target=\"_blank\" rel=\"noopener\">WPI 大学的资源</a></p>\n","tags":[{"name":"网络","slug":"网络","permalink":"https://jonathan1214.github.io/tags/网络/"},{"name":"NS2","slug":"NS2","permalink":"https://jonathan1214.github.io/tags/NS2/"}]},{"title":"在疫情中度过三月","date":"2020-03-31T12:14:59.000Z","path":"2020/03/the-third-month/","text":"惊觉已经是三月的最后一天，在这过去的一个月里，如果说有什么一定一提的，那一定是已经持续了快三个月的的新冠肺炎疫情，国内的疫情逐渐被控制住了，国外却又爆发了更大规模的，看起来返校遥遥无期。一月份的时候我肯定无法想象3月31日自己还在家，突发的疫情打乱我原有的计划，我本该在学校的教室里坐着的，现在却在家，本以为会非常非常想回学校，现在倒也还好，我只是怀念学校的WiFi罢了。疫情蔓延全球，经济衰退，股价暴跌，美股数次熔断，不可否认这是一个动荡的三月。所谓『祸兮福之所倚』，被困在山村中的我却得以享受宁静，可以专心做自己想做的事，我重新开始捡起以前学了一点就知难而退的东西，比如 C++，Java，Linux 还有算法，除此之外，我还开始坚持看书、记单词和记录生活，为了督促自己，我还使用 atimelogger 记录自己每一分钟的花销。如果不是因为疫情，我也不会如此百无聊赖，也就不会开始做这些事情，从这个角度而言，对我而言这还是福。 整个三月份，我看完了『乌合之众』、『金字塔原理』、『随机漫步的傻瓜』、『你的第一本哲学书』和『简单逻辑学』，平均一周看了一本多一点的书，还算可以，但是没有对其中任何一本书作一些读后感之类的笔记，算是一个不完整，希望在后面的阅读补上。这一个月也是折腾不断，看了算法看Linux，中间还去折腾下NS2——一坨年久失修的 shit。现在总结一下，算法是没看多少的，刚开始找了不知到哪儿来的一本 Java 算法书，看了一周几乎看完了，然而脑子中似乎什么都没剩下，于是我又照着『算法4』看，这次看得比较慢，加上中途新学期开学了，有很多课要上，到现在也才前两章，综合起来，我现在对排序算法比较清楚了，选择插入希尔归并快排都算了解得清楚了，现在还在继续看下去，第三章是『查找』，会讲到BST等新的数据结构。至于 Linux，照着鸟哥的书慢慢看，有时间就看一章，不求全部记住，只是有个大概概念就行了，现在也看到了 Shell 部分，坚持看下去吧。学这些东西，并不是出于需要，我只是凭借着一时冲动开始看，什么时候我都热情消退了，我也就放弃了，转而投向新的东西。这说是我很长时间来的一种学习态度吧，对于学校规定的课程内容我总感觉不是很有意思，讲授的东西太过陈旧，我会凭借着冲动去随便投入到一些东西中去，既是对自己冲动的满足也是对那些陈旧无聊的知识的逃避。 这个三月我也不是一切顺利，有两次突然陷入了一种极度的焦虑之中，在那种状态下，我什么都不想做，不愿意去做我应该做的事情，只想一直盯着手机看，好在持续一两天之后这种感觉就会很快消失，一切重归正常，但我知道几周后这种感觉又会到来。暂时还没有什么好办法应对这种情况，我只能选择接受它，并在它到来时暂时放下手头的工作，就当是一时的放松，但我坚信会找到办法的。 身处动荡之中，怀抱希望，希望一切都好起来。","content":"<p>惊觉已经是三月的最后一天，在这过去的一个月里，如果说有什么一定一提的，那一定是已经持续了快三个月的的新冠肺炎疫情，国内的疫情逐渐被控制住了，国外却又爆发了更大规模的，看起来返校遥遥无期。一月份的时候我肯定无法想象3月31日自己还在家，突发的疫情打乱我原有的计划，我本该在学校的教室里坐着的，现在却在家，本以为会非常非常想回学校，现在倒也还好，我只是怀念学校的WiFi罢了。<br><a id=\"more\"></a><br>疫情蔓延全球，经济衰退，股价暴跌，美股数次熔断，不可否认这是一个动荡的三月。所谓『祸兮福之所倚』，被困在山村中的我却得以享受宁静，可以专心做自己想做的事，我重新开始捡起以前学了一点就知难而退的东西，比如 C++，Java，Linux 还有算法，除此之外，我还开始坚持看书、记单词和记录生活，为了督促自己，我还使用 atimelogger 记录自己每一分钟的花销。如果不是因为疫情，我也不会如此百无聊赖，也就不会开始做这些事情，从这个角度而言，对我而言这还是福。</p>\n<p>整个三月份，我看完了『乌合之众』、『金字塔原理』、『随机漫步的傻瓜』、『你的第一本哲学书』和『简单逻辑学』，平均一周看了一本多一点的书，还算可以，但是没有对其中任何一本书作一些读后感之类的笔记，算是一个不完整，希望在后面的阅读补上。这一个月也是折腾不断，看了算法看Linux，中间还去折腾下NS2——一坨年久失修的 shit。现在总结一下，算法是没看多少的，刚开始找了不知到哪儿来的一本 Java 算法书，看了一周几乎看完了，然而脑子中似乎什么都没剩下，于是我又照着『算法4』看，这次看得比较慢，加上中途新学期开学了，有很多课要上，到现在也才前两章，综合起来，我现在对排序算法比较清楚了，选择插入希尔归并快排都算了解得清楚了，现在还在继续看下去，第三章是『查找』，会讲到BST等新的数据结构。至于 Linux，照着鸟哥的书慢慢看，有时间就看一章，不求全部记住，只是有个大概概念就行了，现在也看到了 Shell 部分，坚持看下去吧。<br>学这些东西，并不是出于需要，我只是凭借着一时冲动开始看，什么时候我都热情消退了，我也就放弃了，转而投向新的东西。这说是我很长时间来的一种学习态度吧，对于学校规定的课程内容我总感觉不是很有意思，讲授的东西太过陈旧，我会凭借着冲动去随便投入到一些东西中去，既是对自己冲动的满足也是对那些陈旧无聊的知识的逃避。</p>\n<p>这个三月我也不是一切顺利，有两次突然陷入了一种极度的焦虑之中，在那种状态下，我什么都不想做，不愿意去做我应该做的事情，只想一直盯着手机看，好在持续一两天之后这种感觉就会很快消失，一切重归正常，但我知道几周后这种感觉又会到来。暂时还没有什么好办法应对这种情况，我只能选择接受它，并在它到来时暂时放下手头的工作，就当是一时的放松，但我坚信会找到办法的。</p>\n<hr>\n<p>身处动荡之中，怀抱希望，希望一切都好起来。</p>\n","tags":[{"name":"记录","slug":"记录","permalink":"https://jonathan1214.github.io/tags/记录/"},{"name":"monthly","slug":"monthly","permalink":"https://jonathan1214.github.io/tags/monthly/"}]},{"title":"LaTex笔记（一）——基本概念","date":"2020-03-27T04:13:12.000Z","path":"2020/03/latex-notes-1-basic-concepts/","text":"概述Tex是高德纳开发的排版文字和数学公式软件。TeX稳定，跨平台，支持多语言排版，其版本号非常有意思，无限趋近于pi，3.1415926…读作Tech，泰赫。 LaTex是一种格式，可以把LaTex理解成是对TeX的封装。LATeX使用TeX程序作为自己的排版引擎。设计目标是分离内容和格式。读作拉泰赫。 第一份代码1234\\documentclass&#123;article&#125;\\begin&#123;document&#125;``Hello world!'' from \\LaTeX\\end&#123;document&#125; 一份简短的程序，保存为helloworld.tex，然后在命令行下使用xelatex helloworld编译即可。 LaTeX命令和代码结构源代码为文本文件，包括了内容以及命令，可以控制样式，划分文档结构及排版公式。 命令和环境同几乎所有的编程语言一样，LaTeX命令对大小写敏感，命令以\\开头，有两种形式： \\ + 一串字母：如\\LaTex，且任意非字母符号为界限。暂且称其为字母形式。 \\ + 单个非字母符号：如\\$。称其为字符形式。 字母形式的命令忽略其后的所有连续空格，所有的空格都被认为用来标志命令的结束，如果需要空格，使用{}，如\\TeX{} user既可以把空格显示出来，类似于转义。 接受参数。包括可选参数和必选参数，可选参数用[]包裹，必选参数使用{}包裹。带*的命令可看为特殊的可选参数。 环境。可以使一些效果在局部生效，或是生成特殊的文档元素。用法： 123\\begin&#123;&lt;environment name&gt;&#125;[&lt;optional arguments&gt;]&#123;&lt;mandatory arguments&gt;&#125;...\\end&#123;&lt;environment name&gt;&#125; 分组。限制一些命令的作用范围。使用{}作为分组，分组中使用的命令限制在分组内。 源代码结构以\\documentclass{...}命令开头，花括号中指定了文档使用的文档类。有可选参数，可传递给指定文档类，最终作为文档类的参数。 然后在document环境中写文档正文。 123\\begin&#123;document&#125;...\\end&#123;document&#125; 在documentclass和\\begin中间的部分称为导言区。一般在其中使用\\usepackage调用宏包，对文档进行全局设置。 宏包和文档类文档类规定了LaTeX源代码说要生成的文档的性质。documentclass[&lt;options&gt;]{class-name}。 class-name即文档类名，包括LaTeX提供的article、book和report的标准文档类，还有派生出支持中文排版的ctexart，ctexbook，ctexrep，以及一些其他。 options为可选参数，指定文档类的选项，如字号、纸张大小和单双面等等。参数使用逗号分隔。documentclass[11pt,twosides,a4paper]{article}。 标准文档的选项包括：（略多，需要时查看即可）。 宏包用来扩展LaTeX的功能，如插入复杂表格和图片，增加颜色或超链接等等。语法类似使用文档类：usepackage[&lt;options&gt;]{package-names}。可以一次性使用多个宏包，逗号分隔即可。 命令行使用texdoc package-name查看包的使用方法。 LaTeX用到的文件编译使用文件： .sty：宏包文件。 .cls：文档类文件。 .bib：BiBTeX参考文献数据库文件。 .bst：BiBTeX用到的参考文献格式模板。 编译生成文件： .log：日志 .aux：LaTeX生成的主辅助文件，记录交叉引用、目录、参考文献的引用。 .toc：LaTeX生成目录记录文件 .lof：LaTeX生成图片记录 .lot：LaTeX生成表格记录 .bbl .blg .idx .ind .ilg .out 文件的组织方式可将源文件分隔成若干个文件，如将没章的内容单独写在一个文件中，然后使用\\include{&lt;filename&gt;}在源代码里引用即可。注意路径的书写。可以不带扩展名，默认为.tex。 使用\\include会另起一页，使用\\input{filename}避免这种情况。 导言区使用includeonly{&lt;filename1&gt;,&lt;filename2&gt;...}指定正文中可以引用的文件。 实用工具包：syntonly。然后在导言区使用\\syntaxonly，不生成PDF文档，加快编译速度。 注释：使用%。和MATLAB一样。 术语和概念引擎：XeTeX。格式：定义了一组命令的代码集，LaTeX。编译命令：实际调用的、结合引擎和格式的命令，xelatex。 链接：lshort","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>Tex是高德纳开发的排版文字和数学公式软件。TeX稳定，跨平台，支持多语言排版，其版本号非常有意思，无限趋近于pi，3.1415926…读作Tech，泰赫。</p>\n<p>LaTex是一种格式，可以把LaTex理解成是对TeX的封装。LATeX使用TeX程序作为自己的排版引擎。设计目标是分离内容和格式。读作拉泰赫。<br><a id=\"more\"></a></p>\n<h2 id=\"第一份代码\"><a href=\"#第一份代码\" class=\"headerlink\" title=\"第一份代码\"></a>第一份代码</h2><figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">\\<span class=\"name\">documentclass</span><span class=\"string\">&#123;article&#125;</span></span></span><br><span class=\"line\"><span class=\"tag\">\\<span class=\"name\">begin</span><span class=\"string\">&#123;document&#125;</span></span></span><br><span class=\"line\">``Hello world!'' from <span class=\"tag\">\\<span class=\"name\">LaTeX</span></span></span><br><span class=\"line\"><span class=\"tag\">\\<span class=\"name\">end</span><span class=\"string\">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>\n<p>一份简短的程序，保存为<code>helloworld.tex</code>，然后在命令行下使用<code>xelatex helloworld</code>编译即可。</p>\n<h2 id=\"LaTeX命令和代码结构\"><a href=\"#LaTeX命令和代码结构\" class=\"headerlink\" title=\"LaTeX命令和代码结构\"></a>LaTeX命令和代码结构</h2><p>源代码为文本文件，包括了内容以及命令，可以控制样式，划分文档结构及排版公式。</p>\n<h3 id=\"命令和环境\"><a href=\"#命令和环境\" class=\"headerlink\" title=\"命令和环境\"></a>命令和环境</h3><p>同几乎所有的编程语言一样，LaTeX命令对<strong>大小写敏感</strong>，命令以<code>\\</code>开头，有两种形式：</p>\n<ul>\n<li>\\ + 一串字母：如<code>\\LaTex</code>，且任意非字母符号为界限。暂且称其为字母形式。</li>\n<li>\\ + 单个非字母符号：如<code>\\$</code>。称其为字符形式。</li>\n</ul>\n<p>字母形式的命令忽略其后的所有连续空格，所有的空格都被认为用来标志命令的结束，如果需要空格，使用<code>{}</code>，如<code>\\TeX{} user</code>既可以把空格显示出来，类似于<strong>转义</strong>。</p>\n<p>接受参数。包括可选参数和必选参数，可选参数用<code>[]</code>包裹，必选参数使用<code>{}</code>包裹。带<code>*</code>的命令可看为<em>特殊的可选参数</em>。</p>\n<p>环境。可以使一些效果在局部生效，或是生成特殊的文档元素。用法：</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">\\<span class=\"name\">begin</span><span class=\"string\">&#123;&lt;environment name&gt;&#125;</span><span class=\"string\">[&lt;optional arguments&gt;]</span><span class=\"string\">&#123;&lt;mandatory arguments&gt;&#125;</span></span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"tag\">\\<span class=\"name\">end</span><span class=\"string\">&#123;&lt;environment name&gt;&#125;</span></span></span><br></pre></td></tr></table></figure>\n<p>分组。限制一些命令的作用范围。使用<code>{}</code>作为分组，分组中使用的命令限制在分组内。</p>\n<h3 id=\"源代码结构\"><a href=\"#源代码结构\" class=\"headerlink\" title=\"源代码结构\"></a>源代码结构</h3><p>以<code>\\documentclass{...}</code>命令开头，花括号中指定了文档使用的文档类。有可选参数，可传递给指定文档类，最终作为文档类的参数。</p>\n<p>然后在document环境中写文档正文。</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">\\<span class=\"name\">begin</span><span class=\"string\">&#123;document&#125;</span></span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"tag\">\\<span class=\"name\">end</span><span class=\"string\">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>\n<p>在<code>documentclass</code>和<code>\\begin</code>中间的部分称为导言区。一般在其中使用<code>\\usepackage</code>调用宏包，对文档进行全局设置。</p>\n<h2 id=\"宏包和文档类\"><a href=\"#宏包和文档类\" class=\"headerlink\" title=\"宏包和文档类\"></a>宏包和文档类</h2><h3 id=\"文档类\"><a href=\"#文档类\" class=\"headerlink\" title=\"文档类\"></a>文档类</h3><p>规定了LaTeX源代码说要生成的文档的性质。<code>documentclass[&lt;options&gt;]{class-name}</code>。</p>\n<p><code>class-name</code>即文档类名，包括LaTeX提供的article、book和report的<strong>标准文档类</strong>，还有派生出支持中文排版的ctexart，ctexbook，ctexrep，以及一些其他。</p>\n<p><code>options</code>为可选参数，指定文档类的选项，如字号、纸张大小和单双面等等。参数使用逗号分隔。<code>documentclass[11pt,twosides,a4paper]{article}</code>。</p>\n<p>标准文档的选项包括：（略多，需要时查看即可）。</p>\n<h3 id=\"宏包\"><a href=\"#宏包\" class=\"headerlink\" title=\"宏包\"></a>宏包</h3><p>用来扩展LaTeX的功能，如插入复杂表格和图片，增加颜色或超链接等等。语法类似使用文档类：<code>usepackage[&lt;options&gt;]{package-names}</code>。可以一次性使用多个宏包，逗号分隔即可。</p>\n<p>命令行使用<code>texdoc package-name</code>查看包的使用方法。</p>\n<h2 id=\"LaTeX用到的文件\"><a href=\"#LaTeX用到的文件\" class=\"headerlink\" title=\"LaTeX用到的文件\"></a>LaTeX用到的文件</h2><p>编译使用文件：</p>\n<ul>\n<li>.sty：宏包文件。</li>\n<li>.cls：文档类文件。</li>\n<li>.bib：BiBTeX参考文献数据库文件。</li>\n<li>.bst：BiBTeX用到的参考文献格式模板。</li>\n</ul>\n<p>编译生成文件：</p>\n<ul>\n<li>.log：日志</li>\n<li>.aux：LaTeX生成的主辅助文件，记录交叉引用、目录、参考文献的引用。</li>\n<li>.toc：LaTeX生成目录记录文件</li>\n<li>.lof：LaTeX生成图片记录</li>\n<li>.lot：LaTeX生成表格记录</li>\n<li>.bbl</li>\n<li>.blg</li>\n<li>.idx</li>\n<li>.ind</li>\n<li>.ilg</li>\n<li>.out</li>\n</ul>\n<h2 id=\"文件的组织方式\"><a href=\"#文件的组织方式\" class=\"headerlink\" title=\"文件的组织方式\"></a>文件的组织方式</h2><p>可将源文件分隔成若干个文件，如将没章的内容单独写在一个文件中，然后使用<code>\\include{&lt;filename&gt;}</code>在源代码里引用即可。注意路径的书写。可以不带扩展名，默认为.tex。</p>\n<p>使用<code>\\include</code>会另起一页，使用<code>\\input{filename}</code>避免这种情况。</p>\n<p>导言区使用<code>includeonly{&lt;filename1&gt;,&lt;filename2&gt;...}</code>指定正文中可以引用的文件。</p>\n<p>实用工具包：syntonly。然后在导言区使用<code>\\syntaxonly</code>，不生成PDF文档，加快编译速度。</p>\n<p>注释：使用<code>%</code>。和MATLAB一样。</p>\n<h2 id=\"术语和概念\"><a href=\"#术语和概念\" class=\"headerlink\" title=\"术语和概念\"></a>术语和概念</h2><p>引擎：XeTeX。<br>格式：定义了一组命令的代码集，LaTeX。<br>编译命令：实际调用的、结合引擎和格式的命令，xelatex。</p>\n<hr>\n<p>链接：<a href=\"https://mirrors.tuna.tsinghua.edu.cn/CTAN/info/lshort/chinese\" target=\"_blank\" rel=\"noopener\">lshort</a></p>\n","tags":[{"name":"LaTeX","slug":"LaTeX","permalink":"https://jonathan1214.github.io/tags/LaTeX/"}]},{"title":"胡言乱语","date":"2020-03-22T13:39:06.000Z","path":"2020/03/second-week/","text":"没想到有和上周一样，在周一写下上周的日常。不过这次我有话说，不是因为贪玩游戏，实在是因为周六晚上的突发事件打乱了周日的计划，不得已在半夜在农村道路上走上7里路，第二天已经没有精力去写这玩意儿了。翻看上周每天写下的只言片语，我发现若是只给我自己看，那还是有点东西可写的。 无法抵挡的快乐放纵在放纵当时带来的快乐无与伦比，让我无法阻挡，虽然我已经很少体验到放纵的快乐，但我深知它的吸引力是多么强大。放纵对我而言是个什么样的标准呢？一天打上三把游戏已经是放纵了，大概就是这样，那么我可以说周四我放纵了一次。我处于一种完全沉浸式投入的状态，不在乎自己眼睛的疲劳，全心投入，决心赢下当前的比赛，但我还想赢得更多，于是不断地玩下去。最终局数来到了4，花去了2h，我停了下来，没有继续玩下去。因为心心念念着学习知识，我停了下来，放弃了快乐。但是我知道，下一次我还是会沉浸其中，因为它能让我短暂地逃离现实，这是无法抵挡的快乐。 一个平庸的人几乎每天都要上课，老师讲得那些我从来没有听过的知识，但没有多大程度引起我的兴趣，对我而言学习它只是身为学生的一种职责。我被动地接受他们传递过来的东西，OSI参考模型、TCP/IP参考模型、ALOHA随机接入协议还有光纤的若干性质，我几乎没有记下什么东西，但是我尝试去发现其中的规则，那是一种很美的东西，我尝试像一个『一无所知』的人，面对这些问题我能给出什么样的解决方案，大部分时候我什么也发现不了，对于这些问题我也一筹莫展，更别提解决方案，我不过是个平庸的人。 教育使我成为什么样的人？通常我不会想这样的问题，因为只不过是活着而以，不需要赋予人生意义，成为一个什么样的人也许真的无关紧要。周六看了郑强教授的一个视频，让我想考虑下这个问题，但我知道我想不明白的，我只能回顾自己的人生，并尝试从一些事件归纳出自己被教育成一个什么样的人，具体内容慢慢写吧。 我是随机漫步的傻瓜我是个随机漫步的的傻瓜，但是我并没有受到眷顾，所以我还是个彻底的傻瓜。","content":"<p>没想到有和上周一样，在周一写下上周的日常。不过这次我有话说，不是因为贪玩游戏，实在是因为周六晚上的突发事件打乱了周日的计划，不得已在半夜在农村道路上走上7里路，第二天已经没有精力去写这玩意儿了。翻看上周每天写下的只言片语，我发现若是只给我自己看，那还是有点东西可写的。<br><a id=\"more\"></a></p>\n<h2 id=\"无法抵挡的快乐\"><a href=\"#无法抵挡的快乐\" class=\"headerlink\" title=\"无法抵挡的快乐\"></a>无法抵挡的快乐</h2><p>放纵在放纵当时带来的快乐无与伦比，让我无法阻挡，虽然我已经很少体验到放纵的快乐，但我深知它的吸引力是多么强大。放纵对我而言是个什么样的标准呢？一天打上三把游戏已经是放纵了，大概就是这样，那么我可以说周四我放纵了一次。我处于一种完全沉浸式投入的状态，不在乎自己眼睛的疲劳，全心投入，决心赢下当前的比赛，但我还想赢得更多，于是不断地玩下去。最终局数来到了4，花去了2h<br>，我停了下来，没有继续玩下去。因为心心念念着学习知识，我停了下来，放弃了快乐。但是我知道，下一次我还是会沉浸其中，因为它能让我短暂地逃离现实，这是无法抵挡的快乐。</p>\n<h2 id=\"一个平庸的人\"><a href=\"#一个平庸的人\" class=\"headerlink\" title=\"一个平庸的人\"></a>一个平庸的人</h2><p>几乎每天都要上课，老师讲得那些我从来没有听过的知识，但没有多大程度引起我的兴趣，对我而言学习它只是身为学生的一种职责。我被动地接受他们传递过来的东西，OSI参考模型、TCP/IP参考模型、ALOHA随机接入协议还有光纤的若干性质，我几乎没有记下什么东西，但是我尝试去发现其中的规则，那是一种很美的东西，我尝试像一个『一无所知』的人，面对这些问题我能给出什么样的解决方案，大部分时候我什么也发现不了，对于这些问题我也一筹莫展，更别提解决方案，我不过是个平庸的人。</p>\n<h2 id=\"教育使我成为什么样的人？\"><a href=\"#教育使我成为什么样的人？\" class=\"headerlink\" title=\"教育使我成为什么样的人？\"></a>教育使我成为什么样的人？</h2><p>通常我不会想这样的问题，因为只不过是活着而以，不需要赋予人生意义，成为一个什么样的人也许真的无关紧要。周六看了郑强教授的一个视频，让我想考虑下这个问题，但我知道我想不明白的，我只能回顾自己的人生，并尝试从一些事件归纳出自己被教育成一个什么样的人，具体内容慢慢写吧。</p>\n<h2 id=\"我是随机漫步的傻瓜\"><a href=\"#我是随机漫步的傻瓜\" class=\"headerlink\" title=\"我是随机漫步的傻瓜\"></a>我是随机漫步的傻瓜</h2><p>我是个随机漫步的的傻瓜，但是我并没有受到眷顾，所以我还是个彻底的傻瓜。</p>\n","tags":[{"name":"记录","slug":"记录","permalink":"https://jonathan1214.github.io/tags/记录/"},{"name":"weekly","slug":"weekly","permalink":"https://jonathan1214.github.io/tags/weekly/"}]},{"title":"信道共享技术简述与ALOHA的仿真","date":"2020-03-21T08:04:28.000Z","path":"2020/03/channel-sharing-and-aloha-imulation/","text":"MAC（Media Access Control）协议，即介质访问控制协议。MAC层需要实现数据帧的封装卸装、帧寻址和识别、帧的接受和发送、链路的管理和帧的差错控制等。屏蔽了不同物理链路的种类差异性。其核心是对有限物理资源的高效利用。在Ad Hoc网络中，由于其无中心和使用无线信道等特点，新带来的问题有：选择什么样的信道共享方式，如何处理终端暴露问题，如何隐藏终端，以及如何处理节点移动带来的影响。因而对MAC协议的要求更高。本文将探讨简单的信道共享技术，并对动态接入协议ALOHA进行分析和MATLAB仿真。 信道共享技术分类信道共享技术又称为多点接入技术，原理是通过一个专用信道将所有的用户连接起来。按照多个用户与一个主机连接的访问方法来划分，信道共享技术可以分为通过集中器或复用器相连和直接相连，前者即信道复用，后者又可分为受控接入和随机接入。 信道复用 受控接入 随机接入 信道复用这是一种应用的比较成熟的技术，集中器或复用器按顺序不断扫描各个端口，或采用中断技术来接受用户信息或转发。如FDM，TDM，CDM，WDM和STDM。考虑一个实际例子：两个用户A和B，都需要需要发送信息；如果采用FDM方式，则分别为A和B分配一条不同频率的信道，允许二者一起发送而不产生冲突；如果采用TDM方式，则A和B的数据帧交给集中器，集中器把二者的帧放在不同的时隙发送然后发送，也可以避免冲突。这可以通过集中器扫描，也可以通过用户发送请求产生中断来执行。其实这就是一种静态的信道分配，按频率、时间或码字对信道进行划分。显然，这会造成资源的浪费。 受控接入受控接入方式的网络拓扑是环型结构，分为集中式控制和分散式控制。集中式控制使用轮询方法，主机按顺序逐个询问各站是否有数据需要发送。分散式控制即使用令牌，在环路中有一个特殊的帧——『令牌』，沿着环路传递，只有获得了令牌的站才有权发送信息。 随机接入随机接入方式的网络拓扑是总线型结构，所有的站点可随时发送数据，争用信道，容易产生冲突，经典的协议有ALOHA，CSMA和CSMA/CD。 信道的静态和动态分配信道的静态分配即将信道资源N等分，这个资源包括时隙（slot）、频谱（frequency）和码字（code），适用于用户数量少、数据量大的情况。这种信道的分配方式在某系情况下是不合理，它不能满足用户对资源占用的不同需求，效率低，不合适多站点，不适于突发性数据。 信道的动态分配使用多路访问协议，动态分配信道资源提高信道利用率。可以这么理解：不对信道资源进行划分，用户产生了需求就进行处理，处理时占用全部的信道资源。这么做不可避免的会产生信道争用和冲突问题，可以牺牲一点自由，使用受控接入方式可以隐藏争用问题和解决冲突问题。或者可以直面信道争用和冲突，使用随机接入方式，其中一个重要的协议就是ALOHA。 从一个更高的角度上来看，信道复用技术是一种信道的静态分配技术，受控接入和随机接入是一种信道的动态分配技术。 ALOHA前面讲到，ALOHA协议是一种信道的动态分配协议，它实现了信道共享方式中的一种随机接入技术。在这种动态分配的方式下，信道有三种状态，传输，空闲和竞争，所有的站点都通过同一信道发送或接受帧，某一特定时刻只允许一个站点使用信道。 以一个数据帧A的发送为例，考虑其如何才能成功发送。发送时机有两种选择，连续时间或时间片，前者允许在任意时刻发送，后者将时间用时钟分离为片段，帧只允许在每一个片段开始瞬间发生。若是以连续时间发送，帧发送时，若信道是空闲状态，则成功开始发送帧，此时信道为传输状态，假设在帧发送时间内又有数据帧B的发送请求产生，则信道进入竞争状态，产生了冲突，帧A发送失败，帧B也发送失败，都需要重传，二者分别随机等待一段时间，然后进行发送，直到发送成功。 纯ALOHA帧传输示意图我们把以连续时间发送的称为纯ALOHA（pure ALOHA），按时间片发送到称为时隙ALOHA（slotted ALOHA），下面对它们的信道利用率进行分析。 pure ALOHA 信道利用率分析首先考虑pure ALOHA中一帧发送成功的条件，假设帧长固定，发送所需时间为T，则不难推知发送成功的条件为该帧发送前后各有一段T时间内没有其他帧发送，如下图所示。 纯ALOHA的帧发送成功条件 对其信道利用率分析我们先要确定一些条件： 假设：帧长固定，无限用户，按泊松分布产生新的数据帧。 网络负载为G，表示在T内总共发送的平均帧数，包括发送成功的帧和因碰撞未发送成功的帧。 吞吐率为S，表示在帧的发送时间T内成功发送的平均帧数。 简单分析可知，0&lt;=S&lt;=1，S=0表示在信道上无成功发送的数据；S=1表示数据帧一个接一个发送，这是不可能的。G只有在不发送碰撞时才和S相等，且可以远大于1。 我们研究信道利用率，就是要考虑在什么的样的网络负载下，能够取得最大的吞吐率，并且要知道这个最大的吞吐率。 对这个问题进行理论分析并不困难，稳定情况下，S=G*P[发送成功]，求出一个数据帧发送成功概率P即可，由前面的分析可知，当前帧要想发送成功，以为着当前时刻的前后T时间内，共2T时间内，没有其他数据帧的发送请求产生，按照数据帧的产生数或者说数据帧请求产生数在T时间内服从参数为G的泊松分布，不难得出P[发送成功]=((2G)^0/0!)*e^(-2G)，则吞吐率S=G*P[发送成功]=G*e^(-2G)，求极值可知，当G=0.5时，S取最大值0.184，非常小。 对这个过程进行MATLAB仿真并不难，具体思路如下：产生一系列值的G，对每一个帧，产生若干个服从参数为G的泊松分布随机数，若连续的前后两个随机数和为0，则表示发送成功，统计发送成功的数占所有随机数的比即为该负载G下发送成功的概率，在和G相乘求得此时的吞吐率S，对每一个G都这么求即可得出一系列的(G,S)，再使用plot作出图像，如下所示： 纯ALOHA的信道吞吐率与网络负载的关系 slotted ALOHA 信道利用率分析时隙ALOHA协议下，将信道时间划分为离散的时间隙，隙长为一个帧所需的发送时间，每个站点只能在时隙开始时才允许发。 分析信道利用率时，条件和纯ALOHA相同。重点也是在考虑发送成功的概率，在时隙ALOHA协议下，当前帧发送成功的条件为：当前发送时隙前的一个时隙T内没有新的数据帧发送请求产生。事实上，由于只允许在时隙开始时发送请求，站点发送的数据帧都是积攒下来的。可以求出P[发送成功]=(G^0/0!)*e^(-G)，S=G*e^(-G)，当G=1时，S取最大值0.368，是纯ALOHA的2倍，但还是不够高。仿真思路同纯ALOHA，最后作出的S-G图像如下所示： 时隙ALOHA的信道吞吐率与网络负载的关系 附MATLAB仿真代码：aloha_.mview raw12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455clear all;clc;% ALOHA 仿真% 网络负载G% 成功发送条件，请求为0T = 100000; % 仿真时间 1000个帧长load_scale = 0.1;G = 0:load_scale:5; % 网络负载requests = zeros(T+1, size(G,2)); % 请求次数pure_ALOHA_sucess = zeros(1,size(G,2)); % pure ALOHA成功次数slotted_ALOHA_sucess = zeros(1,size(G,2)); % slotted ALOHA% 产生请求for g = 1:size(G,2) requests(:,g) = random('Poisson',G(g),T+1,1);end% pure ALOHAfor g = 1:size(G,2) for index = 1:T if requests(index,g) + requests(index+1,g) == 0 pure_ALOHA_sucess(g) = pure_ALOHA_sucess(g) + 1; end if requests(index,g) == 0 slotted_ALOHA_sucess(g) = slotted_ALOHA_sucess(g) + 1; end endend%% calculate% pure ALOHAprobl_pure_ALOHA = pure_ALOHA_sucess / T; % 成功概率S_pure_ALOHA = G.*probl_pure_ALOHA; % 吞吐率% slotted ALOHAprobl_slotted_ALOHA = slotted_ALOHA_sucess / T;S_slotted_ALOHA = G.*probl_slotted_ALOHA;%% plot% purefigure(1)yyaxis leftplot(G,probl_pure_ALOHA)ylabel('Probablity of Sucess')yyaxis rightplot(G,S_pure_ALOHA)title('Average Throughput of Pure ALOHA')xlabel('G')ylabel('Average Throughput')grid on% slottedfigure(2)yyaxis leftplot(G,probl_slotted_ALOHA)ylabel('Probablity of Sucess')yyaxis rightplot(G,S_slotted_ALOHA)title('Average Throughput of Slotted ALOHA')xlabel('G')ylabel('Average Throughput')grid on","content":"<p>MAC（Media Access Control）协议，即介质访问控制协议。MAC层需要实现数据帧的封装卸装、帧寻址和识别、帧的接受和发送、链路的管理和帧的差错控制等。屏蔽了不同物理链路的种类差异性。其核心是<strong>对有限物理资源的高效利用</strong>。在Ad Hoc网络中，由于其无中心和使用无线信道等特点，新带来的问题有：选择什么样的信道共享方式，如何处理终端暴露问题，如何隐藏终端，以及如何处理节点移动带来的影响。因而对MAC协议的要求更高。本文将探讨简单的信道共享技术，并对动态接入协议<code>ALOHA</code>进行分析和<br>MATLAB仿真。<br><a id=\"more\"></a></p>\n<h2 id=\"信道共享技术分类\"><a href=\"#信道共享技术分类\" class=\"headerlink\" title=\"信道共享技术分类\"></a>信道共享技术分类</h2><p>信道共享技术又称为多点接入技术，原理是通过一个专用信道将所有的用户连接起来。按照多个用户与一个主机连接的访问方法来划分，信道共享技术可以分为通过集中器或复用器相连和直接相连，前者即信道复用，后者又可分为受控接入和随机接入。</p>\n<ul>\n<li><a href=\"#信道复用\">信道复用</a></li>\n<li><a href=\"#受控接入\">受控接入</a></li>\n<li><a href=\"#随机接入\">随机接入</a></li>\n</ul>\n<h3 id=\"信道复用\"><a href=\"#信道复用\" class=\"headerlink\" title=\"信道复用\"></a>信道复用</h3><p>这是一种应用的比较成熟的技术，集中器或复用器按顺序不断扫描各个端口，或采用中断技术来接受用户信息或转发。如<code>FDM</code>，<code>TDM</code>，<code>CDM</code>，<code>WDM</code>和<code>STDM</code>。<br>考虑一个实际例子：两个用户A和B，都需要需要发送信息；如果采用FDM方式，则分别为A和B分配一条不同频率的信道，允许二者一起发送而不产生冲突；如果采用TDM方式，则A和B的数据帧交给集中器，集中器把二者的帧放在不同的时隙发送然后发送，也可以避免冲突。这可以通过集中器扫描，也可以通过用户发送请求产生中断来执行。<br>其实这就是一种静态的信道分配，按频率、时间或码字对信道进行划分。显然，这会造成资源的浪费。</p>\n<h3 id=\"受控接入\"><a href=\"#受控接入\" class=\"headerlink\" title=\"受控接入\"></a>受控接入</h3><p>受控接入方式的网络拓扑是环型结构，分为集中式控制和分散式控制。集中式控制使用轮询方法，主机按顺序逐个询问各站是否有数据需要发送。分散式控制即使用令牌，在环路中有一个特殊的帧——『令牌』，沿着环路传递，只有获得了令牌的站才有权发送信息。</p>\n<h3 id=\"随机接入\"><a href=\"#随机接入\" class=\"headerlink\" title=\"随机接入\"></a>随机接入</h3><p>随机接入方式的网络拓扑是总线型结构，所有的站点可随时发送数据，争用信道，容易产生冲突，经典的协议有ALOHA，CSMA和CSMA/CD。</p>\n<h3 id=\"信道的静态和动态分配\"><a href=\"#信道的静态和动态分配\" class=\"headerlink\" title=\"信道的静态和动态分配\"></a>信道的静态和动态分配</h3><p>信道的静态分配即将信道资源N等分，这个资源包括时隙（slot）、频谱（frequency）和码字（code），适用于用户数量少、数据量大的情况。这种信道的分配方式在某系情况下是不合理，它不能满足用户对资源占用的不同需求，效率低，不合适多站点，不适于突发性数据。</p>\n<p>信道的动态分配使用多路访问协议，动态分配信道资源提高信道利用率。可以这么理解：不对信道资源进行划分，用户产生了需求就进行处理，处理时占用全部的信道资源。这么做不可避免的会产生信道争用和冲突问题，可以牺牲一点自由，使用受控接入方式可以隐藏争用问题和解决冲突问题。或者可以直面信道争用和冲突，使用随机接入方式，其中一个重要的协议就是ALOHA。</p>\n<p>从一个更高的角度上来看，信道复用技术是一种信道的静态分配技术，受控接入和随机接入是一种信道的动态分配技术。</p>\n<h2 id=\"ALOHA\"><a href=\"#ALOHA\" class=\"headerlink\" title=\"ALOHA\"></a>ALOHA</h2><p>前面讲到，ALOHA协议是一种信道的动态分配协议，它实现了信道共享方式中的一种随机接入技术。在这种动态分配的方式下，信道有三种状态，<code>传输</code>，<code>空闲</code>和<code>竞争</code>，所有的站点都通过同一信道发送或接受帧，某一特定时刻只允许一个站点使用信道。</p>\n<p>以一个数据帧A的发送为例，考虑其如何才能成功发送。发送时机有两种选择，连续时间或时间片，前者允许在任意时刻发送，后者将时间用时钟分离为片段，帧只允许在每一个片段开始瞬间发生。若是以连续时间发送，帧发送时，若信道是空闲状态，则成功开始发送帧，此时信道为传输状态，假设在帧发送时间内又有数据帧B的发送请求产生，则信道进入竞争状态，产生了<em>冲突</em>，帧A发送失败，帧B也发送失败，都需要重传，二者分别随机等待一段时间，然后进行发送，直到发送成功。</p>\n<p><div align=\"center\" class=\"img\"><br>    <img src=\"/assets/img/2020/aloha_principle_illustration.png\" alt=\"aloha_principle_illustration\" width=\"750\"><br>    <span align=\"center\" style=\"color:#999\">纯ALOHA帧传输示意图</span><br></div><br>我们把以连续时间发送的称为纯ALOHA（pure ALOHA），按时间片发送到称为时隙ALOHA（slotted ALOHA），下面对它们的信道利用率进行分析。</p>\n<h3 id=\"pure-ALOHA-信道利用率分析\"><a href=\"#pure-ALOHA-信道利用率分析\" class=\"headerlink\" title=\"pure ALOHA 信道利用率分析\"></a>pure ALOHA 信道利用率分析</h3><p>首先考虑<code>pure ALOHA</code>中一帧发送成功的条件，假设帧长固定，发送所需时间为T，则不难推知发送成功的条件为<strong>该帧发送前后各有一段T时间内没有其他帧发送</strong>，如下图所示。</p>\n<p align=\"center\" class=\"img\"><br><img src=\"/assets/img/2020/aloha_success.png\" alt=\"pure_aloha_success\" width=\"750\"><br>    <span align=\"center\" style=\"color:#999\">纯ALOHA的帧发送成功条件</span><br></p>\n\n<p>对其信道利用率分析我们先要确定一些条件：</p>\n<ul>\n<li>假设：帧长固定，无限用户，按泊松分布产生新的数据帧。</li>\n<li>网络负载为G，表示在T内总共发送的平均帧数，包括发送成功的帧和因碰撞未发送成功的帧。</li>\n<li>吞吐率为S，表示在帧的发送时间T内成功发送的平均帧数。</li>\n</ul>\n<p>简单分析可知，0&lt;=S&lt;=1，S=0表示在信道上无成功发送的数据；S=1表示数据帧一个接一个发送，这是不可能的。G只有在不发送碰撞时才和S相等，且可以远大于1。</p>\n<p>我们研究信道利用率，就是要考虑在什么的样的网络负载下，能够取得最大的吞吐率，并且要知道这个最大的吞吐率。</p>\n<p>对这个问题进行理论分析并不困难，稳定情况下，<code>S=G*P[发送成功]</code>，求出一个数据帧发送成功概率P即可，由前面的分析可知，当前帧要想发送成功，以为着当前时刻的前后T时间内，共2T时间内，没有其他数据帧的发送请求产生，按照数据帧的产生数或者说数据帧请求产生数在T时间内服从参数为G的泊松分布，不难得出<code>P[发送成功]=((2G)^0/0!)*e^(-2G)</code>，则吞吐率<code>S=G*P[发送成功]=G*e^(-2G)</code>，求极值可知，当G=0.5时，S取最大值0.184，非常小。</p>\n<p>对这个过程进行MATLAB仿真并不难，具体思路如下：产生一系列值的G，对每一个帧，产生若干个服从参数为G的泊松分布随机数，若连续的前后两个随机数和为0，则表示发送成功，统计发送成功的数占所有随机数的比即为该负载G下发送成功的概率，在和G相乘求得此时的吞吐率S，对每一个G都这么求即可得出一系列的(G,S)，再使用plot作出图像，如下所示：</p>\n<p align=\"center\" class=\"img\"><br><img src=\"/assets/img/2020/pure_aloha.jpg\" alt=\"pure_aloha\" width=\"750\"><br>    <span align=\"center\" style=\"color:#999\">纯ALOHA的信道吞吐率与网络负载的关系</span><br></p>\n\n<h3 id=\"slotted-ALOHA-信道利用率分析\"><a href=\"#slotted-ALOHA-信道利用率分析\" class=\"headerlink\" title=\"slotted ALOHA 信道利用率分析\"></a>slotted ALOHA 信道利用率分析</h3><p>时隙ALOHA协议下，将信道时间划分为离散的时间隙，隙长为一个帧所需的发送时间，每个站点只能在时隙开始时才允许发。</p>\n<p>分析信道利用率时，条件和纯ALOHA相同。重点也是在考虑发送成功的概率，在时隙ALOHA协议下，当前帧发送成功的条件为：当前发送时隙前的一个时隙T内没有新的数据帧发送请求产生。事实上，由于只允许在时隙开始时发送请求，站点发送的数据帧都是积攒下来的。可以求出<code>P[发送成功]=(G^0/0!)*e^(-G)</code>，<code>S=G*e^(-G)</code>，当G=1时，S取最大值0.368，是纯ALOHA的2倍，但还是不够高。<br>仿真思路同纯ALOHA，最后作出的S-G图像如下所示：</p>\n<p align=\"center\" class=\"img\"><br>    <img src=\"/assets/img/2020/slotted_aloha.jpg\" alt=\"slotted_aloha\" width=\"750\"><br>    <span align=\"center\" style=\"color:#999\">时隙ALOHA的信道吞吐率与网络负载的关系</span><br></p>\n\n<p>附MATLAB仿真代码：<br><figure class=\"highlight matlab\"><figcaption><span>aloha_.m</span><a href=\"/downloads/code/aloha_.m\">view raw</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clear all;clc;</span><br><span class=\"line\"><span class=\"comment\">% ALOHA 仿真</span></span><br><span class=\"line\"><span class=\"comment\">% 网络负载G</span></span><br><span class=\"line\"><span class=\"comment\">% 成功发送条件，请求为0</span></span><br><span class=\"line\">T = <span class=\"number\">100000</span>;   <span class=\"comment\">% 仿真时间 1000个帧长</span></span><br><span class=\"line\">load_scale = <span class=\"number\">0.1</span>;</span><br><span class=\"line\">G = <span class=\"number\">0</span>:load_scale:<span class=\"number\">5</span>; <span class=\"comment\">% 网络负载</span></span><br><span class=\"line\">requests = <span class=\"built_in\">zeros</span>(T+<span class=\"number\">1</span>, <span class=\"built_in\">size</span>(G,<span class=\"number\">2</span>)); <span class=\"comment\">% 请求次数</span></span><br><span class=\"line\">pure_ALOHA_sucess = <span class=\"built_in\">zeros</span>(<span class=\"number\">1</span>,<span class=\"built_in\">size</span>(G,<span class=\"number\">2</span>)); <span class=\"comment\">% pure ALOHA成功次数</span></span><br><span class=\"line\">slotted_ALOHA_sucess = <span class=\"built_in\">zeros</span>(<span class=\"number\">1</span>,<span class=\"built_in\">size</span>(G,<span class=\"number\">2</span>)); <span class=\"comment\">% slotted ALOHA</span></span><br><span class=\"line\"><span class=\"comment\">% 产生请求</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> g = <span class=\"number\">1</span>:<span class=\"built_in\">size</span>(G,<span class=\"number\">2</span>)</span><br><span class=\"line\">    requests(:,g) = random(<span class=\"string\">'Poisson'</span>,G(g),T+<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"comment\">% pure ALOHA</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> g = <span class=\"number\">1</span>:<span class=\"built_in\">size</span>(G,<span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> index = <span class=\"number\">1</span>:T</span><br><span class=\"line\">       <span class=\"keyword\">if</span> requests(index,g) + requests(index+<span class=\"number\">1</span>,g) == <span class=\"number\">0</span></span><br><span class=\"line\">           pure_ALOHA_sucess(g) = pure_ALOHA_sucess(g) + <span class=\"number\">1</span>;</span><br><span class=\"line\">       <span class=\"keyword\">end</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> requests(index,g) == <span class=\"number\">0</span></span><br><span class=\"line\">           slotted_ALOHA_sucess(g) = slotted_ALOHA_sucess(g) + <span class=\"number\">1</span>;</span><br><span class=\"line\">       <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"comment\">%% calculate</span></span><br><span class=\"line\"><span class=\"comment\">% pure ALOHA</span></span><br><span class=\"line\">probl_pure_ALOHA = pure_ALOHA_sucess / T; <span class=\"comment\">% 成功概率</span></span><br><span class=\"line\">S_pure_ALOHA = G.*probl_pure_ALOHA;       <span class=\"comment\">% 吞吐率</span></span><br><span class=\"line\"><span class=\"comment\">% slotted ALOHA</span></span><br><span class=\"line\">probl_slotted_ALOHA = slotted_ALOHA_sucess / T;</span><br><span class=\"line\">S_slotted_ALOHA = G.*probl_slotted_ALOHA;</span><br><span class=\"line\"><span class=\"comment\">%% plot</span></span><br><span class=\"line\"><span class=\"comment\">% pure</span></span><br><span class=\"line\">figure(<span class=\"number\">1</span>)</span><br><span class=\"line\">yyaxis left</span><br><span class=\"line\">plot(G,probl_pure_ALOHA)</span><br><span class=\"line\">ylabel(<span class=\"string\">'Probablity of Sucess'</span>)</span><br><span class=\"line\">yyaxis right</span><br><span class=\"line\">plot(G,S_pure_ALOHA)</span><br><span class=\"line\">title(<span class=\"string\">'Average Throughput of Pure ALOHA'</span>)</span><br><span class=\"line\">xlabel(<span class=\"string\">'G'</span>)</span><br><span class=\"line\">ylabel(<span class=\"string\">'Average Throughput'</span>)</span><br><span class=\"line\">grid on</span><br><span class=\"line\"><span class=\"comment\">% slotted</span></span><br><span class=\"line\">figure(<span class=\"number\">2</span>)</span><br><span class=\"line\">yyaxis left</span><br><span class=\"line\">plot(G,probl_slotted_ALOHA)</span><br><span class=\"line\">ylabel(<span class=\"string\">'Probablity of Sucess'</span>)</span><br><span class=\"line\">yyaxis right</span><br><span class=\"line\">plot(G,S_slotted_ALOHA)</span><br><span class=\"line\">title(<span class=\"string\">'Average Throughput of Slotted ALOHA'</span>)</span><br><span class=\"line\">xlabel(<span class=\"string\">'G'</span>)</span><br><span class=\"line\">ylabel(<span class=\"string\">'Average Throughput'</span>)</span><br><span class=\"line\">grid on</span><br></pre></td></tr></table></figure></p>\n","tags":[{"name":"网络","slug":"网络","permalink":"https://jonathan1214.github.io/tags/网络/"},{"name":"MAC协议","slug":"MAC协议","permalink":"https://jonathan1214.github.io/tags/MAC协议/"},{"name":"MATLAB","slug":"MATLAB","permalink":"https://jonathan1214.github.io/tags/MATLAB/"}]},{"title":"新学期的第一周","date":"2020-03-15T12:15:57.000Z","path":"2020/03/first-week-record-of-new-term/","text":"震惊的Joey 不知不觉间大三已经过完一半，想起在过去的两年半中好像没有值得纪念的事，有点无可奈何，但要说没有发生那么一件在当时让我很有感触的事，当然也不可能，只是我以为自己的记忆会帮我保存那些真正重要的感觉，因此没有记录，但是这样的事怎么会有那么多呢？亲人故去、终有所成之类的记忆深刻的事不常发生，更多的是生活中有感触的小事，它们发生很触动我，但它们又是那么不起眼，不久后我就会忘记。过去的都过去了，不过现在我不想就让现在的它们被遗忘，我要尽可能地记录。 新学期的第一周也就这么过去了，或者说新学期的第三周就这么过去了，因为疫情耽搁在家没法返校，导致前两周的电工实习没法线下上也没法在线上操作，因此前两周没课，所以这一周才算是我的新学期第一周，没有开始上课怎么能叫新学期呢？不管怎么算，这一周的的确确就这么过去了。 新学期的前三门课过去的一周里，我上了三门课：《计算机通信网络》、《无线自组织网络与应用》和《光通信网络》。每科两节课，一共是六节课。三位老师都很有意思，有说自己从教一纪不知点名为何物的，有网课平台整三四个的，课下还提醒你『你啥时候进的直播啥时候出去我这都有记录，那些进来签个到就走了的同学自己注意点』，也有正常上课群里发『1』签到的。抛开这些不说，老师们课上得挺好。 atimelogger 记录每一分钟周一晚上突然翻到这个自己两年前就下载过的APP————atimelogger，这是一个记录自己每一分钟用在何处的APP，我决定不再试一把，尝试记录自己每一分钟用在何处。从周二开始，这一周每一天我都几乎记录下了自己的每一分钟，这种感觉很奇妙，当你做什么的时候，你会意识到有一个时钟在走，你会不由自主地集中注意力，想要它走慢一点或者抓紧利用这有限的时间。后面我想，不管它在不在，我的生命时钟都在不停地走，不知道在某一天就会停下来，因为它是如此的不可感知，我很少注意到它，但是这个APP帮助我意识到了，它具象了我的生命时钟，让我感受到我的时间在不断消耗，我必须抓紧每一分钟。atimelogger上的记录显示：我每天都花了30~40分钟玩2K19；每天晚上我都会看一集『老友记』，用时22分钟；每天都会记单词，用时20~30分钟；每天我都至少在『微信读书』APP上看了1h书；每天我都至少在床上睡了8个小时；每天我都至少在学习成长上花了6h。我开始喜欢上这种记录的感觉。 重启 Blog周四晚上折腾了一晚，重启Blog，后面几天也在不断完善，终于到了现在这个样子。换了站点的头像，给站点添加了访问人数统计，为每一篇博文添加阅读数统计，在此感谢不蒜子大佬的脚本。周六晚上还添加了相册，到周日晚上，终于可以正常使用了。关于重启博客我是这样想的，上个月我就重启了『记录计划』，只是在手机上写，既然都要记录，为什么不放到网上呢？这样还方便查看，而且我会更有动力去写，Blog是一个比较好的选择。 话不多说，以上就是这一周，关于上的这些课的具体内容我会在后面的文章中详细记录。这些网络类的课很有意思，它们有一种规则的美感，我想如果能自己亲手制定某些规则并加以实现肯定让人兴奋。生活总是有很多的不确定，但我确定关于『记录』这件事我会坚持下去。","content":"<p></p><p align=\"center\" class=\"img\"><br>    <img src=\"/assets/img/2020/astonished_joey.jpg\" alt=\"astonished_joey\" width=\"750\"><br>    <span align=\"center\" style=\"color:#999\">震惊的Joey</span></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><p></p></h2><p>不知不觉间大三已经过完一半，想起在过去的两年半中好像没有值得纪念的事，有点无可奈何，但要说没有发生那么一件在当时让我很有感触的事，当然也不可能，只是我以为自己的记忆会帮我保存那些真正重要的感觉，因此没有记录，但是这样的事怎么会有那么多呢？亲人故去、终有所成之类的记忆深刻的事不常发生，更多的是生活中有感触的小事，它们发生很触动我，但它们又是那么不起眼，不久后我就会忘记。过去的都过去了，不过现在我不想就让现在的它们被遗忘，我要尽可能地记录。<br><a id=\"more\"></a></p>\n<p>新学期的第一周也就这么过去了，或者说新学期的第三周就这么过去了，因为疫情耽搁在家没法返校，导致前两周的电工实习没法线下上也没法在线上操作，因此前两周没课，所以这一周才算是我的新学期第一周，没有开始上课怎么能叫新学期呢？不管怎么算，这一周的的确确就这么过去了。</p>\n<h2 id=\"新学期的前三门课\"><a href=\"#新学期的前三门课\" class=\"headerlink\" title=\"新学期的前三门课\"></a>新学期的前三门课</h2><p>过去的一周里，我上了三门课：《计算机通信网络》、《无线自组织网络与应用》和《光通信网络》。每科两节课，一共是六节课。三位老师都很有意思，有说自己从教一纪不知点名为何物的，有网课平台整三四个的，课下还提醒你『你啥时候进的直播啥时候出去我这都有记录，那些进来签个到就走了的同学自己注意点』，也有正常上课群里发『1』签到的。抛开这些不说，老师们课上得挺好。</p>\n<h2 id=\"atimelogger-记录每一分钟\"><a href=\"#atimelogger-记录每一分钟\" class=\"headerlink\" title=\"atimelogger 记录每一分钟\"></a>atimelogger 记录每一分钟</h2><p>周一晚上突然翻到这个自己两年前就下载过的APP————atimelogger，这是一个记录自己每一分钟用在何处的APP，我决定不再试一把，尝试记录自己每一分钟用在何处。从周二开始，这一周每一天我都几乎记录下了自己的每一分钟，这种感觉很奇妙，当你做什么的时候，你会意识到有一个时钟在走，你会不由自主地集中注意力，想要它走慢一点或者抓紧利用这有限的时间。后面我想，不管它在不在，我的生命时钟都在不停地走，不知道在某一天就会停下来，因为它是如此的不可感知，我很少注意到它，但是这个APP帮助我意识到了，它具象了我的生命时钟，让我感受到我的时间在不断消耗，我必须抓紧每一分钟。<br>atimelogger上的记录显示：我每天都花了30~40分钟玩2K19；每天晚上我都会看一集『老友记』，用时22分钟；每天都会记单词，用时20~30分钟；每天我都至少在『微信读书』APP上看了1h书；每天我都至少在床上睡了8个小时；每天我都至少在学习成长上花了6h。我开始喜欢上这种记录的感觉。</p>\n<h2 id=\"重启-Blog\"><a href=\"#重启-Blog\" class=\"headerlink\" title=\"重启 Blog\"></a>重启 Blog</h2><p>周四晚上折腾了一晚，重启Blog，后面几天也在不断完善，终于到了现在这个样子。换了站点的头像，给站点添加了访问人数统计，为每一篇博文添加阅读数统计，在此感谢不蒜子大佬的脚本。周六晚上还添加了<code>相册</code>，到周日晚上，终于可以正常使用了。关于重启博客我是这样想的，上个月我就重启了『记录计划』，只是在手机上写，既然都要记录，为什么不放到网上呢？这样还方便查看，而且我会更有动力去写，Blog是一个比较好的选择。</p>\n<hr>\n<p>话不多说，以上就是这一周，关于上的这些课的具体内容我会在后面的文章中详细记录。这些网络类的课很有意思，它们有一种规则的美感，我想如果能自己亲手制定某些规则并加以实现肯定让人兴奋。生活总是有很多的不确定，但我确定关于『记录』这件事我会坚持下去。</p>\n","tags":[{"name":"记录","slug":"记录","permalink":"https://jonathan1214.github.io/tags/记录/"},{"name":"weekly","slug":"weekly","permalink":"https://jonathan1214.github.io/tags/weekly/"}]},{"title":"union-find算法的原理及实现","date":"2020-03-13T07:26:53.000Z","path":"2020/03/union-find/","text":"在计算机网络中，对于任意两个节点，可以在其间构建一条连接建立通信，这样做没有问题，但是在整个网络中都这么做会导致需要建立的连接非常多，容易计算得到N个节点的网络需要的连接数N(N-1)/2，这增加了网络的负担，实现起来也不容易，有什么办法改进呢？六度空间理论大家都知道，说的是最多通过六个人，我们可以和世界上任何人建立联系，那么如何知道两个人之间是否可以建立联系呢？这两个问题其实都属于连通性问题，可以使用union-find算法解决，步骤如下： 1. 数据准备p和q表示两个抽象的节点，可以用整数表示，如果『p，q 是相连的』，则意味着： 自反性：p和p是相连的。 对称性：如果p和q相连，则q和p也是相连的。 传递性：如果p和q相连，q和r相连，则p和r也相连。 我们可以用一个数组表示所有的节点，数组的每个位置表示一个节点，每个位置的值表示这个节点所在分量的标识符，初始化的时候每个节点的标识符都是其本身，如下所示： 12345void UF(int N) &#123; a = new int[N]; // 初始化节点数组 for (int i = 0; i &lt; N; i++) a[i] = i;&#125; 2. 实现quick-find在union-find算法中，有两个目标需要实现：判断两个节点是否连通和连接两个节点的。一种简单的思路是这样的，规定同属一个连通分量的标识符相同，比如：节点0，1和2是连通的，我们选择1为标识符，那么a[0]=a[1]=a[2]=1。这样做判断两个节点是否连通就可以在常数时间完成，基于此规则我们可以实现quick-find算法，但是这样做union的成本就会上升，每次union，需要遍历所有的节点，并对合适节点的标识符进行改变，这是个平方级别的算法，如下所示。 123456789101112boolean isConnected(int p, int q) &#123; return find(p)==find(q);&#125;int find(int p) &#123; return a[p]; &#125;void union(int p, int q) &#123; int pp = find(p); // p 节点的标识符 int qq = find(q); // q 节点的标识符 if (pp == qq) return; // 将 pp 标识符全部改成 qq for (int i = 0; i &lt; a.length; i++) if (a[i] == pp) a[i] = qq;&#125; quick-unionquick-find算法中，union的成本是平方级别的，其原因在于每次union需要遍历全部的节点，可以进行一些调整，得到改进，这就是quick-union算法。具体实现：在同一类别的中的节点，我们不再让所有节点保存相同的标识符，而是在节点中保持其父节点，类似一棵树，不过是向上走的，子节点指向父节点，根节点保存的是他自己，这样一来，进行union操作时，至于遍历找到根节点，然后让其中一个根节点指向另一个根节点即可，进行find操作时，只需遍历找到根节点即指向自身的节点。 12345678910int find(int p) &#123; while (a[p] != p) p = a[p]; return p;&#125;void union(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); // pRoot 节点指向 Qroot a[pRoot] = qRoot;&#125; 加权 quick-union这样做没什么问题，但是在最坏情况下，节点是依次相连的，串成一串，这会导致算法的性能下降，我们对其稍加改进，每次union时，都把节点数小的那一组连接到节点数大的那一组，这就是加权的quick-union算法。实现这个算法我们需要一个数组保存每个节点下节点的数目，对根节点而言，这个数就是它所在组的大小。 123456789101112131415161718192021UF(int N) &#123; a = new int[N]; // 初始化节点数组 sz = new int[N]; // 保存节点数目 for (int i = 0; i &lt; N; i++) a[i] = i; for (int i = 0; i &lt; N; i++) sz[i] = 1;&#125;// find 算法没有改变void union(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) return; if (sz[pRoot] &gt; sz[qRoot]) &#123; // p 所在组较大 a[qRoot] = pRoot; // 将q连接到q上 sz[pRoot] += sz[qRoot]; // 更新 pRoot 下的节点数 &#125; else &#123; // q 所在组较大 a[pRoot] = qRoot; sz[qRoot] += sz[pRoot]; &#125;&#125; 路径压缩还有一种路径压缩算法可以改进quick-union，即每次查找时，都把途径的节点指向根节点，这样均摊下来的find成本比较小，可以证明，路径压缩的加权quick-union算法是实现union-find最快的算法。 12345678910int find(int p) &#123; int x = p, t; while (a[p] != p) p = a[p]; // 找到根节点 while (x != p) &#123; // 直到到达根节点 t = a[x]; // 保存当前节点的父节点 a[x] = p; // 当前节点直接连接到根节点 x = t; // 移动到当前节点的父节点 &#125;&#125;// union 算法不变 回到开头的那两个问题，有了union-find算法，我们来尝试解决它们。对于网络中节点是否需要构建新的连接，抽象出网络的节点构建起UF后，执行isConnected()即可判断是否需要建立新的连接，对于两个人是否可以建立连接的问题，我们用同样的方法也可以解决，但要是想通过最少的中间人就认识一个人，该怎么做呢，这又是另外一个问题了。","content":"<p>在计算机网络中，对于任意两个节点，可以在其间构建一条连接建立通信，这样做没有问题，但是在整个网络中都这么做会导致需要建立的连接非常多，容易计算得到<code>N</code>个节点的网络需要的连接数<code>N(N-1)/2</code>，这增加了网络的负担，实现起来也不容易，有什么办法改进呢？六度空间理论大家都知道，说的是最多通过六个人，我们可以和世界上任何人建立联系，那么如何知道两个人之间是否可以建立联系呢？这两个问题其实都属于连通性问题，可以使用<code>union-find</code>算法解决，步骤如下：</p>\n<h2 id=\"1-数据准备\"><a href=\"#1-数据准备\" class=\"headerlink\" title=\"1. 数据准备\"></a>1. 数据准备</h2><p><code>p</code>和<code>q</code>表示两个抽象的节点，可以用整数表示，如果『p，q 是相连的』，则意味着：</p>\n<ul>\n<li>自反性：<code>p</code>和<code>p</code>是相连的。</li>\n<li>对称性：如果<code>p</code>和<code>q</code>相连，则<code>q</code>和<code>p</code>也是相连的。</li>\n<li>传递性：如果<code>p</code>和<code>q</code>相连，<code>q</code>和<code>r</code>相连，则<code>p</code>和<code>r</code>也相连。</li>\n</ul>\n<p>我们可以用一个数组表示所有的节点，数组的每个位置表示一个节点，每个位置的值表示这个节点所在分量的标识符，初始化的时候每个节点的标识符都是其本身，如下所示：<br><a id=\"more\"></a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">UF</span><span class=\"params\">(<span class=\"keyword\">int</span> N)</span> </span>&#123;</span><br><span class=\"line\">    a = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[N]; <span class=\"comment\">// 初始化节点数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++)</span><br><span class=\"line\">        a[i] = i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-实现\"><a href=\"#2-实现\" class=\"headerlink\" title=\"2. 实现\"></a>2. 实现</h2><h3 id=\"quick-find\"><a href=\"#quick-find\" class=\"headerlink\" title=\"quick-find\"></a>quick-find</h3><p>在<code>union-find</code>算法中，有两个目标需要实现：判断两个节点是否连通和连接两个节点的。一种简单的思路是这样的，规定同属一个连通分量的标识符相同，比如：节点<code>0</code>，<code>1</code>和<code>2</code>是连通的，我们选择<code>1</code>为标识符，那么<code>a[0]=a[1]=a[2]=1</code>。这样做判断两个节点是否连通就可以在常数时间完成，基于此规则我们可以实现<code>quick-find</code>算法，但是这样做<code>union</code>的成本就会上升，每次<code>union</code>，需要遍历所有的节点，并对合适节点的标识符进行改变，这是个平方级别的算法，如下所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isConnected</span><span class=\"params\">(<span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> q)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> find(p)==find(q);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> p)</span> </span>&#123; <span class=\"keyword\">return</span> a[p]; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">union</span><span class=\"params\">(<span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> q)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pp = find(p);   <span class=\"comment\">// p 节点的标识符</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> qq = find(q);   <span class=\"comment\">// q 节点的标识符</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pp == qq) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 将 pp 标识符全部改成 qq</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; a.length; i++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a[i] == pp) a[i] = qq;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"quick-union\"><a href=\"#quick-union\" class=\"headerlink\" title=\"quick-union\"></a>quick-union</h3><p>quick-find算法中，union的成本是平方级别的，其原因在于每次union需要遍历全部的节点，可以进行一些调整，得到改进，这就是quick-union算法。具体实现：在同一类别的中的节点，我们不再让所有节点保存相同的标识符，而是在节点中保持其父节点，类似一棵树，不过是向上走的，子节点指向父节点，根节点保存的是他自己，这样一来，进行union操作时，至于遍历找到根节点，然后让其中一个根节点指向另一个根节点即可，进行find操作时，只需遍历找到根节点即指向自身的节点。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> p)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (a[p] != p) p = a[p];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">union</span><span class=\"params\">(<span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> q)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pRoot = find(p);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> qRoot = find(q);</span><br><span class=\"line\">    <span class=\"comment\">// pRoot 节点指向 Qroot</span></span><br><span class=\"line\">    a[pRoot] = qRoot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"加权-quick-union\"><a href=\"#加权-quick-union\" class=\"headerlink\" title=\"加权 quick-union\"></a>加权 quick-union</h3><p>这样做没什么问题，但是在最坏情况下，节点是依次相连的，串成一串，这会导致算法的性能下降，我们对其稍加改进，每次union时，都把节点数小的那一组连接到节点数大的那一组，这就是加权的quick-union算法。实现这个算法我们需要一个数组保存每个节点下节点的数目，对根节点而言，这个数就是它所在组的大小。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UF(<span class=\"keyword\">int</span> N) &#123;</span><br><span class=\"line\">    a = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[N];     <span class=\"comment\">// 初始化节点数组</span></span><br><span class=\"line\">    sz = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[N];    <span class=\"comment\">// 保存节点数目</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++)</span><br><span class=\"line\">        a[i] = i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++)</span><br><span class=\"line\">        sz[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// find 算法没有改变</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">union</span><span class=\"params\">(<span class=\"keyword\">int</span> p, <span class=\"keyword\">int</span> q)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pRoot = find(p);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> qRoot = find(q);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pRoot == qRoot) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sz[pRoot] &gt; sz[qRoot]) &#123; <span class=\"comment\">// p 所在组较大</span></span><br><span class=\"line\">        a[qRoot] = pRoot; <span class=\"comment\">// 将q连接到q上</span></span><br><span class=\"line\">        sz[pRoot] += sz[qRoot]; <span class=\"comment\">// 更新 pRoot 下的节点数</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;    <span class=\"comment\">// q 所在组较大</span></span><br><span class=\"line\">        a[pRoot] = qRoot;</span><br><span class=\"line\">        sz[qRoot] += sz[pRoot];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"路径压缩\"><a href=\"#路径压缩\" class=\"headerlink\" title=\"路径压缩\"></a>路径压缩</h3><p>还有一种路径压缩算法可以改进quick-union，即每次查找时，都把途径的节点指向根节点，这样均摊下来的find成本比较小，可以证明，路径压缩的加权quick-union算法是实现union-find最快的算法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> p)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x = p, t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (a[p] != p) p = a[p]; <span class=\"comment\">// 找到根节点</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (x != p) &#123; <span class=\"comment\">// 直到到达根节点</span></span><br><span class=\"line\">        t = a[x];   <span class=\"comment\">// 保存当前节点的父节点</span></span><br><span class=\"line\">        a[x] = p;   <span class=\"comment\">// 当前节点直接连接到根节点</span></span><br><span class=\"line\">        x = t;      <span class=\"comment\">// 移动到当前节点的父节点</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// union 算法不变</span></span><br></pre></td></tr></table></figure>\n<hr>\n<p>回到开头的那两个问题，有了union-find算法，我们来尝试解决它们。对于网络中节点是否需要构建新的连接，抽象出网络的节点构建起<code>UF</code>后，执行<code>isConnected()</code>即可判断是否需要建立新的连接，对于两个人是否可以建立连接的问题，我们用同样的方法也可以解决，但要是想通过最少的中间人就认识一个人，该怎么做呢，这又是另外一个问题了。</p>\n","tags":[{"name":"算法","slug":"算法","permalink":"https://jonathan1214.github.io/tags/算法/"},{"name":"Java","slug":"Java","permalink":"https://jonathan1214.github.io/tags/Java/"},{"name":"union-find","slug":"union-find","permalink":"https://jonathan1214.github.io/tags/union-find/"}]},{"title":"算法的分析方法","date":"2020-03-10T13:30:43.000Z","path":"2020/03/a-way-to-algorithm-analysis/","text":"也看了几天『算法』了，总是觉得不得要领，在此做一点笔记想必会有所帮助，能够完整地写下来或者清楚地讲述给别人并使之理解才算掌握了知识，这个观点来自费曼，我深以为然。 算法及其重要性算法 被用来描述一种有限的、确定的、有效的并适合计算机程序来实现的解决问题的方法，它是计算机科学的基础，是这个领域研究的核心。『算法』在前言中就如此讲到： 算法和数据结构的学习的学习是所有计算机教学计划的基础。 我想算法的重要性已不言而喻，这也是我在此努力学习的原因，当然我不是计算机系的学生，但我深信一定程度上了解算法和其分析方法对我的专业学习和理解也很有帮助。 使用数据抽象开发可重用的算法虽然我关心的是算法背后的逻辑，但是真正实现起来还是落在代码上，为了保证其可重用性，使用数据抽象，让我们更关注算法的内核，而不是具体的数据。按照下面的步骤解决问题： 定义 API 根据特定的应用场景开发用例代码 描述一种数据结构，并在 API 说对应的抽象数据类型的实现中根据它定义类的实例变量 描述算法 分析算法的性能特点 算法分析诸如『我的算法会运行多久？』和『为什么我的程序耗尽了所有的内存』这样的基础问题，我们使用 科学方法 可以给出实际性的回答，如下所示，同时使用 数学分析 为算法建立模型，还可以使用 实验数据 验证模型。 细致的观察真实世界的特点 根据观察的结果提出假设模型 预测未来事件 继续观测并核实预测的准确性 如此反复直到确认预测和观察一致 进行实际分析之前，首先要确定 输入模型 和 问题的规模，其实就是说 输入数据量的大小 和 数据的特点 对运行时间的影响，显然运行时间会随着规模的增大而变长。 关于数学分析，依据 Knuth 的观点，程序运行的总时间主要与 执行每条语句的耗时 和 执行每条语句的频率有关。对于前者，这由机器决定，我们不关心，而后者由程序和输入决定，这正是我们要分析的。对于语句频率的分析我们会采用近似的方法，这由会得到 增长的数量级 这一概念，当输入规模很大时，这被验证是可行的，而我们正是关注算法处理大规模输入的性能。 增长的数量级概念的应用使我们能够 将程序和它实现的算法隔离开，算法和输入模型决定了增长的数量级。 使用 成本模型 评估算法的性质，该模型定义了算法中的基本操作，如数组的访问次数和元素的交换次数等等。在选定的数学模型下，我们或许可以用精确的数学语言说明算法的性质，这正是我们进行数学分析的目的。 以上我们可以得出分析程序运行时间数学模型的步骤如下： 确定输入模型下，定义问题的规模 识别内循环 根据内循环的操作确定成本模型 对于规定的输入，判断这些操作的执行频率","content":"<p>也看了几天『算法』了，总是觉得不得要领，在此做一点笔记想必会有所帮助，能够完整地写下来或者清楚地讲述给别人并使之理解才算掌握了知识，这个观点来自费曼，我深以为然。<br><!-- 这里应该添加一个目录 --><br><a id=\"more\"></a></p>\n<h2 id=\"算法及其重要性\"><a href=\"#算法及其重要性\" class=\"headerlink\" title=\"算法及其重要性\"></a>算法及其重要性</h2><p><strong>算法</strong> 被用来描述一种有限的、确定的、有效的并适合计算机程序来实现的解决问题的方法，它是计算机科学的基础，是这个领域研究的核心。『算法』在前言中就如此讲到：</p>\n<blockquote>\n<p>算法和数据结构的学习的学习是所有计算机教学计划的基础。</p>\n</blockquote>\n<p>我想算法的重要性已不言而喻，这也是我在此努力学习的原因，当然我不是计算机系的学生，但我深信一定程度上了解算法和其分析方法对我的专业学习和理解也很有帮助。</p>\n<h2 id=\"使用数据抽象开发可重用的算法\"><a href=\"#使用数据抽象开发可重用的算法\" class=\"headerlink\" title=\"使用数据抽象开发可重用的算法\"></a>使用数据抽象开发可重用的算法</h2><p>虽然我关心的是算法背后的逻辑，但是真正实现起来还是落在代码上，为了保证其可重用性，使用数据抽象，让我们更关注算法的内核，而不是具体的数据。按照下面的步骤解决问题：</p>\n<ul>\n<li>定义 API</li>\n<li>根据特定的应用场景开发用例代码</li>\n<li>描述一种数据结构，并在 API 说对应的抽象数据类型的实现中根据它定义类的实例变量</li>\n<li>描述算法</li>\n<li>分析算法的性能特点</li>\n</ul>\n<h2 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h2><p>诸如『我的算法会运行多久？』和『为什么我的程序耗尽了所有的内存』这样的基础问题，我们使用 <em>科学方法</em> 可以给出实际性的回答，如下所示，同时使用 <em>数学分析</em> 为算法建立模型，还可以使用 <em>实验数据</em> 验证模型。</p>\n<ul>\n<li>细致的观察真实世界的特点</li>\n<li>根据观察的结果提出假设模型</li>\n<li>预测未来事件</li>\n<li>继续观测并核实预测的准确性</li>\n<li>如此反复直到确认预测和观察一致</li>\n</ul>\n<p>进行实际分析之前，首先要确定 <strong>输入模型</strong> 和 <strong>问题的规模</strong>，其实就是说 <strong>输入数据量的大小</strong> 和 <strong>数据的特点</strong> 对运行时间的影响，显然运行时间会随着规模的增大而变长。</p>\n<p>关于数学分析，依据 Knuth 的观点，程序运行的总时间主要与 <strong>执行每条语句的耗时</strong> 和 <strong>执行每条语句的频率有关</strong>。对于前者，这由机器决定，我们不关心，而后者由程序和输入决定，这正是我们要分析的。对于语句频率的分析我们会采用近似的方法，这由会得到 <strong>增长的数量级</strong> 这一概念，当输入规模很大时，这被验证是可行的，而我们正是关注算法处理大规模输入的性能。</p>\n<p>增长的数量级概念的应用使我们能够 <strong>将程序和它实现的算法隔离开</strong>，算法和输入模型决定了增长的数量级。</p>\n<p>使用 <strong>成本模型</strong> 评估算法的性质，该模型定义了算法中的基本操作，如数组的访问次数和元素的交换次数等等。在选定的数学模型下，我们或许可以用精确的数学语言说明算法的性质，这正是我们进行数学分析的目的。</p>\n<p>以上我们可以得出分析程序运行时间数学模型的步骤如下：</p>\n<ul>\n<li>确定输入模型下，定义问题的规模</li>\n<li>识别内循环</li>\n<li>根据内循环的操作确定成本模型</li>\n<li>对于规定的输入，判断这些操作的执行频率</li>\n</ul>\n","tags":[{"name":"算法","slug":"算法","permalink":"https://jonathan1214.github.io/tags/算法/"},{"name":"Java","slug":"Java","permalink":"https://jonathan1214.github.io/tags/Java/"}]},{"title":"记录高频硬件课程设计","date":"2019-12-29T01:23:10.000Z","path":"2019/12/record-of-high-frequency-course-design/","text":"本文绝大部分内容是在19年12月29日写的，我记得很清楚，那天是周日上午，我没有为即将到来的通原考试而复习，而是选择去写点东西记录几天前刚刚结束的高频课设，这是一次很难忘的经历，有痛苦也有快乐，有想过放弃但还是坚持了下来，感谢自己和队友们。现在是2020年3月15日，本该在学校度过周日的我，和所有的大学生一样，因为肺炎疫情只能在家里学习，我没什么学习状态，有些无聊，因此整理博客，把这篇去年的记录整理整理，发到GitHubBlog上，留作纪念，发表日期还是使用去年写这篇文章的日子。 最终验收12月24号，高频硬件课设验收，在队友的强烈要求下，我们选择了一个比较宽松的老师给我们验收，因为我们功率达不到，但还想 『恰完烂分』，这能对他的保研有所帮助。最后的结果很好，我们拿到了5分（满分5分），『烂分恰完』。 最终验收时电路连接和波形 开始12月17号周二下午考完『随机过程』，终于有时间休息了，躺了一个小时，吃个饭，室友已经去搞硬件了，虽然已经是晚上9点多了，但我还想去，带上东西，去李老师办公室焊。折腾了两个小时，焊好了一个西勒振荡器，但没有测试工具，只能第二天测试焊接是否正确，测试工具缺乏和焊接出错这两个问题在整个课设过程中一直困扰着我们。 第一天晚上焊好的西勒振荡器 一起干第二天是周三，没有课，我和赵公子决定去实验室接着焊板子，顺便测试下昨晚上焊的振荡器。两个小时后，我们焊好了发射机和接收机的振荡器，经过测试，他的能用，而我的那块振荡器产生了寄生调幅。检查了电路没有任何问题，折腾到下午，最后发现是射极偏置电阻过大导致的，微调射极电阻，即可解决这个问题。 下午和晚上我们都在实验室呆着，一直做到晚上11点。因为我已经很久没焊接东西，有点手生，他更是没啥经验，我们效率比较低，只焊好了一个乘法电路、一个中频放大器和一个包络检波器。后面测试时发现，我焊接的那个乘法电路不能实现信号相乘。那时我还不知道，接下来3天我都会把时间花在乘法电路上，如果早知道调试它会这么折腾，第一天晚上就应该当机立断重新焊一个的。 心生退意接下来的几天我感到痛苦不堪，我焊接乘法电路始终不好使，不知为什么我就是不愿重新焊一块，执着地想把它修好，但这一切都是徒劳的。看着周围的同学一个个都做出来乘法电路了，我开始怀疑自己：如果做不出来是不是证明我不行，我怎么能不行呢？要不放弃吧，这样就不存在证明了，我告诉自己这些bonus对我来说并不那么重要，我保研与否与这课设5分没什么关系。沃老板执着地说焊板子的烟搞得他很难受，实验室里面人太多了，空气太差，乌烟瘴气，他想回寝室做，这样的参与状态让我心有不快，偏偏他才是一定要拿这 5 分保研的人，为什么我要受这些精神折磨，我当时的确不想再做下去了。 周六早上，纠结了许久，我去教化补充了些元器件，决定去实验室再焊一个乘法器，还说服沃老板也焊一个接收机的乘法电路。我不知道是什么力量支撑着我继续做下去，这件事对我来说不是那么必要，最诱人的bonus并不是我一定需要的，如果不做课设，我可以去复习通原，我可以享受轻松的一周。事后我仔细想了想，大概是因为我自己的性格决定的，我不是那种遇到问题就放弃的人，借口谁都有一些，但是作为我，一旦开始做了，就要做到最后，没有中途放弃的，之前的软件仿真就是如此，没有理由硬件不坚持下去，到这个时候，其实做这个课设已经变成了和自己较劲了，我不想就这么输了。 周六下午去做了通信原理实验，晚上终于焊好我的第二块乘法电路，测试再次失败，沃老板也焊好接收机混频电路，经过测试也失败。这时候我心态已经到了最低点了，我真的不想再来了，前面说的那么多不服输如何如何，可是看着别人一个个做好，我的却始终不行，旁边还有人明着嘲讽我，这使我明白『挫败感』是何含义。晚上10点，我和沃老板回寝室了，赵公子在周五下午有事回家了，但他做的已经足够多了。我突然决定不再去了。 坚持才是胜利周日上午我还是去实验室了，我想就是什么都做不出来，也得一直在实验室坐着，我就要和它刚到底。好在一切坚持都没有白费，我的乘法电路测试成功了，事实证明我的电路设计没有问题，焊接的也没有问题，昨晚测试失败只是因为电路连线没有接好，胜利让我欣喜若狂，我真想大声怒吼：我终于完成了。另一边也有好消息传来，沃老板焊的和赵公子焊的乘法电路都是好使的，还有什么比此刻更快乐呢？ 赵公子的乘法器AM波形 沃老板的混频器波形 周日下午发生了一些不愉快的事情，因为下午找不到他人（其实他在午睡），我对沃老板的不满更加强烈了，而那时我已经十分疲惫，愤怒之下，下午3点左右我直接回寝室，拒绝回他消息，然后睡了一觉。期间他来找我，我『哈哈』糊弄过去，不想再干。6点多起来看一眼手机，想了想，还是再去试试，把级联和功率要求做完吧，都已经到这个份上了，干脆就把它做到完。 乘胜追击我不想就此打住，野心开始膨胀了，『恰5分』 是调侃，此时更像是口号。发射机 AM 调制输出接上我焊调试乘法器抽空焊好的小信号放大器，效果非常好！放大了80倍，但我心里清楚，因为没有接负载，最后功率肯定达不到；接收机，混频后中频放大再检波，效果很差，但也算检波出来了，在要求不那么严苛的时候，可以拿到分；发射机接收机级联成功，和仿真保持一致。 如此算来，我们已经可以拿到 4.5 分，但是我们不想收手，我们继续调放大器，要把功率的 5 分也拿到手。很不幸，我们没有成功，三极管射极电阻过小，导致射极电流过大，二极管被烧坏了，放大器也就怀了，这又是我们唯一的放大器，级联也没办法做了，这下只有 4 分了，后悔，懊恼。 第二天周一，已经是12月23号了，我都没想到自己会在这上面花上近一周时间。白天上了一天课，晚上我们接着调试了一下，还是那个问题，AM 波后的小信号放大器不好使，级联就不行，功率也没有。赵公子也回来了，我们让他重新焊了一个，失败了，因为我临时对之前测试成功的电路做了修改，为了减小电流避免三极管烧毁的事再发生，但是我没想到这么一改，电流太小，放大倍数达不到要求，而且我应该自己亲手焊的。可以说今天又是一无所获。但我不会就此打住，我不愿放弃。 周二上午上完微波课，我立马去教化买了元件，再焊一个小信号放大器，再试一次，不到最后，谁也不知道结果，我不想放弃。一番折腾，焊好，测试，成功。 下午验收前一刻，上周三买的陶瓷滤波器终于从深圳邮到了学校，我赶紧去取回来，接到电路中，完美!『烂分恰完』。 后记做完这次课设，心里有太多感慨，很多次我都想放弃了，但是总有一股力量把我拉了回来，这其中有对朋友承诺的坚守也有自己那股不服输的劲，验收成功那一刻我有点想哭，是啊，这整个过程只有我自己这么看重吧，最后还在自我感动，但如果没有这自我感动，我不知道自己能否坚持下来。当然，课设整个过程也暴露了我的一些问题：我需要有更强大的精神力量，激励自己前进，也要学会如何带领团队前进。","content":"<p>本文绝大部分内容是在19年12月29日写的，我记得很清楚，那天是周日上午，我没有为即将到来的通原考试而复习，而是选择去写点东西记录几天前刚刚结束的高频课设，这是一次很难忘的经历，有痛苦也有快乐，有想过放弃但还是坚持了下来，感谢自己和队友们。现在是2020年3月15日，本该在学校度过周日的我，和所有的大学生一样，因为肺炎疫情只能在家里学习，我没什么学习状态，有些无聊，因此整理博客，把这篇去年的记录整理整理，发到GitHubBlog上，留作纪念，发表日期还是使用去年写这篇文章的日子。<br><a id=\"more\"></a></p>\n<h2 id=\"最终验收\"><a href=\"#最终验收\" class=\"headerlink\" title=\"最终验收\"></a>最终验收</h2><p>12月24号，高频硬件课设验收，在队友的强烈要求下，我们选择了一个比较宽松的老师给我们验收，因为我们功率达不到，但还想 <strong>『恰完烂分』</strong>，这能对他的保研有所帮助。最后的结果很好，我们拿到了5分（满分5分），<strong>『烂分恰完』</strong>。</p>\n<div align=\"center\" class=\"img\"><br>    <img src=\"/assets/img/2019/final.jpg\" alt=\"验收\" height=\"400\"><br>    <p align=\"center\" style=\"color:#999\">最终验收时电路连接和波形</p><br></div>\n\n<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><p>12月17号周二下午考完『随机过程』，终于有时间休息了，躺了一个小时，吃个饭，室友已经去搞硬件了，虽然已经是晚上9点多了，但我还想去，带上东西，去李老师办公室焊。折腾了两个小时，焊好了一个西勒振荡器，但没有测试工具，只能第二天测试焊接是否正确，测试工具缺乏和焊接出错这两个问题在整个课设过程中一直困扰着我们。</p>\n<div align=\"center\" class=\"img\"><br>    <img src=\"/assets/img/2019/siler_oscillator.jpg\" alt=\"西勒振荡器\" height=\"400\"><br>    <p align=\"center\" style=\"color:#999\">第一天晚上焊好的西勒振荡器</p><br></div>\n\n<h2 id=\"一起干\"><a href=\"#一起干\" class=\"headerlink\" title=\"一起干\"></a>一起干</h2><p>第二天是周三，没有课，我和赵公子决定去实验室接着焊板子，顺便测试下昨晚上焊的振荡器。两个小时后，我们焊好了发射机和接收机的振荡器，经过测试，他的能用，而我的那块振荡器产生了寄生调幅。检查了电路没有任何问题，折腾到下午，最后发现是射极偏置电阻过大导致的，微调射极电阻，即可解决这个问题。</p>\n<p>下午和晚上我们都在实验室呆着，一直做到晚上11点。因为我已经很久没焊接东西，有点手生，他更是没啥经验，我们效率比较低，只焊好了一个乘法电路、一个中频放大器和一个包络检波器。后面测试时发现，我焊接的那个乘法电路不能实现信号相乘。那时我还不知道，接下来3天我都会把时间花在乘法电路上，如果早知道调试它会这么折腾，第一天晚上就应该当机立断重新焊一个的。</p>\n<h2 id=\"心生退意\"><a href=\"#心生退意\" class=\"headerlink\" title=\"心生退意\"></a>心生退意</h2><p>接下来的几天我感到痛苦不堪，我焊接乘法电路始终不好使，不知为什么我就是不愿重新焊一块，执着地想把它修好，但这一切都是徒劳的。看着周围的同学一个个都做出来乘法电路了，我开始怀疑自己：如果做不出来是不是证明我不行，我怎么能不行呢？要不放弃吧，这样就不存在证明了，我告诉自己这些bonus对我来说并不那么重要，我保研与否与这课设5分没什么关系。沃老板执着地说焊板子的烟搞得他很难受，实验室里面人太多了，空气太差，乌烟瘴气，他想回寝室做，这样的参与状态让我心有不快，偏偏他才是一定要拿这 5 分保研的人，为什么我要受这些精神折磨，我当时的确不想再做下去了。</p>\n<p>周六早上，纠结了许久，我去教化补充了些元器件，决定去实验室再焊一个乘法器，还说服沃老板也焊一个接收机的乘法电路。我不知道是什么力量支撑着我继续做下去，这件事对我来说不是那么必要，最诱人的bonus并不是我一定需要的，如果不做课设，我可以去复习通原，我可以享受轻松的一周。事后我仔细想了想，大概是因为我自己的性格决定的，我不是那种遇到问题就放弃的人，借口谁都有一些，但是作为我，一旦开始做了，就要做到最后，没有中途放弃的，之前的软件仿真就是如此，没有理由硬件不坚持下去，到这个时候，其实做这个课设已经变成了和自己较劲了，我不想就这么输了。</p>\n<p>周六下午去做了通信原理实验，晚上终于焊好我的第二块乘法电路，测试再次失败，沃老板也焊好接收机混频电路，经过测试也失败。这时候我心态已经到了最低点了，我真的不想再来了，前面说的那么多不服输如何如何，可是看着别人一个个做好，我的却始终不行，旁边还有人明着嘲讽我，这使我明白『挫败感』是何含义。晚上10点，我和沃老板回寝室了，赵公子在周五下午有事回家了，但他做的已经足够多了。我突然决定不再去了。</p>\n<h2 id=\"坚持才是胜利\"><a href=\"#坚持才是胜利\" class=\"headerlink\" title=\"坚持才是胜利\"></a>坚持才是胜利</h2><p>周日上午我还是去实验室了，我想就是什么都做不出来，也得一直在实验室坐着，我就要和它刚到底。好在一切坚持都没有白费，我的乘法电路测试成功了，事实证明我的电路设计没有问题，焊接的也没有问题，昨晚测试失败只是因为电路连线没有接好，胜利让我欣喜若狂，我真想大声怒吼：我终于完成了。另一边也有好消息传来，沃老板焊的和赵公子焊的乘法电路都是好使的，还有什么比此刻更快乐呢？</p>\n<div align=\"center\"><br>    <img src=\"/assets/img/2019/amplitude_modulation.jpg\" alt=\"AM调幅\" height=\"400\"><br>    <p align=\"center\" style=\"color:#999\">赵公子的乘法器AM波形</p><br>    <img src=\"/assets/img/2019/mixing.jpg\" alt=\"混频\" height=\"400\"><br>    <p align=\"center\" style=\"color:#999\">沃老板的混频器波形</p><br></div>\n\n<p>周日下午发生了一些不愉快的事情，因为下午找不到他人（其实他在午睡），我对沃老板的不满更加强烈了，而那时我已经十分疲惫，愤怒之下，下午3点左右我直接回寝室，拒绝回他消息，然后睡了一觉。期间他来找我，我『哈哈』糊弄过去，不想再干。6点多起来看一眼手机，想了想，还是再去试试，把级联和功率要求做完吧，都已经到这个份上了，干脆就把它做到完。</p>\n<h2 id=\"乘胜追击\"><a href=\"#乘胜追击\" class=\"headerlink\" title=\"乘胜追击\"></a>乘胜追击</h2><p>我不想就此打住，野心开始膨胀了，<strong>『恰5分』</strong> 是调侃，此时更像是口号。发射机 AM 调制输出接上我焊调试乘法器抽空焊好的小信号放大器，效果非常好！放大了80倍，但我心里清楚，因为没有接负载，最后功率肯定达不到；接收机，混频后中频放大再检波，效果很差，但也算检波出来了，在要求不那么严苛的时候，可以拿到分；发射机接收机级联成功，和仿真保持一致。</p>\n<p>如此算来，我们已经可以拿到 4.5 分，但是我们不想收手，我们继续调放大器，要把功率的 5 分也拿到手。很不幸，我们没有成功，三极管射极电阻过小，导致射极电流过大，二极管被烧坏了，放大器也就怀了，这又是我们唯一的放大器，级联也没办法做了，这下只有 4 分了，后悔，懊恼。</p>\n<p>第二天周一，已经是12月23号了，我都没想到自己会在这上面花上近一周时间。白天上了一天课，晚上我们接着调试了一下，还是那个问题，AM 波后的小信号放大器不好使，级联就不行，功率也没有。赵公子也回来了，我们让他重新焊了一个，失败了，因为我临时对之前测试成功的电路做了修改，为了减小电流避免三极管烧毁的事再发生，但是我没想到这么一改，电流太小，放大倍数达不到要求，而且我应该自己亲手焊的。可以说今天又是一无所获。但我不会就此打住，我不愿放弃。</p>\n<p>周二上午上完微波课，我立马去教化买了元件，再焊一个小信号放大器，再试一次，不到最后，谁也不知道结果，我不想放弃。一番折腾，焊好，测试，成功。</p>\n<p>下午验收前一刻，上周三买的陶瓷滤波器终于从深圳邮到了学校，我赶紧去取回来，接到电路中，完美!<strong>『烂分恰完』</strong>。</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>做完这次课设，心里有太多感慨，很多次我都想放弃了，但是总有一股力量把我拉了回来，这其中有对朋友承诺的坚守也有自己那股不服输的劲，验收成功那一刻我有点想哭，是啊，这整个过程只有我自己这么看重吧，最后还在自我感动，但如果没有这自我感动，我不知道自己能否坚持下来。当然，课设整个过程也暴露了我的一些问题：我需要有更强大的精神力量，激励自己前进，也要学会如何带领团队前进。</p>\n","tags":[{"name":"记录","slug":"记录","permalink":"https://jonathan1214.github.io/tags/记录/"}]},{"title":"Believe_in_yourself","date":"2018-06-18T14:30:53.000Z","path":"2018/06/Believe-in-yourself/","text":"最近有点烦躁，事情一件接着一件地扑面而来，丝毫不给我喘气的机会，为了排遣苦闷，我嘴上的脏话多了不少，不过好在这一切都将过去了，过去了之后我一定要好好开始，现在，我只有祈祷最后能有一个好的结果。这是一个疯狂的六月！英语课程考试(6.7)，英语口语测试(6.14)，六级考试(6.16)，科创答辩(6.20)，数学建模考试(6.21)，近代史考试(6.26)，英语期末考试(6.29)……这还远没有结束，七月是工大的小学期时间！八月才放暑假！九月开学！坏消息是大物和微积分的考试放到小学期了，当然，这也可以算是好消息，至少六月份可以喘口气了，真正毫无疑问的好消息自然就是我们会搬进新公寓！","content":"<p>最近有点烦躁，事情一件接着一件地扑面而来，丝毫不给我喘气的机会，为了排遣苦闷，我嘴上的脏话多了不少，不过好在这一切都将过去了，过去了之后我一定要好好开始，现在，我只有祈祷最后能有一个好的结果。<br><a id=\"more\"></a><br>这是一个疯狂的六月！<br>英语课程考试(6.7)，英语口语测试(6.14)，六级考试(6.16)，科创答辩(6.20)，数学建模考试(6.21)，近代史考试(6.26)，英语期末考试(6.29)……这还远没有结束，七月是工大的小学期时间！八月才放暑假！九月开学！坏消息是大物和微积分的考试放到小学期了，当然，这也可以算是好消息，至少六月份可以喘口气了，真正毫无疑问的好消息自然就是我们会搬进新公寓！</p>\n","tags":[{"name":"记录","slug":"记录","permalink":"https://jonathan1214.github.io/tags/记录/"}]},{"title":"数据结构复习","date":"2018-05-14T12:25:46.000Z","path":"2018/05/review-data-structure/","text":"先抄一段Dave在他的书《The Pragmatic Programmer》中的话： You’re a Pragmatic Programmer. You aren’t wedded to any particular technology, but you have a broad enough background in the science, and your experience with practical projects allow you to choose good solution in particular situations. Theory and practice combine to make you strong. You adjust your approach to suit the current circumstance and environment. And you do this continuously as the work progresses. Pragmatic Programmers get the job done, and do it well. Ok，现在开始吧！ C语言程序设计开始 先上第一段代码： 1234567#include &lt;stdio.h&gt;int main(void)&#123; printf(\"Hello world\\n\"); printf(\"This is a C program\"); return 0;&#125; 这是一个简单的C程序，我从这里开始，解释什么的是不需要的。 第二段代码：1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;int main (void)&#123; //这个程序根据你输入的两个整数和输入的一个四则运算符进行运算 int a, b; unsigned int Bool = 0; char ch; printf(\"请输入两个整数：\"); scanf(\"%d\", &amp;a); scanf(\"%d\", &amp;a); printf(\"\\n请输入一个四则运算符：\"); Bool = scanf(\"%c\", &amp;ch); switch (ch) &#123; case '+': printf(\"\\n%d + %d = %d\", a, b, a+b); break; case '-': printf(\"\\n%d - %d = %d\", a, b, a-b); break:; case '*': printf(\"\\n%d * %d = %d\", a, b, a*b); break; case '/': printf(\"\\n%d / %d = %f\", a, b, float(a)/b); break; default: printf(\"输入的不是四则运算符！！！\"); break; &#125; return 0;&#125; OK，上面的代码写出来了！没有什么问题！记几个需要注意的地方： 1. `scanf()`的是有返回值，读到了几个正确的输入就返回几，例如在上面的代码的中，如果输入了一个字符，`Bool`的值就变成`1`，在这里作用不大，不过就是为了复习嘛，无所谓的啦。 2. 注意`switch() case`语句的用法：`switch()`括号内的变量类型一定要是__整型或者字符型__。 第三段代码：1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main (void)&#123; //定义一个二维数组并初始化 int a[2][3] = &#123; &#123;1, 2, 3&#125;, &#123;4, 5, 6&#125; &#125;; //几个指针的声明 int *pt; int (*pa)[3]; //注意：[]的优先级高于* int *pax[3]; //注意与上一个进行对比，这是不一样的 int ar1[2][3]; int ar2[3][2]; int **p2; //以下均是有效的赋值 pt = &amp;a[0][0]; pa = &amp;a[0]; //在这里pt和pa的值相同 pa = &amp;a[1]; p2 = &amp;pt;&#125; 从上面就可以看出来，指针这个东西还是很烦人的，不过也不难，多看几遍就行了，还有要注意指针和数组的关系。指针比数组更本质！ 第四段代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344//找二维数组的鞍点，行最小且列最大的即为鞍点#include &lt;stdio.h&gt;int main (void)&#123; int a[20][20]; int Row, Col; int i, j; printf(\"请输入数组的行数和列数：\"); scanf(\"%d%d\", Row, Col); printf(\"\\n请输入%d个整数：\\n\\t\", Row*Col); for (i = 0; i &lt; Row; i++) for (j = 0; j &lt; Col; j++) scanf(\"%d\", &amp;a[i][j]); for (i = 0; i &lt; Row; i++) &#123; int temp = a[i][0]; int k = 0; int f = 1; for (j = 1; j &lt; Col; j++) &#123; if (temp &gt; a[i][j]) &#123; temp = a[i][j]; k = j; &#125; &#125; for (j = 0; j &lt; Row; j++) &#123; if (j == i) continue; else &#123; if (a[j][k] &gt; a[i][k]) f = 0; &#125; &#125; if (f) printf(\"\\n%d\", &amp;a[i][k]); else printf(\"\\n无鞍点\"); &#125; return 0;&#125; 我也不管什么优化了，丑就丑吧，几个循环套起来又怕什么，比比谁写的更丑，没有运行时间和内存使用限制，写起来就是爽！ 第五段代码：12345678910111213141516171819#include &lt;stdio.h&gt;int main (void)&#123; printf(\"这是一个计算函数值的程序：\\n\"); int x, y; printf(\"请输入整数x的值：\"); scanf(\"%d\", &amp;x); if (x &lt; 0) y = 5*x; else &#123; if (x &lt; 8) y = 2*x - 1; else y = x + 4; &#125; printf(\"\\ny = %d\", y); return 0;&#125; 这段代码没什么意思，纯粹是送的。 第六段代码：1234567891011121314151617181920#include &lt;stdio.h&gt;void Pri_as_ord(int *p, int *q)&#123; int temp; if (*p &gt; *q) &#123; temp = *p; *p = *q; *q = temp; &#125;&#125;int main (void)&#123; int a, b; printf(\"请输入两个整数：\"); scanf(\"%d%d\", &amp;a, &amp;b); Pri_as_ord(&amp;a, &amp;b); printf(\"按由小到大的顺序输出：%d %d\", a, b); return 0;&#125; 还是没什么意思，接着写！ 第七段代码：12345678910111213141516171819202122232425262728293031323334353637383940/*录入三个学生的学号和各自两门课的成绩*/#include &lt;stdio.h&gt;struct Student&#123; int num; float score1; float score2;&#125;;void Best(struct Student student[], int n)&#123; int i, m, aver[n]; for (i = 0; i &lt; n; i++) aver[i] = (student[i].score1 + student[i].score2)/2; if (aver[0] &gt; aver[1]) &#123; if (aver[0] &gt; aver[2]) m = 0; else m = 2; &#125; else &#123; if (aver[1] &gt; aver[2]) m = 1; else m = 2; &#125; printf(\"平均成绩最高的学生的学号是：%d\", student[m].num);&#125;int main (void)&#123; int i = 1; struct Student student[3]; for (; i &lt; 4; i++) printf(\"请输入第%d个学生的学号和两门课的成绩:%d %f %f\", i, student[i-1].num, student[i-1].score1, student[i-1].score2); Best(student, 3); return 0;&#125; 哇！写得想吐了！超级累！不管继续！ 第八段代码123456789101112131415161718192021222324252627282930313233343536/*这只是一个函数，用来实现删除单链表中码值相同的节点，只保留一个假设节点是这样的：struct node&#123; int data; struct node *next; &#125;;*/void Del(struct node *head)&#123; struct node *p, *q, *s; p = head-&gt;next; if (p == NULL) printf(\"Empty List\"); else &#123; while (p-&gt;next != NULL) &#123; q = p-&gt;next; do &#123; while ((q-&gt;data != p-&gt;data) &amp;&amp; (q-&gt;next != NULL)) &#123; s = q; q = q-&gt;next; &#125; if (q-&gt;data == x) &#123; s-&gt;next = q-&gt;next; free (q); &#125; p = s-&gt;next; &#125; while (p != NULL); p = p-&gt;next; &#125; &#125;&#125; 上面的代码有点烦，不过好在思路还算清晰，没有遇到问题，就是时间花得太长了，单链表还是不够熟练，接着来！ 第九段代码：12345678910111213141516171819202122232425//一个队列入排操作struct queue&#123; int item[max]; int front; int rear;&#125;;//初始化时rear=-1，front为0~max-1的任意值//front指向队列第一个元素的前一个位置，rear指向队尾元素所在位置//front=rear时队列满，rear=-1时队列空struct queue q;void Inqueue(struct queue q, int x)&#123; if (q.front == q.rear) printf(\"队满\"); else &#123; if (q.rear = -1) q.rear = q.front; if (q.rear = max-1) q.rear = 0; q.rear += 1; q.item[q.rear] = x; &#125;&#125; 简单的顺序存储的队列，实现入排操作不难，弄懂原理就好。","content":"<p>先抄一段Dave在他的书《The Pragmatic Programmer》中的话：</p>\n<blockquote>\n<p>You’re a Pragmatic Programmer. You aren’t wedded to any particular technology, but you have a broad enough background in the science, and your experience with practical projects allow you to choose good solution in particular situations. Theory and practice combine to make you strong. You adjust your approach to suit the current circumstance and environment. And you do this continuously as the work progresses. Pragmatic Programmers get the job done, and do it well.</p>\n</blockquote>\n<p>Ok，现在开始吧！</p>\n<a id=\"more\"></a>\n<h1 id=\"C语言程序设计\"><a href=\"#C语言程序设计\" class=\"headerlink\" title=\"C语言程序设计\"></a>C语言程序设计</h1><h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><ol>\n<li>先上第一段代码：</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Hello world\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"This is a C program\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是一个简单的C程序，我从这里开始，解释什么的是不需要的。</p>\n<ol start=\"2\">\n<li>第二段代码：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//这个程序根据你输入的两个整数和输入的一个四则运算符进行运算</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a, b;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> Bool = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> ch;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"请输入两个整数：\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;a);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;a);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n请输入一个四则运算符：\"</span>);</span><br><span class=\"line\">    Bool = <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%c\"</span>, &amp;ch);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (ch)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'+'</span>: <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n%d + %d = %d\"</span>, a, b, a+b);</span><br><span class=\"line\">                  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'-'</span>: <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n%d - %d = %d\"</span>, a, b, a-b);</span><br><span class=\"line\">                  <span class=\"keyword\">break</span>:;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'*'</span>: <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n%d * %d = %d\"</span>, a, b, a*b);</span><br><span class=\"line\">                  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'/'</span>: <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n%d / %d = %f\"</span>, a, b, <span class=\"keyword\">float</span>(a)/b);</span><br><span class=\"line\">                  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:  <span class=\"built_in\">printf</span>(<span class=\"string\">\"输入的不是四则运算符！！！\"</span>);</span><br><span class=\"line\">                  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>OK，上面的代码写出来了！没有什么问题！记几个需要注意的地方：</p>\n<pre><code>1. `scanf()`的是有返回值，读到了几个正确的输入就返回几，例如在上面的代码的中，如果输入了一个字符，`Bool`的值就变成`1`，在这里作用不大，不过就是为了复习嘛，无所谓的啦。\n2. 注意`switch() case`语句的用法：`switch()`括号内的变量类型一定要是__整型或者字符型__。\n</code></pre><ol start=\"3\">\n<li>第三段代码：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//定义一个二维数组并初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a[<span class=\"number\">2</span>][<span class=\"number\">3</span>] = &#123;</span><br><span class=\"line\">        &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>&#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//几个指针的声明</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> *pt;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*pa)[<span class=\"number\">3</span>];  <span class=\"comment\">//注意：[]的优先级高于*</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> *pax[<span class=\"number\">3</span>];   <span class=\"comment\">//注意与上一个进行对比，这是不一样的</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ar1[<span class=\"number\">2</span>][<span class=\"number\">3</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ar2[<span class=\"number\">3</span>][<span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> **p2;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//以下均是有效的赋值</span></span><br><span class=\"line\">    pt = &amp;a[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">    pa = &amp;a[<span class=\"number\">0</span>];   <span class=\"comment\">//在这里pt和pa的值相同</span></span><br><span class=\"line\">    pa = &amp;a[<span class=\"number\">1</span>];</span><br><span class=\"line\">    p2 = &amp;pt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>从上面就可以看出来，指针这个东西还是很烦人的，不过也不难，多看几遍就行了，还有要注意指针和数组的关系。指针比数组更本质！</p>\n<ol start=\"4\">\n<li>第四段代码：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//找二维数组的鞍点，行最小且列最大的即为鞍点</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a[<span class=\"number\">20</span>][<span class=\"number\">20</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> Row, Col;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, j;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"请输入数组的行数和列数：\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, Row, Col);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n请输入%d个整数：\\n\\t\"</span>, Row*Col);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; Row; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; Col; j++)</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;a[i][j]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; Row; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = a[i][<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> f = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">1</span>; j &lt; Col; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (temp &gt; a[i][j])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                temp = a[i][j];</span><br><span class=\"line\">                k = j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; Row; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j == i)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (a[j][k] &gt; a[i][k])</span><br><span class=\"line\">                    f = <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f)</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n%d\"</span>, &amp;a[i][k]);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n无鞍点\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>我也不管什么优化了，丑就丑吧，几个循环套起来又怕什么，比比谁写的更丑，没有运行时间和内存使用限制，写起来就是爽！</p>\n<ol start=\"5\">\n<li>第五段代码：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"这是一个计算函数值的程序：\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"请输入整数x的值：\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;x);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        y = <span class=\"number\">5</span>*x;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">8</span>)</span><br><span class=\"line\">            y = <span class=\"number\">2</span>*x - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            y = x + <span class=\"number\">4</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\ny = %d\"</span>, y);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这段代码没什么意思，纯粹是送的。</p>\n<ol start=\"6\">\n<li>第六段代码：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Pri_as_ord</span><span class=\"params\">(<span class=\"keyword\">int</span> *p, <span class=\"keyword\">int</span> *q)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (*p &gt; *q)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        temp = *p;</span><br><span class=\"line\">        *p = *q;</span><br><span class=\"line\">        *q = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a, b;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"请输入两个整数：\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;a, &amp;b);</span><br><span class=\"line\">    Pri_as_ord(&amp;a, &amp;b);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"按由小到大的顺序输出：%d %d\"</span>, a, b);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>还是没什么意思，接着写！</p>\n<ol start=\"7\">\n<li>第七段代码：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*录入三个学生的学号和各自两门课的成绩</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> num;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> score1;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> score2;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Best</span><span class=\"params\">(struct Student student[], <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, m, aver[n];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">        aver[i] = (student[i].score1 + student[i].score2)/<span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (aver[<span class=\"number\">0</span>] &gt; aver[<span class=\"number\">1</span>])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (aver[<span class=\"number\">0</span>] &gt; aver[<span class=\"number\">2</span>])</span><br><span class=\"line\">            m = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            m = <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (aver[<span class=\"number\">1</span>] &gt; aver[<span class=\"number\">2</span>])</span><br><span class=\"line\">            m = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            m = <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"平均成绩最高的学生的学号是：%d\"</span>, student[m].num);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span> <span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span> <span class=\"title\">student</span>[3];</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; i &lt; <span class=\"number\">4</span>; i++)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"请输入第%d个学生的学号和两门课的成绩:%d %f %f\"</span>,</span><br><span class=\"line\">                i, student[i<span class=\"number\">-1</span>].num, student[i<span class=\"number\">-1</span>].score1, student[i<span class=\"number\">-1</span>].score2);</span><br><span class=\"line\">    Best(student, <span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>哇！写得想吐了！超级累！不管继续！</p>\n<ol start=\"8\">\n<li>第八段代码<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*这只是一个函数，用来实现删除单链表中码值相同的节点，只保留一个</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">假设节点是这样的：struct node&#123;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\tint data;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\tstruct node *next;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t&#125;;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Del</span><span class=\"params\">(struct node *head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> *<span class=\"title\">p</span>, *<span class=\"title\">q</span>, *<span class=\"title\">s</span>;</span></span><br><span class=\"line\">    p = head-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Empty List\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p-&gt;next != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            q = p-&gt;next;</span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> ((q-&gt;data != p-&gt;data) &amp;&amp; (q-&gt;next != <span class=\"literal\">NULL</span>))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    s = q;</span><br><span class=\"line\">                    q = q-&gt;next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (q-&gt;data == x)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    s-&gt;next = q-&gt;next;</span><br><span class=\"line\">                    <span class=\"built_in\">free</span> (q);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                p = s-&gt;next;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> (p != <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">            p = p-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>上面的代码有点烦，不过好在思路还算清晰，没有遇到问题，就是时间花得太长了，单链表还是不够熟练，接着来！</p>\n<ol start=\"9\">\n<li>第九段代码：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//一个队列入排操作</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">queue</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> item[max];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> front;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> rear;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化时rear=-1，front为0~max-1的任意值</span></span><br><span class=\"line\"><span class=\"comment\">//front指向队列第一个元素的前一个位置，rear指向队尾元素所在位置</span></span><br><span class=\"line\"><span class=\"comment\">//front=rear时队列满，rear=-1时队列空</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">queue</span> <span class=\"title\">q</span>;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Inqueue</span><span class=\"params\">(struct <span class=\"built_in\">queue</span> q, <span class=\"keyword\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (q.front == q.rear)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"队满\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (q.rear = <span class=\"number\">-1</span>)</span><br><span class=\"line\">            q.rear = q.front;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (q.rear = max<span class=\"number\">-1</span>)</span><br><span class=\"line\">            q.rear = <span class=\"number\">0</span>;</span><br><span class=\"line\">        q.rear += <span class=\"number\">1</span>;</span><br><span class=\"line\">        q.item[q.rear] = x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>简单的顺序存储的队列，实现入排操作不难，弄懂原理就好。</p>\n","tags":[{"name":"C/C++","slug":"C-C","permalink":"https://jonathan1214.github.io/tags/C-C/"},{"name":"数据结构","slug":"数据结构","permalink":"https://jonathan1214.github.io/tags/数据结构/"}]},{"title":"一点思考","date":"2018-04-16T14:17:54.000Z","path":"2018/04/A_little_thinking/","text":"时间总是不等人的，转眼大一快过完了，看着现在的窘境，回首过去，难免有一点伤感，如果那些时候换些选择，现在肯定不一样，不过转念一想，每准一切都是最好的安排，在那些时候做的那些选择成就了今天的我，好坏都这样吧，我得直视前方，正所谓，往者不可谏，来者犹可追。","content":"<p>时间总是不等人的，转眼大一快过完了，看着现在的窘境，回首过去，难免有一点伤感，如果那些时候换些选择，现在肯定不一样，不过转念一想，每准一切都是最好的安排，在那些时候做的那些选择成就了今天的我，好坏都这样吧，我得直视前方，正所谓，往者不可谏，来者犹可追。</p>\n","tags":[{"name":"思考","slug":"思考","permalink":"https://jonathan1214.github.io/tags/思考/"}]},{"title":"记录科创中期答辩","date":"2018-04-13T12:10:29.000Z","path":"2018/04/My_first_lose/","text":"今天下午的科创中期答辩我们组当掉了，说实话我们什么都没做，单纯的想敷衍过去，很不幸，老师没有让我们通过，4月29号要再来一次，希望可以通过吧。关于这次答辩，我还是有些东西想记下来的： 我们都有自己擅长的事，当然也有自己的绝不擅长甚至不愿触碰的事儿，很不幸，上台发言就是我不愿触碰的事儿，我害怕自己讲不清楚，害怕自己口齿不清，害怕失败，这或许是这次失败的一个重要原因吧。我们应该考虑下次答辩换一个人的，换一个会说的人，再有就是大二科创一定要好好选队友，海鹏非常可以，有拼劲儿，天行表达非常好，到时候再说，我只是一个中规中矩的驱动人物罢了，现在需要多学一点知识，也好让人家接受你成为队友。 我算是认识到了，要想做好一件事情，一个好的态度是非常是非常重要的。对应到这次科创，这态度体现在，如下几个方面，我们有没有好好做这个项目或者说有没有做，有没有认真准备PPT，有没有认真准备报告。总结起来就是既要好好做也要好好说，anyway，这一次已经过去了，我们要把剩下的路走完。 合理安排自己的时间，不要再浪费了，有许多美好值得去追求，有很多有意义的事儿可以去做，不要再浪费时间做一些没有意义的如玩手机的事儿了。 最后，不要再赶ddl，一定要提前做好。","content":"<p>今天下午的科创中期答辩我们组当掉了，说实话我们什么都没做，单纯的想敷衍过去，很不幸，老师没有让我们通过，4月29号要再来一次，希望可以通过吧。<br><a id=\"more\"></a><br>关于这次答辩，我还是有些东西想记下来的：</p>\n<p>我们都有自己擅长的事，当然也有自己的绝不擅长甚至不愿触碰的事儿，很不幸，上台发言就是我不愿触碰的事儿，我害怕自己讲不清楚，害怕自己口齿不清，害怕失败，这或许是这次失败的一个重要原因吧。我们应该考虑下次答辩换一个人的，换一个会说的人，再有就是大二科创一定要好好选队友，海鹏非常可以，有拼劲儿，天行表达非常好，到时候再说，我只是一个中规中矩的驱动人物罢了，现在需要多学一点知识，也好让人家接受你成为队友。</p>\n<p>我算是认识到了，要想做好一件事情，一个好的态度是非常是非常重要的。对应到这次科创，这态度体现在，如下几个方面，我们有没有好好做这个项目或者说有没有做，有没有认真准备PPT，有没有认真准备报告。总结起来就是既要好好做也要好好说，anyway，这一次已经过去了，我们要把剩下的路走完。</p>\n<p>合理安排自己的时间，不要再浪费了，有许多美好值得去追求，有很多有意义的事儿可以去做，不要再浪费时间做一些没有意义的如玩手机的事儿了。</p>\n<p>最后，不要再赶ddl，一定要提前做好。</p>\n","tags":[{"name":"记录","slug":"记录","permalink":"https://jonathan1214.github.io/tags/记录/"}]}]