---
title: 作用域，连接属性以及存储类型
date: 2020-10-15 16:47:34
updated:
categories:
  - 学习
tags:
  - C/C++
---

逃避手中的难事，看看 C 中标识符的作用域、链接属性和存储类型是如何区分的吧。

以下内容为阅读《C 和指针》时做的笔记。pp39-47。

<!-- more -->

##  作用域

当变量在程序的某个部分被声明时，它只有在程序的一定区域才能被访问，这个区域由标识符的作用域决定。

> 标识符的作用域就是程序中该标识符可以被使用的区域。

这意味着，作用域之外无法访问这些变量，分属不同作用域的变量可以有相同的名字。

编译器可以确认 4 种不同类型的作用域——文件作用域、函数作用域、代码作用域和原型作用域。标识符声明的位置决定它的作用域。

+ **代码块作用域**：位于一堆花括号之间的所有语句称为一个代码块，任何在代码块开始位置声明的标识符都具有代码块作用域（block scope）。
+ **文件作用域**：任何在代码块之外声明的标识符都具有文件作用域（file scope）。它表示这些标识符从它们的声明之处直到它所在的源文件结尾处都是可以访问的。文件中定义的函数名也具有文件作用域。
+ **原型作用域**：只适用于在函数原型中声明的参数名。
+ **函数作用域**：只适用于语句标签，在`goto` 语句中使用。（不用理会）

## 链接属性

标识符的链接属性决定如何处理在不同文件中出现的标识符。标识符的作用域与它的链接属性有关，但两个属性并不相同。

链接属性一共 3 种——`external`、`internal` 和 `none`。

+ `none`：拥有该属性的标识符被当作单独的个体，即该标识符的多个声明被当作独立不同的实体。
+ `internal`：拥有该属性的标识符在同一个源文件内的所有声明都指同一个实体，位于不同源文件的多个声明分属不同的实体。
+ `external`：拥有该属性的标识符不论声明多少次，位于多个源文件的标识符都表示同一实体。

如下例子所示，其中，b、c 和 f 的链接属性为 external，其余标识符的链接属性为 none。

```c
typedef char *a;
int b;
int c( int d )
{
    int e;
    int f(int g);
    ...
}
```

除了缺省时的链接属性之外，关键字 `extern` 和 `static` 用于在声明中修改标识符的链接属性。

如果某个声明缺省时为 `external` 链接属性，在它前面加上 `static` 关键字可以使它的链接属性变为 `internal`。如：`static int b;`。那么变量 b 将为这个源文件所私有。此外，**`static`只对缺省链接属性为 `external` 的声明才有改变链接属性的效果**。

`external` 关键字的规则更加复杂。一般来说，**当它为一个标识符指定 `external` 链接属性时，就可以访问在其他任何位置定义的这个实体**。

> 如果你在一个地方定义变量，请在使用这个变量的其他源文件的声明中添加 `extern` 关键字。

当 `extern` 关键字用于源文件中一个标识符的第 1 次声明时，它指定该标识符具有 `external` 链接属性，但如果它用于该标识符的第 2 次或以后的声明时，它并不会更改由第 1 次声明所指定的链接属性。

## 存储类型

变量的存储类型是指存储变量值的内存类型，它决定变量何时创建、何时销毁以及它的值讲保持多久。三种类型：普通内存、运行时堆栈和硬件寄存器。

**变量缺省存储类型取决于它的声明位置。**凡是在任何代码块之外声明的变量总是存储于静态内存中，即不属于堆栈的内存，这类变量被称为*静态变量*。这类变量无法为其指定存储类型。静态变量在程序执行前创建，一直存在。

在代码块内部声明的变量的缺省存储类型是自动的（automatic），即它存储于堆栈中，称为**自动变量**。自动变量在代码块执行完毕后就消失，当代码块再次执行时，它们的值一般并不是上次执行时的值。注意，修改变量的存储类型并不表示修改该变量的作用域，它仍然只能在该代码块内部按照名字访问。

静态变量和自动变量的初始化存在重要差别。静态变量在可执行文件载入内存时，已经保存了正确初始值的位置将赋值给那个变量，完成这个任务不需要额外的时间和指令，默认初始化为 0。而自动变量的初始化需要更多的开销。事实上，自动变量没有缺省的初始值，而显示初始化将在代码块的起始处插入一条隐式的赋值语句，这导致：

+ 除声明 const 变量之外，在声明变量时同时进行初始化和先声明后赋值只有风格之差，而无效率之别。
+ 这条隐式的赋值语句使自动变量在程序执行到它们所声明的函数时，每次都将重新初始化。
+ 由于初始化在程序运行时执行，因而可以用任何表达式作为初始化值。
+ 若不对自动变量进行初始化，其值总是垃圾。

## `static` 关键字

如前面所言，`static` 关键字有两个用途：修改链接属性和修改存储类型。

当 `static` 用于函数定义时，或用于代码块之外的变量声明时，它用于修改标识符的链接属性，从 `external` 改为 `internal`，但不影响标识符的存储类型和作用域。用这种方式声明的函数或变量只能在声明它们的源文件中访问。

当它用于代码块内部的变量时，static 关键字用于修改变量的存储类型，从自动变量改为静态变量，但变量的链接属性和作用域不受影响。

## 总结

| 变量类型 | 声明的位置     | 是否存储于堆栈 | 作用域           | 如果声明为 `static`                              |
| -------- | -------------- | -------------- | ---------------- | ------------------------------------------------ |
| 全局     | 所有代码块之外 | 否             | 从声明处到文件尾 | 不允许其他源文件访问                             |
| 局部     | 代码块起始处   | 是             | 整个代码块       | 变量不存储于堆栈中，其值在程序整个执行期一直保持 |
| 形式参数 | 函数头部       | 是             | 整个函数         | 不允许                                           |



